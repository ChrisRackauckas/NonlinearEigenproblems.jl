# Tutorial: Solving a NEP defined in fortran

## A problem defined in fortran

A situation may arise where you will have to
(or have the opportunity to) work with fortran.
This is not as uncommon as many think, mostly
due to the legacy software in many engineering fields.
The Julia language is designed
with interoperability in mind, and to call
fortran routines should not scare you.

We assume our NEP is defined by the following fortran code
which corresponds to this NEP:
```math
M(\lambda)=A_0+\lambda^3e_ne_1^T+\exp(\lambda)e_1e_n^T.
```
where ``A_0`` is a finite difference approximation of a scaled
Laplacian matrix. This problem is obviously nice to represent
in a sparse format.

We suppose the problem is defined in fortran,
where the following routine returns (or sets)
three vectors `I`, `J` and `F`, where `I` and `J`
correspond to row and column pointers and `F` the value.
The variable `s=λ` is the evaluation point.
The input `der` determines which derivative
of `M` should be computed (if derivatives are not easily available,
see below).

Suppose the following is contained in `myproblem.f95`:
```fortran
subroutine mder(s,n,der,I,J,F)
  real*8, intent(in) :: s
  integer*8, intent(in) :: n
  integer*8, intent(in) :: der
  integer*8, intent(out), dimension(3*n):: I
  integer*8, intent(out), dimension(3*n):: J
  real*8, intent(out), dimension(3*n):: F
  integer*8 :: p
  real*8 :: factor
  if (der==0) then
     factor=1;
  else
     factor=0;
  end if
  do p = 1, n
     I(p) = p
     J(p) = p
     F(p) = 2.0*factor;
  end do
  do p = 1, n-1
     I(n+p) = p
     J(n+p) = p+1
     F(n+p) = -1.0*factor;
     I(2*n+p) = p+1
     J(2*n+p) = p
     F(2*n+p) = -1.0*factor;
  end do
  I(2*n)=n;
  J(2*n)=1;
  if (der == 0) then
     F(2*n)=s*s*s;
  else if (der == 1) then
     F(2*n)=3*s*s;
  else if (der == 2) then
     F(2*n)=3*2*s;
  else if (der == 3) then
     F(2*n)=3*2;
  else
     F(2*n)=0;
  end if
  I(3*n)=1;
  J(3*n)=n;
  F(3*n)=-exp(s);
end subroutine compute_Mder_legacy
```
## Compile and call the code
```
Compile the code to a shared object file. With ubuntu
linux and GNU fortran, this is achieved with
```bash
$ gfortran -shared -fPIC -o myproblem.so myproblem.f95
```
In Julia, you can now call this routine using the `Libdl`
library:
```julia
using Libdl;
mylib=Libdl.dlopen("./myproblem.so")
input_types=(Float64, Int, Int)
input_types_ref=map(S -> Ref{S}, input_types)
output_types=(Int, Int, Float64)
output_types_ptr=map(S -> Ptr{S}, output_types)
type_list=(input_types_ref...,output_types_ptr...)
λ=0.3;
der=0;
n=3; # Problem size
I=Vector{Int}(undef,3*n); # 3*n nnz elements in matrix
J=Vector{Int}(undef,3*n); # 3*n nnz elements in matrix
F=Vector{Float64}(undef,3*n); # 3*n nnz elements in matrix
ccall(Libdl.dlsym(mylib,:mder_), Nothing,
   (Ref{Float64}, Ref{Int},Ref{Int},  Ptr{Int}, Ptr{Int}, Ptr{Float64}),
   λ, n, der, I, J, F)
```
The above code sets vectors `I`, `J` and `F` such that they
represent a sparse matrix. The sparse matrix can be
constructed with the `sparse` command:
```julia
julia> using SparseArrays
julia> A=sparse(I,J,F)
3×3 SparseMatrixCSC{Float64,Int64} with 9 stored entries:
  [1, 1]  =  2.0
  [2, 1]  =  -1.0
  [3, 1]  =  0.027
  [1, 2]  =  -1.0
  [2, 2]  =  2.0
  [3, 2]  =  -1.0
  [1, 3]  =  -1.34986
  [2, 3]  =  -1.0
  [3, 3]  =  2.0
julia> Matrix(A)
3×3 Array{Float64,2}:
  2.0    -1.0  -1.34986
 -1.0     2.0  -1.0
  0.027  -1.0   2.0
```

## Implementation in NEP-PACK: basic usage

The above provides a mean to compute a derivative
matrix. This is sufficient to construct a NEP, with
the `Mder_NEP` type.

```julia
julia> n=100;
julia> function my_Mder(λ::Float64,der::Int=0)
  I=Vector{Int}(undef,3*n); # 3*n nnz elements in matrix
  J=Vector{Int}(undef,3*n); # 3*n nnz elements in matrix
  F=Vector{Float64}(undef,3*n); # 3*n nnz elements in matrix
  ccall(Libdl.dlsym(mylib,:mder_), Nothing,
     (Ref{Float64}, Ref{Int},Ref{Int},  Ptr{Int}, Ptr{Int}, Ptr{Float64}),
     λ, n, der, I, J, F)
  return sparse(I,J,F);
end
julia> nep=Mder_NEP(n,my_Mder)
julia> quasinewton(Float64,nep,λ=-1.8,v=ones(n), displaylevel=1)
Precomputing linsolver
Iteration:  1 errmeasure:4.903565024143569095e-01, λ=-1.8
Iteration:  2 errmeasure:8.776860766232853772e-02, λ=-1.3816406142423465
Iteration:  3 errmeasure:6.109070850428219984e-02, λ=-2.0060080798679913
...
Iteration: 11 errmeasure:5.305001776886219717e-12, λ=-1.7940561686588974
Iteration: 12 errmeasure:2.895637837297152945e-14, λ=-1.7940561686787597
Iteration: 13 errmeasure:3.874312247075750238e-16, λ=-1.7940561686786516
(-1.7940561686786516, [76.9596, 80.634, 84.3084, 87.9827, 91.6571, 95.3315, 99.0059, 102.68, 106.355, 110.029  …  407.653, 411.328, 415.002, 418.676, 422.351, 426.025, 429.699, 433.374, 437.048, 440.723])
```


## Implementation in NEP-PACK: basic usage, no derivatives

In the above example, all the derivatives of `M`
were available in the function call. The nonlinearity
is in many cases complicated, and its derivatives
may require man-hours to compute, or may be very
computationally expensive.

Many algorithms do not require a very accurate derivative,
and we now show how you can make a finite difference
approximation of the derivative available, if you
do not want to compute the exact derivative.
(We now suppose the code above ignores the `der`
variable.)

```julia
julia> n=100;
julia> function my_Mder_FD(λ::Float64,der::Int=0)
  if (der>1)
   error("Higher derivatives not supported");
  end
  # 3*n nnz elements in matrix
  I=Vector{Int}(undef,3*n);
  J=Vector{Int}(undef,3*n);
  F1=Vector{Float64}(undef,3*n);
  ccall(Libdl.dlsym(mylib,:mder_), Nothing,
     (Ref{Float64}, Ref{Int},Ref{Int},  Ptr{Int}, Ptr{Int}, Ptr{Float64}),
     λ, n, 0, I, J, F1)
  if (der==0)
     return sparse(I,J,F1);
  end

  if (der==1)
     # Make another fortran call to make a finite difference approximation
     ee=sqrt(eps());
     F2=Vector{Float64}(undef,3*n);
     ccall(Libdl.dlsym(mylib,:mder_), Nothing,
          (Ref{Float64}, Ref{Int},Ref{Int},  Ptr{Int}, Ptr{Int}, Ptr{Float64}),
          λ-ee, n, 0, I, J, F2)
     # We exploit the fact that the sparsity pattern is independent of λ
     Fder=(F1-F2)/ee;
     return sparse(I,J,Fder);
  end
end
julia> nep=Mder_NEP(n,my_Mder_FD)
julia> quasinewton(Float64,nep,λ=-1.8,v=ones(n), displaylevel=1)
Precomputing linsolver
Iteration:  1 errmeasure:4.903565024143569095e-01, λ=-1.8(300,)
Iteration:  2 errmeasure:8.776860702961868099e-02, λ=-1.3816406181760241
Iteration:  3 errmeasure:6.109070348286420316e-02, λ=-2.00600806462913
Iteration:  4 errmeasure:6.147228750365956243e-03, λ=-1.823378852531689
...
Iteration: 10 errmeasure:9.823321222968297101e-10, λ=-1.7940561723368231
Iteration: 11 errmeasure:5.308106556085355029e-12, λ=-1.7940561686588856
Iteration: 12 errmeasure:2.895687526650138902e-14, λ=-1.7940561686787595
Iteration: 13 errmeasure:5.066228972915048590e-16, λ=-1.7940561686786511
(-1.7940561686786511, [76.9596, 80.634, 84.3084, 87.9827, 91.6571, 95.3315, 99.0059, 102.68, 106.355, 110.029  …  407.653, 411.328, 415.002, 418.676, 422.351, 426.025, 429.699, 433.374, 437.048, 440.723])
```


## Implementation in NEP-PACK (advanced usage)


