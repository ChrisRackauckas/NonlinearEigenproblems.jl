<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 6 (Python 2) · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../methods/">NEP-Solvers</a></li><li><a class="toctext" href="../types/">Types &amp; Data structures</a></li><li><a class="toctext" href="../compute_functions/">Compute functions</a></li><li><a class="toctext" href="../linsolvers/">Linear solvers</a></li><li><a class="toctext" href="../innersolvers/">Projection</a></li><li><a class="toctext" href="../errmeasure/">Measuring the error</a></li><li><a class="toctext" href="../logger/">Logger</a></li><li><a class="toctext" href="../transformations/">Transformations</a></li><li><a class="toctext" href="../deflation/">Deflation</a></li><li><a class="toctext" href="../gallery/">Gallery</a></li></ul></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="toctext" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="toctext" href="../tutorial_call_python/">Tutorial 5 (Python 1)</a></li><li class="current"><a class="toctext" href>Tutorial 6 (Python 2)</a><ul class="internal"><li><a class="toctext" href="#PyJulia-1">PyJulia</a></li><li><a class="toctext" href="#Using-PyJulia-and-NEP-PACK-1">Using PyJulia and NEP-PACK</a></li></ul></li><li><a class="toctext" href="../tutorial_matlab1/">Tutorial 7 (MATLAB)</a></li><li><a class="toctext" href="../tutorial_fortran1/">Tutorial 8 (FORTRAN)</a></li><li><a class="toctext" href="../tutorial_nano1/">Tutorial 9 (gmsh + nanophotonics)</a></li><li><a class="toctext" href="../tutorial_newmethod/">Tutorial 10 (New solver)</a></li><li><a class="toctext" href="../tutorial_linsolve/">Tutorial 11 (Linear solvers)</a></li><li><a class="toctext" href="../hydrotutorial/">Tutorial 12 (Orr–Somerfeld)</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href>Tutorial 6 (Python 2)</a></li></ul><a class="edit-page" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/tutorial_python_call.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial 6 (Python 2)</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial:-Using-NEP-PACK-from-python-1" href="#Tutorial:-Using-NEP-PACK-from-python-1">Tutorial: Using NEP-PACK from python</a></h1><h2><a class="nav-anchor" id="PyJulia-1" href="#PyJulia-1">PyJulia</a></h2><p>The previous tutorial illustrated how a NEP defined in python code can be solved with NEP-PACK. Python is currently a more mature language than Julia, and there are considerable packages and features in python not present in Julia. If you need these features, it may be more convenient to call NEP-PACK from  python, rather than calling python code from julia.</p><p>The python package <a href="https://github.com/JuliaPy/pyjulia">PyJulia</a> gives us that possibility. The installation of PyJulia on Ubuntu linux is simple:</p><pre><code class="language-none">$ python3 -m pip install julia # Only necessary first time you run it
...
$ python3
&gt;&gt;&gt; from julia.api import Julia
&gt;&gt;&gt; jl = Julia(compiled_modules=False) # compilation flag necessary on ubuntu
&gt;&gt;&gt; julia.install()               # Only necessary first time you run it
&gt;&gt;&gt; from julia import Base
&gt;&gt;&gt; Base.MathConstants.golden  # Julia&#39;s definition of golden ratio
1.618033988749895</code></pre><h2><a class="nav-anchor" id="Using-PyJulia-and-NEP-PACK-1" href="#Using-PyJulia-and-NEP-PACK-1">Using PyJulia and NEP-PACK</a></h2><p>The <a href="../compute_functions/#NonlinearEigenproblems.NEPTypes.Mder_NEP"><code>Mder_NEP</code></a>-function provides a convenient way to define NEPs by only using a function that computes the matrix <span>$M(λ)$</span> and its derivatives. Let us first define a function which does that in python. We consider the problem</p><div>\[M(λ)=\begin{bmatrix}3&amp;2\newline3&amp;-1\end{bmatrix}+
λ\begin{bmatrix}0&amp;2\newline0&amp;1\end{bmatrix}+
e^{0.5 λ}\begin{bmatrix}1&amp;1\newline1&amp;1\end{bmatrix}\]</div><p>and implement it with this python code:</p><pre><code class="language-python">import numpy as np;
import cmath as m;
def my_compute_M(s,der):
    &quot;&quot;&quot;Compute the matrix M^{(k)}(s) for a given eigenvalue approximation and derivative k&quot;&quot;&quot;
    A=np.matrix(&#39;3 2; 3 -1&#39;);  B=np.matrix(&#39;0 2; 0 1&#39;);   C=np.matrix(&#39;1 1; 1 1&#39;);
    tau=0.5;
    M=pow(tau,der)*m.exp(tau*s)*C
    if (der==0):
        M=M+A+s*B;
    elif (der==1):
        M=M+B;
    return M</code></pre><p>An evaluation of the matrix function can be done by the call:</p><pre><code class="language-none">&gt;&gt;&gt; my_compute_M(0.3,0)
matrix([[4.16183424+0.j, 3.76183424+0.j],
        [4.16183424+0.j, 0.46183424+0.j]])</code></pre><p>We instantiate a new NEP based with <code>Mder_NEP</code> which first must be imported</p><pre><code class="language-none">&gt;&gt;&gt; from julia.NonlinearEigenproblems import Mder_NEP
&gt;&gt;&gt; n=2; # Size of the problem
&gt;&gt;&gt; nep=Mder_NEP(2,my_compute_M);</code></pre><p>and we can apply most of our solvers to this problem by first importing the corresponding function, in this case we use <a href="../methods/#NonlinearEigenproblems.NEPSolver.contour_beyn"><code>contour_beyn</code></a>.</p><pre><code class="language-none">&gt;&gt;&gt; from julia.NonlinearEigenproblems import contour_beyn;
&gt;&gt;&gt; sol=contour_beyn(nep,logger=1,neigs=1,radius=3)
Computing integrals
NonlinearEigenproblems.NEPSolver.MatrixTrapezoidal: computing G...
NonlinearEigenproblems.NEPSolver.MatrixTrapezoidal: summing terms........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
Computing SVD prepare for eigenvalue extraction  p=1
Computing eigenvalues
Computing eigenvectors
&gt;&gt;&gt;</code></pre><p>We can verify that we computed a solution as follows</p><pre><code class="language-none">&gt;&gt;&gt; s=sol[0][0]; v=sol[1]
&gt;&gt;&gt; my_compute_M(s,0)*v
matrix([[1.71634841e-17-1.59872116e-14j],
        [9.55210099e-17-3.99680289e-15j]])
&gt;&gt;&gt; from numpy.linalg import norm
&gt;&gt;&gt; norm(my_compute_M(s,0)*v)
1.6479526251408437e-14</code></pre><p>Note that in order to obtain better efficiency for large-scale problems, and reduce overhead, you may want to use <a href="../compute_functions/#NonlinearEigenproblems.NEPTypes.Mder_Mlincomb_NEP"><code>Mder_Mlincomb_NEP</code></a>, as described in the <a href="../tutorial_call_python/">previous tutorial</a>.</p><p><img src="http://jarlebring.se/onepixel.png?NEPPACKDOC_PYTHON2" alt="To the top"/></p><footer><hr/><a class="previous" href="../tutorial_call_python/"><span class="direction">Previous</span><span class="title">Tutorial 5 (Python 1)</span></a><a class="next" href="../tutorial_matlab1/"><span class="direction">Next</span><span class="title">Tutorial 7 (MATLAB)</span></a></footer></article></body></html>
