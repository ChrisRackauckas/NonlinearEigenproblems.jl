<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial: Combining methods and problems · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../methods/">NEP Methods</a></li><li><a class="toctext" href="../types/">NEP Types</a></li><li><a class="toctext" href="../linsolvers/">LinSolver</a></li><li><a class="toctext" href="../errmeasure/">Error measure</a></li><li><a class="toctext" href="../logger/">Logger</a></li><li><a class="toctext" href="../transformations/">NEP Transformations</a></li><li><a class="toctext" href="../gallery/">NEP Gallery</a></li><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="toctext" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="toctext" href="../tutorial_call_python/">Tutorial 5 (Python NEP)</a></li><li><a class="toctext" href="../tutorial_matlab1/">Tutorial 6 (MATLAB 1)</a></li><li><a class="toctext" href="../tutorial_fortran1/">Tutorial 7 (FORTRAN 1)</a></li><li><a class="toctext" href="../tutorial_nano1/">Tutorial 8 (gmsh + nanophotonics)</a></li><li><a class="toctext" href="../tutorial_newmethod/">Tutorial 9 (New solver)</a></li><li><a class="toctext" href="../tutorial_linsolve/">Tutorial 10 (Linear solvers)</a></li><li><a class="toctext" href="../hydrotutorial/">Tutorial 11 (Orr-Somerfeld)</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Tutorial: Combining methods and problems</a></li></ul><a class="edit-page" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/tutorial_combine.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial: Combining methods and problems</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial:-Combining-methods-and-problems-1" href="#Tutorial:-Combining-methods-and-problems-1">Tutorial: Combining methods and problems</a></h1><p>The NEP-solvers available in NEP-PACK, all have different properties for different problems, e.g., some methods can reliably compute a general not necessarily accurate solution, whereas other methods are extremely efficient to refine an eigenpair approximation.</p><p>Problems stemming from PDEs often have an accuracy parameter (e.g. step length). This can be exploited in several NEP-PACK methods.</p><h2><a class="nav-anchor" id="Two-stage-approach-1" href="#Two-stage-approach-1">Two-stage approach</a></h2><p>The two-stage approach is quite common in the field of nonlinear eigenvalue problems:</p><ul><li>Compute many approximations of eigenvalues of interested eigenvalues</li><li>Refine the eigenvalues with a locally iterative method</li></ul><p>This can be achieved in this way in NEP-PACK:</p><pre><code class="language-none">julia&gt; nep=nep_gallery(&quot;dep0&quot;,1000);
julia&gt; # Solve very inaccurately with Beyn&#39;s contour method
julia&gt; (λ,v)=contour_beyn(nep,k=10,σ=0, radius=3,N=10, sanity_check=false)
julia&gt; λgood=Vector{eltype(λ)}(undef,0)
julia&gt; vgood=Matrix{eltype(v)}(undef,size(nep,1),0);
julia&gt; for i = 1:size(λ,1)
try
  (λnew,vnew)=quasinewton(nep, λ=λ[i],v=v[:,i],maxit=100,tol=1e-10,armijo_factor=0.5)
  λ[i]=λnew; v[:,i]=vnew;
  push!(λgood,λnew);
  vgood=hcat(vgood,v);
catch e
  if (e isa NoConvergenceException)
    println(&quot;Failed to refine eigval:&quot;,λ[i])
  end
end

end</code></pre><h2><a class="nav-anchor" id="Exploiting-parameters-in-eigenvalues-1" href="#Exploiting-parameters-in-eigenvalues-1">Exploiting parameters in eigenvalues</a></h2><p>We revisit the problem [bemtutorial.md] which is directly available in the gallery</p><pre><code class="language-none">julia&gt; N=3; # Discretization parameter
julia&gt; nep3=nep_gallery(&quot;bem_fichera&quot;,N);
julia&gt; size(nep3)
(384, 384)
julia&gt; N=1; # Less accurate
julia&gt; nep1=nep_gallery(&quot;bem_fichera&quot;,N);
julia&gt; size(nep1)
(96, 96)
julia&gt; nep6=nep_gallery(&quot;bem_fichera&quot;,6);</code></pre><p>This is a difficult problem in the sense that assembling the matrix is computationally expensive:</p><pre><code class="language-none">julia&gt; using BenchmarkTools
julia&gt; @btime compute_Mder(nep1,3.0)
  116.564 ms (824122 allocations: 111.90 MiB)
julia&gt; @btime compute_Mder(nep3,3.0)
  1.910 s (13083850 allocations: 1.73 GiB)
julia&gt; @btime compute_Mder(nep6,3.0)
  10.383 s (66141370 allocations: 8.77 GiB)</code></pre><p><img src="http://jarlebring.se/onepixel.png?NEPPACKDOC_TUTORIAL" alt="To the top"/></p><footer><hr/></footer></article></body></html>
