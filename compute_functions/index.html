<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Compute functions · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../methods/">NEP-Solvers</a></li><li><a class="toctext" href="../types/">NEP Types</a></li><li class="current"><a class="toctext" href>Compute functions</a><ul class="internal"><li><a class="toctext" href="#Compute-functions-documentation-1">Compute-functions documentation</a></li><li><a class="toctext" href="#Type-helpers-1">Type helpers</a></li></ul></li><li><a class="toctext" href="../linsolvers/">LinSolvers</a></li><li><a class="toctext" href="../innersolvers/">Projection</a></li><li><a class="toctext" href="../errmeasure/">Measuring the error</a></li><li><a class="toctext" href="../logger/">Logger</a></li><li><a class="toctext" href="../transformations/">Transformations</a></li><li><a class="toctext" href="../deflation/">Deflation</a></li><li><a class="toctext" href="../gallery/">Gallery</a></li></ul></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="toctext" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="toctext" href="../tutorial_call_python/">Tutorial 5 (Python)</a></li><li><a class="toctext" href="../tutorial_matlab1/">Tutorial 6 (MATLAB)</a></li><li><a class="toctext" href="../tutorial_fortran1/">Tutorial 7 (FORTRAN)</a></li><li><a class="toctext" href="../tutorial_nano1/">Tutorial 8 (gmsh + nanophotonics)</a></li><li><a class="toctext" href="../tutorial_newmethod/">Tutorial 9 (New solver)</a></li><li><a class="toctext" href="../tutorial_linsolve/">Tutorial 10 (Linear solvers)</a></li><li><a class="toctext" href="../hydrotutorial/">Tutorial 11 (Orr-Somerfeld)</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Compute functions</a></li></ul><a class="edit-page" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/compute_functions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Compute functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Compute-functions-1" href="#Compute-functions-1">Compute functions</a></h1><p>The nonlinear eigenvalue problems in NEP-PACK are defined by the data stored in the corresponding NEP-class. The advised way NEP-solvers access the data is to do it through three main functions, which take the NEP-object as input.</p><ul><li><a href="#NonlinearEigenproblems.NEPCore.compute_Mder"><code>compute_Mder</code></a>: Computes a given derivative of the matrix function <span>$M(λ)$</span>.</li><li><a href="@ref"><code>compute_Mlincomb</code></a>: Computes a linear combination of derivatives <span>$M(λ)$</span></li><li><a href="#NonlinearEigenproblems.NEPCore.compute_MM"><code>compute_MM</code></a>: Computes the block residual.</li></ul><p>As a NEP-solver developer, <code>compute_Mlincomb</code>-calls are preferred over <code>compute_Mder</code>-calls, for the same reasons that algorithms that only require matrix vector products can be easier to use in a given application than an iterative algorithm using only matrix vector products. It is in general also more efficient although they produce the same result up to round-off errors:</p><pre><code class="language-julia-repl">julia&gt; using BenchmarkTools;
julia&gt; n=1000; p=10;
julia&gt; nep=DEP([randn(n,n), randn(n,n)];
julia&gt; V=randn(n,p);
julia&gt; @btime compute_Mlincomb(nep,1.0,V);
  478.316 μs (19 allocations: 80.78 KiB)
julia&gt; @btime for k=1:p; z[:]+=compute_Mder(nep,1.0,k)*V[:,k]; end
  78.510 ms (183 allocations: 465.71 MiB)</code></pre><p>The <code>compute_Mlincomb</code>-function exist in two variants, where <code>compute_Mlincomb!</code> may modify the <code>V</code>-matrix, but in general require less memory allocations.</p><p>A type where only <code>compute_Mder</code> is implemented, the <code>compute_Mlincomb</code>-functionality can be provided by delegating using the function <a href="#NonlinearEigenproblems.NEPCore.compute_Mlincomb_from_Mder"><code>compute_Mlincomb_from_Mder</code></a>.</p><p>A user who needs a new class of NEPs (which is not available in among the standard types) is advised to use the helper functions <a href="#NonlinearEigenproblems.NEPTypes.Mder_NEP"><code>Mder_NEP</code></a> and/or <a href="#NonlinearEigenproblems.NEPTypes.Mder_Mlincomb_NEP"><code>Mder_Mlincomb_NEP</code></a> since they are more user friendly. Implementation of your own NEP-type is only advised if needed for efficiency reasons.</p><h2><a class="nav-anchor" id="Compute-functions-documentation-1" href="#Compute-functions-documentation-1">Compute-functions documentation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPCore.compute_Mder" href="#NonlinearEigenproblems.NEPCore.compute_Mder"><code>NonlinearEigenproblems.NEPCore.compute_Mder</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">compute_Mder(nep::NEP,λ::Number [,i::Integer=0])</code></pre><p>Computes the ith derivative of <code>nep</code> evaluated in <code>λ</code>.</p><p><strong>Example</strong></p><p>This example shows that <code>compute_Mder(nep,λ,1)</code> gives the first derivative.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; ϵ=1e-5;
julia&gt; Aminus=compute_Mder(nep,λ-ϵ);
julia&gt; Aminus=compute_Mder(nep,λ-ϵ);
julia&gt; Aplus=compute_Mder(nep,λ+ϵ);
julia&gt; opnorm((Aplus-Aminus)/(2ϵ)-compute_Mder(nep,λ,1))
1.990970375089371e-11</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPCore.compute_Mlincomb!" href="#NonlinearEigenproblems.NEPCore.compute_Mlincomb!"><code>NonlinearEigenproblems.NEPCore.compute_Mlincomb!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">compute_Mlincomb(nep::NEP,λ::Number,V, a::Vector=ones(size(V,2)), startder=0)
compute_Mlincomb!(nep::NEP,λ::Number,V, a::Vector=ones(size(V,2)), startder=0)</code></pre><p>Computes the linear combination of derivatives<br/><span>$Σ_i a_i M^{(i)}(λ) v_i$</span> starting from derivative <code>startder</code>. The function <code>compute_Mlincomb!</code> does the same but may modify the <code>V</code> matrix/array.</p><p><strong>Example</strong></p><p>This example shows that <code>compute_Mder</code> gives a result consistent with <code>compute_Mlincomb</code>. Note that <code>compute_Mlincomb</code> is in general faster since no matrix needs to be constructed.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; v=ones(size(nep,1)); λ=-1+1im;
julia&gt; norm(compute_Mder(nep,λ,1)*v-compute_Mlincomb(nep,λ,hcat(v,v),[0,1]))
1.0778315928076987e-15
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPCore.compute_MM" href="#NonlinearEigenproblems.NEPCore.compute_MM"><code>NonlinearEigenproblems.NEPCore.compute_MM</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">compute_MM(nep::NEP,S,V)</code></pre><p>Computes the sum <span>$Σ_i M_i V f_i(S)$</span> for a NEP, where <span>$S$</span> and <span>$V$</span> are matrices, and the NEP satisfies <span>$M(λ)=Σ_i M_i f_i(λ)$</span>.</p><p><strong>Example</strong></p><p>This example shows that for diagonal <code>S</code>, the result of <code>compute_MM</code> can also be computed with <code>compute_Mlincomb</code></p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; D=diagm(0 =&gt; [1,2])
2×2 Array{Int64,2}:
 1  0
 0  2
julia&gt; V=ones(size(n,1),2);
julia&gt; W=compute_MM(nep,D,V);
julia&gt; norm(W[:,1]-compute_Mlincomb(nep,D[1,1],V[:,1]))
1.1102230246251565e-16
julia&gt; norm(W[:,2]-compute_Mlincomb(nep,D[2,2],V[:,2]))
0.0</code></pre><p><strong>Reference</strong></p><p>Properties of the quantity <span>$Σ_i M_i V f_i(S)$</span> for non-polynomial nonlinear eigenvalue problems were extensively used in:</p><ul><li>D. Kressner A block Newton method for nonlinear eigenvalue problems, Numer. Math., 114 (2) (2009), pp. 355-372</li><li>C. Effenberger, Robust solution methods for nonlinear eigenvalue problems, PhD thesis, 2013, EPF Lausanne</li></ul></div></div></section><h2><a class="nav-anchor" id="Type-helpers-1" href="#Type-helpers-1">Type helpers</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPCore.compute_Mlincomb_from_Mder" href="#NonlinearEigenproblems.NEPCore.compute_Mlincomb_from_Mder"><code>NonlinearEigenproblems.NEPCore.compute_Mlincomb_from_Mder</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">compute_Mlincomb_from_Mder(nep::NEP,λ::Number,V,a)</code></pre><p>The function computes <code>Mlincomb</code> by a call to <code>compute_Mder</code>. This function is slow since it requires the construction of the matrices. Usage normally by overloading in this way</p><pre><code class="language-julia">    compute_Mlincomb(nep::MyNEP,λ::Number,V,a)=compute_Mlincomb_from_Mder(nep,λ,V,a)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.Mder_NEP" href="#NonlinearEigenproblems.NEPTypes.Mder_NEP"><code>NonlinearEigenproblems.NEPTypes.Mder_NEP</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Mder_NEP(n,Mder_fun; maxder=max)</code></pre><p>Creates a <code>NEP</code> from its <code>compute_Mder</code> function defined by the function handle <code>Mder_fun</code>. The <code>Mder_fun(λ,der)</code> takes two parameters a scalar <code>λ::Number</code>, derivative number  <code>der</code>. The size <code>n::Int</code> must also be specified. The function <code>Mder_fun(λ,der)</code> should return the n x n matrix corresponding to the  <code>der</code>th derivatve. If only a limited number of derivatives are available, <code>maxder</code> should be set, e.g., if not derivatives are implemented, set <code>maxder=0</code>. The function <code>compute_Mlicomb</code> is automatically available by (delegation) to <code>compute_Mlincomb_from_Mder</code>.</p><p>Note: This is a convenience function it is not recommended for high performance computations, since, e.g., it will not maintain type stability.</p><p><strong>Example</strong></p><p>The following example defines a linear eigenvalue problem <code>A0+λA1</code> defined in an external function.</p><pre><code class="language-julia-repl">julia&gt; using LinearAlgebra; # For the I function
julia&gt; function my_Mder(s,der)
    A0=ones(Float64,3,3)-I; A0[1,1]=-1;
    A1=ones(Float64,3,3)*3; A1[2,3]=0;
    if (der==0)
       return A0+A1*s;
    elseif (der==1)
       return A1;
    else
       return zero(A0);
    end
end
julia&gt; nep=Mder_NEP(3,my_Mder);
julia&gt; (λ,v)=augnewton(nep,v=ones(3));
julia&gt; norm(compute_Mder(nep,λ)*v)
5.551115123125783e-17</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.Mder_Mlincomb_NEP" href="#NonlinearEigenproblems.NEPTypes.Mder_Mlincomb_NEP"><code>NonlinearEigenproblems.NEPTypes.Mder_Mlincomb_NEP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Mder_Mlincomb_NEP(n,Mder_fun, [maxder_Mder,] Mlincomb_fun, [maxder_Mlincomb])</code></pre><p>Creates a <code>NEP</code> from its <code>compute_Mder</code> and <code>compute_Mlincomb</code>functions  defined by the function handles <code>Mder_fun</code> and <code>Mlincomb_fun</code>. The <code>Mlincomb_fun(λ,X)</code> takes two parameters a scalar <code>λ::Number</code> and a matrix <code>X</code>.  The size <code>n::Int</code> must also be specified. The function <code>Mlincomb_fun(λ,X)</code> should return a vector corresponding of the linear combination of derivatives multiplied with the vectors in X. If only a limited number of derivatives are implemented, <code>maxder_Mder</code> or <code>maxder_Mlincomb</code> should be set, e.g., if not derivatives are implemented, set <code>maxder=0</code>.</p><p>See also <code>Mder_NEP</code>.</p><p>Note: This is a convenience function it is not recommended for high performance computations, since, e.g., it will not maintain type stability.</p><p><strong>Example</strong></p><p>The following example defines a linear eigenvalue problem <code>A0+λA1</code> defined in an external function.</p><pre><code class="language-julia-repl">julia&gt; using LinearAlgebra; # For the I function
julia&gt; function my_Mder(s,der)
    A0=ones(Float64,3,3)-I; A0[1,1]=-1;
    A1=ones(Float64,3,3)*3; A1[2,3]=0;
    if (der==0)
       return A0+A1*s;
    elseif (der==1)
       return A1;
    else
       return zero(A0);
    end
end
julia&gt; function my_Mlincomb(s,X) # Compute linear comb of derivatives
    A0=ones(Float64,3,3)-I; A0[1,1]=-1;
    A1=ones(Float64,3,3)*3; A1[2,3]=0;
    if (size(X,2) &lt;= 1)
       return A0*X[:,1]+s*A1*X[:,1]
    else # This means: size(X,2) =&gt; 2
       return A0*X[:,1]+A1*(s*X[:,1]+X[:,2]);
    end
end
julia&gt; nep=Mder_Mlincomb_NEP(3,my_Mder,my_Mlincomb);
julia&gt; (λ,v)=augnewton(nep,v=[1.0; 2.3; 0.0])
julia&gt; norm(compute_Mder(nep,λ)*v)
6.798699777552591e-17</code></pre></div></div></section><footer><hr/><a class="previous" href="../types/"><span class="direction">Previous</span><span class="title">NEP Types</span></a><a class="next" href="../linsolvers/"><span class="direction">Next</span><span class="title">LinSolvers</span></a></footer></article></body></html>
