<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Compute functions · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../methods/">NEP-Solvers</a></li><li><a class="toctext" href="../types/">NEP Types</a></li><li class="current"><a class="toctext" href>Compute functions</a><ul class="internal"></ul></li><li><a class="toctext" href="../linsolvers/">LinSolvers</a></li><li><a class="toctext" href="../innersolvers/">Inner solvers</a></li><li><a class="toctext" href="../errmeasure/">Measuring the error</a></li><li><a class="toctext" href="../logger/">Logger</a></li><li><a class="toctext" href="../transformations/">Transforming NEPs</a></li><li><a class="toctext" href="../deflation/">Deflation</a></li><li><a class="toctext" href="../gallery/">Gallery</a></li></ul></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="toctext" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="toctext" href="../tutorial_call_python/">Tutorial 5 (Python)</a></li><li><a class="toctext" href="../tutorial_matlab1/">Tutorial 6 (MATLAB)</a></li><li><a class="toctext" href="../tutorial_fortran1/">Tutorial 7 (FORTRAN)</a></li><li><a class="toctext" href="../tutorial_nano1/">Tutorial 8 (gmsh + nanophotonics)</a></li><li><a class="toctext" href="../tutorial_newmethod/">Tutorial 9 (New solver)</a></li><li><a class="toctext" href="../tutorial_linsolve/">Tutorial 10 (Linear solvers)</a></li><li><a class="toctext" href="../hydrotutorial/">Tutorial 11 (Orr-Somerfeld)</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Compute functions</a></li></ul><a class="edit-page" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/compute_functions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Compute functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Compute-functions-1" href="#Compute-functions-1">Compute functions</a></h1><p>The nonlinear eigenvalue problem is defined by the data stored in the NEP-class, and the NEP-solvers access the data mainly through three main functions, <code>compute_Mder</code> <code>compute_Mlincomb</code> and <code>compute_MM</code>.</p><p>** Extend. This is important for the data structure **</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPCore.compute_Mder" href="#NonlinearEigenproblems.NEPCore.compute_Mder"><code>NonlinearEigenproblems.NEPCore.compute_Mder</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">compute_Mder(nep::NEP,λ::Number [,i::Integer=0])</code></pre><p>Computes the ith derivative of <code>nep</code> evaluated in <code>λ</code>.</p><p><strong>Example</strong></p><p>This example shows that <code>compute_Mder(nep,λ,1)</code> gives the first derivative.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; ϵ=1e-5;
julia&gt; Aminus=compute_Mder(nep,λ-ϵ);
julia&gt; Aminus=compute_Mder(nep,λ-ϵ);
julia&gt; Aplus=compute_Mder(nep,λ+ϵ);
julia&gt; opnorm((Aplus-Aminus)/(2ϵ)-compute_Mder(nep,λ,1))
1.990970375089371e-11</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPCore.compute_Mlincomb!" href="#NonlinearEigenproblems.NEPCore.compute_Mlincomb!"><code>NonlinearEigenproblems.NEPCore.compute_Mlincomb!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">compute_Mlincomb(nep::NEP,λ::Number,V, a::Vector=ones(size(V,2)), startder=0)
compute_Mlincomb!(nep::NEP,λ::Number,V, a::Vector=ones(size(V,2)), startder=0)</code></pre><p>Computes the linear combination of derivatives<br/><span>$Σ_i a_i M^{(i)}(λ) v_i$</span> starting from derivative <code>startder</code>. The function <code>compute_Mlincomb!</code> does the same but may modify the <code>V</code> matrix/array.</p><p><strong>Example</strong></p><p>This example shows that <code>compute_Mder</code> gives a result consistent with <code>compute_Mlincomb</code>. Note that <code>compute_Mlincomb</code> is in general faster since no matrix needs to be constructed.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; v=ones(size(nep,1)); λ=-1+1im;
julia&gt; norm(compute_Mder(nep,λ,1)*v-compute_Mlincomb(nep,λ,hcat(v,v),[0,1]))
1.0778315928076987e-15
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPCore.compute_MM" href="#NonlinearEigenproblems.NEPCore.compute_MM"><code>NonlinearEigenproblems.NEPCore.compute_MM</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">compute_MM(nep::NEP,S,V)</code></pre><p>Computes the sum <span>$Σ_i M_i V f_i(S)$</span> for a NEP, where <span>$S$</span> and <span>$V$</span> are matrices, and the NEP satisfies <span>$M(λ)=Σ_i M_i f_i(λ)$</span>.</p><p><strong>Example</strong></p><p>This example shows that for diagonal <code>S</code>, the result of <code>compute_MM</code> can also be computed with <code>compute_Mlincomb</code></p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; D=diagm(0 =&gt; [1,2])
2×2 Array{Int64,2}:
 1  0
 0  2
julia&gt; V=ones(size(n,1),2);
julia&gt; W=compute_MM(nep,D,V);
julia&gt; norm(W[:,1]-compute_Mlincomb(nep,D[1,1],V[:,1]))
1.1102230246251565e-16
julia&gt; norm(W[:,2]-compute_Mlincomb(nep,D[2,2],V[:,2]))
0.0</code></pre><p><strong>Reference</strong></p><p>Properties of the quantity <span>$Σ_i M_i V f_i(S)$</span> for non-polynomial nonlinear eigenvalue problems were extensively used in:</p><ul><li>D. Kressner A block Newton method for nonlinear eigenvalue problems, Numer. Math., 114 (2) (2009), pp. 355-372</li><li>C. Effenberger, Robust solution methods for nonlinear eigenvalue problems, PhD thesis, 2013, EPF Lausanne</li></ul></div></div></section><footer><hr/><a class="previous" href="../types/"><span class="direction">Previous</span><span class="title">NEP Types</span></a><a class="next" href="../linsolvers/"><span class="direction">Next</span><span class="title">LinSolvers</span></a></footer></article></body></html>
