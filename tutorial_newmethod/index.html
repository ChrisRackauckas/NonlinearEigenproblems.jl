<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 9 (New solver) · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../methods/">NEP-Solvers</a></li><li><a class="toctext" href="../types/">Types &amp; Data structures</a></li><li><a class="toctext" href="../compute_functions/">Compute functions</a></li><li><a class="toctext" href="../linsolvers/">Linear solvers</a></li><li><a class="toctext" href="../innersolvers/">Projection</a></li><li><a class="toctext" href="../errmeasure/">Measuring the error</a></li><li><a class="toctext" href="../logger/">Logger</a></li><li><a class="toctext" href="../transformations/">Transformations</a></li><li><a class="toctext" href="../deflation/">Deflation</a></li><li><a class="toctext" href="../gallery/">Gallery</a></li></ul></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="toctext" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="toctext" href="../tutorial_call_python/">Tutorial 5 (Python)</a></li><li><a class="toctext" href="../tutorial_matlab1/">Tutorial 6 (MATLAB)</a></li><li><a class="toctext" href="../tutorial_fortran1/">Tutorial 7 (FORTRAN)</a></li><li><a class="toctext" href="../tutorial_nano1/">Tutorial 8 (gmsh + nanophotonics)</a></li><li class="current"><a class="toctext" href>Tutorial 9 (New solver)</a><ul class="internal"><li><a class="toctext" href="#Halley&#39;s-method-1">Halley&#39;s method</a></li><li><a class="toctext" href="#Implementation-in-NEP-PACK-(preliminary-version)-1">Implementation in NEP-PACK (preliminary version)</a></li><li><a class="toctext" href="#Implementation-in-NEP-PACK-(full-version)-1">Implementation in NEP-PACK (full version)</a></li></ul></li><li><a class="toctext" href="../tutorial_linsolve/">Tutorial 10 (Linear solvers)</a></li><li><a class="toctext" href="../hydrotutorial/">Tutorial 11 (Orr–Somerfeld)</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href>Tutorial 9 (New solver)</a></li></ul><a class="edit-page" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/tutorial_newmethod.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial 9 (New solver)</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial:-Implementing-your-own-method-1" href="#Tutorial:-Implementing-your-own-method-1">Tutorial: Implementing your own method</a></h1><p>Although we try to provide state-of-the-art algorithms in NEP-PACK, you may want to implement a solver which is not available in NEP-PACK. By using the NEP-PACK data types and structures you can make your life easier in several ways. You do not need to know the internals of NEP-PACK. Correct usage, will give you access to many applications, helper functionality to combine with, and you will have to possibility to compare your method with other solvers. We now illustrate how to implement your own solver.</p><h2><a class="nav-anchor" id="Halley&#39;s-method-1" href="#Halley&#39;s-method-1">Halley&#39;s method</a></h2><p><a href="https://en.wikipedia.org/wiki/Halley%27s_method">Halley&#39;s method for root-finding of nonlinear scalar equations</a> has fast local convergence - even faster than Newton&#39;s method in terms of iterations. A NEP can be formulated as a root-finding problem since a solution will always satisfy</p><div>\[f(λ)=\det(M(λ))=0\]</div><p>The application of Halley&#39;s method to this nonlinear scalar equation will serve as an example solver, although it does, to our knowledge, not lead to a competitive algorithm. Halley&#39;s method for the root-finding problem is defined as the</p><div>\[λ_{k+1}=λ_k-\frac{2f(λ_k)f&#39;(λ_k)}{2(f&#39;(λ_k))^2-f(λ_k)f&#39;&#39;(λ_k)}\]</div><p>Although there are formulas for the derivatives of the determinant, we will here for simplicity just use finite difference to estimate the derivatives, i.e.,</p><div>\[ f&#39;(λ)\approx \frac{f(λ+δ)-f(λ-δ)}{2δ}\]</div><div>\[ f&#39;&#39;(λ)\approx \frac{f(λ+δ)-2f(λ)+f(λ-δ)}{δ^2}\]</div><h2><a class="nav-anchor" id="Implementation-in-NEP-PACK-(preliminary-version)-1" href="#Implementation-in-NEP-PACK-(preliminary-version)-1">Implementation in NEP-PACK (preliminary version)</a></h2><p>Let us first define our solver function and introduce the function of which we wish to find the roots. The matrix <span>$M(λ)$</span> is obtained from the <a href="../compute_functions/#NonlinearEigenproblems.NEPCore.compute_Mder"><code>compute_Mder</code></a>-function.</p><pre><code class="language-julia">using NonlinearEigenproblems
function halley(nep::NEP;λ=0.0,δ=sqrt(eps()),maxit=100,tol=eps()*100)
   f=s-&gt; det(compute_Mder(nep,s)); # The objective function
   # More code here
end</code></pre><p>The main loop (which should go in <code># More code here</code>) can be implemented, in a way that does not involve many function evaluations, as follows:</p><pre><code class="language-julia">   for i=1:maxit
       fλ=f(λ)
       fλp=f(λ+δ)
       fλm=f(λ-δ)
       fp=(fλp-fλm)/(2δ)
       fpp=(fλp-2*fλ+fλm)/(δ^2)
       Δλ=2*fλ*fp/(2*fp^2-fλ*fpp);
       λ=λ-Δλ;
       @show (i,λ)
       if (abs(Δλ)&lt;tol)
          return λ
       end
   end</code></pre><p>Let&#39;s test our code on a benchmark problem:</p><pre><code class="language-julia">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; λ=halley(nep)
(i, λ) = (1, -0.08425238005323712)
(i, λ) = (2, -0.14769529096609657)
(i, λ) = (3, -0.443164132772242)
(i, λ) = (4, -0.3653012970379835)
(i, λ) = (5, -0.35874460050208345)
(i, λ) = (6, -0.3587189462161427)
(i, λ) = (7, -0.35871894596862675)
(i, λ) = (8, -0.3587189459686267)</code></pre><p>Clearly, the algorithm terminates after 8 iterations. We can verify that this is actually a solution easily if we also have an approximate eigenvector. An eigenvector can be computed by essentially one step of inverse iteration, on the matrix <span>$M(λ)$</span>:</p><pre><code class="language-julia">julia&gt; x=normalize(compute_Mder(nep,λ)\ones(size(nep,1)))
5-element Array{Float64,1}:
 -0.3170546135678643
  0.15957983055370098
 -0.30996780934165974
  0.5577415634513512
  0.6832678503094953</code></pre><p>The residual norm  <span>$|M(λ)x|$</span> does indeed become almost zero so it seems we have a solution:</p><pre><code class="language-julia">julia&gt; norm(compute_Mlincomb(nep,λ,x))
6.735017818475343e-16</code></pre><h2><a class="nav-anchor" id="Implementation-in-NEP-PACK-(full-version)-1" href="#Implementation-in-NEP-PACK-(full-version)-1">Implementation in NEP-PACK (full version)</a></h2><p>In the following we illustrate a more advanced usage of the NEP-PACK method development: NEP-PACKs logging facility  and error estimation. See <a href="../logger/"><code>Logger</code></a> and <a href="../errmeasure/"><code>Errmeasure</code></a>. This gives access to other ways to measure error as well as a logging which is the same for all solvers and simplifies comparisons.</p><pre><code class="language-julia">using NonlinearEigenproblems, LinearAlgebra, Plots
function halley(nep::NEP;λ=0.0,δ=sqrt(eps()),maxit=100,
                tol=eps()*100,logger=0,
                errmeasure = DefaultErrmeasure(nep))
    # Setup the logger.
    @parse_logger_param!(logger);

    n=size(nep,1);
    f=s-&gt; det(compute_Mder(nep,s)); # The objective function


    for i=1:maxit
        fλ=f(λ)
        fλp=f(λ+δ)
        fλm=f(λ-δ)
        fp=(fλp-fλm)/(2δ)
        fpp=(fλp-2*fλ+fλm)/(δ^2)
        Δλ=2*fλ*fp/(2*fp^2-fλ*fpp);
        λ=λ-Δλ;
        # Compute an eigenvector. This will not work if the
        # eigenvector is orthogonal to ones(n)
        x=normalize(compute_Mder(nep,λ)\ones(n));
        err=estimate_error(ermdata,λ,x)  # Estimate the error
        push_iteration_info!(logger,i; λ=λ,err=err) # Put it into the log
        if (err&lt;tol)
            return (λ,x)
        end
    end
end</code></pre><p>We can now run our new method using with a <code>logger=1</code> keyword argument so we get the standardized output of iteration info:</p><pre><code class="language-julia-repl">julia&gt; (λ,x)=halley(nep,logger=1);
iter 1 err:0.08492602120772309 λ=-0.08425238005323712
iter 2 err:0.07450867012944977 λ=-0.14769529096609657
iter 3 err:0.032639292900081246 λ=-0.443164132772242
iter 4 err:0.00281602165251169 λ=-0.3653012970379835
iter 5 err:1.1025990567599428e-5 λ=-0.35874460050208345
iter 6 err:1.0638098128402615e-10 λ=-0.3587189462161427
iter 7 err:4.942402279980973e-17 λ=-0.35871894596862675
julia&gt; norm(compute_Mlincomb(nep,λ,x))
5.613646650354486e-16</code></pre><p>If you now want to plot the error history, you can use the <a href="../logger/#NonlinearEigenproblems.NEPSolver.ErrorLogger"><code>ErrorLogger</code></a>:</p><pre><code class="language-julia-repl">julia&gt; mylogger=ErrorLogger()
julia&gt; (λ,x)=halley(nep,logger=mylogger);
julia&gt; plot(mylogger.errs[1:10,1],yaxis=:log)</code></pre><p>We clearly observe the superlinear convergence:</p><p><img src="../newmethod_convergence.svg" alt/></p><footer><hr/><a class="previous" href="../tutorial_nano1/"><span class="direction">Previous</span><span class="title">Tutorial 8 (gmsh + nanophotonics)</span></a><a class="next" href="../tutorial_linsolve/"><span class="direction">Next</span><span class="title">Tutorial 10 (Linear solvers)</span></a></footer></article></body></html>
