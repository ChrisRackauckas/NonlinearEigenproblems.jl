<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 9 (New solver) · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../methods/">NEP-Solvers</a></li><li><a class="toctext" href="../types/">Types &amp; Data structures</a></li><li><a class="toctext" href="../compute_functions/">Compute functions</a></li><li><a class="toctext" href="../linsolvers/">Linear solvers</a></li><li><a class="toctext" href="../innersolvers/">Projection</a></li><li><a class="toctext" href="../errmeasure/">Measuring the error</a></li><li><a class="toctext" href="../logger/">Logger</a></li><li><a class="toctext" href="../transformations/">Transformations</a></li><li><a class="toctext" href="../deflation/">Deflation</a></li><li><a class="toctext" href="../gallery/">Gallery</a></li></ul></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="toctext" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="toctext" href="../tutorial_call_python/">Tutorial 5 (Python)</a></li><li><a class="toctext" href="../tutorial_matlab1/">Tutorial 6 (MATLAB)</a></li><li><a class="toctext" href="../tutorial_fortran1/">Tutorial 7 (FORTRAN)</a></li><li><a class="toctext" href="../tutorial_nano1/">Tutorial 8 (gmsh + nanophotonics)</a></li><li class="current"><a class="toctext" href>Tutorial 9 (New solver)</a><ul class="internal"><li><a class="toctext" href="#Halley&#39;s-method-1">Halley&#39;s method</a></li><li><a class="toctext" href="#Implementation-in-NEP-PACK-(preliminary-version)-1">Implementation in NEP-PACK (preliminary version)</a></li><li><a class="toctext" href="#Implementation-in-NEP-PACK-(full-version)-1">Implementation in NEP-PACK (full version)</a></li></ul></li><li><a class="toctext" href="../tutorial_linsolve/">Tutorial 10 (Linear solvers)</a></li><li><a class="toctext" href="../hydrotutorial/">Tutorial 11 (Orr–Somerfeld)</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href>Tutorial 9 (New solver)</a></li></ul><a class="edit-page" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/tutorial_newmethod.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial 9 (New solver)</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial:-Implementing-your-own-method-1" href="#Tutorial:-Implementing-your-own-method-1">Tutorial: Implementing your own method</a></h1><p>Although we try to provide state-of-the-art algorithms in NEP-PACK, you may want to implement a solver which is not available in NEP-PACK. By using the NEP-PACK data types and structures when you implement your solver, you can make your life easier in several ways. You do not need to know the internals of NEP-PACK. Correct usage will give you access to many applications, helper functionality to combine with, and you will have to possibility to compare your method with other solvers. We now illustrate how to implement your own NEP-solver.</p><h2><a class="nav-anchor" id="Halley&#39;s-method-1" href="#Halley&#39;s-method-1">Halley&#39;s method</a></h2><p><a href="https://en.wikipedia.org/wiki/Halley%27s_method">Halley&#39;s method for root-finding of nonlinear scalar equations</a> has fast local convergence - even faster than Newton&#39;s method in terms convergence order, and often faster in terms of number of iterations. A NEP can be formulated as a root-finding problem since a solution will always satisfy</p><div>\[f(λ)=\det(M(λ))=0\]</div><p>The application of Halley&#39;s method to this nonlinear scalar equation will serve as an example solver, although it does, to our knowledge, not lead to a competitive algorithm. Halley&#39;s method for the root-finding problem is defined by the iteration</p><div>\[λ_{k+1}=λ_k-\frac{2f(λ_k)f&#39;(λ_k)}{2(f&#39;(λ_k))^2-f(λ_k)f&#39;&#39;(λ_k)}\]</div><p>There are formulas for the derivatives of the determinant, we will here for simplicity just use finite difference approximation to estimate the derivatives, i.e.,</p><div>\[ f&#39;(λ)\approx \frac{f(λ+δ)-f(λ-δ)}{2δ}\]</div><div>\[ f&#39;&#39;(λ)\approx \frac{f(λ+δ)-2f(λ)+f(λ-δ)}{δ^2}\]</div><h2><a class="nav-anchor" id="Implementation-in-NEP-PACK-(preliminary-version)-1" href="#Implementation-in-NEP-PACK-(preliminary-version)-1">Implementation in NEP-PACK (preliminary version)</a></h2><p>Let us first define our solver function and introduce the function whose roots we wish to find. The matrix <span>$M(λ)$</span> is obtained by a call to the <a href="../compute_functions/#NonlinearEigenproblems.NEPCore.compute_Mder"><code>compute_Mder</code></a>-function.</p><pre><code class="language-julia">using NonlinearEigenproblems
function halley(nep::NEP;λ=0.0,δ=sqrt(eps()),maxit=100,tol=eps()*100)
   f=s-&gt; det(compute_Mder(nep,s)); # The objective function
   # More code here
end</code></pre><p>The main loop (which should go in <code># More code here</code>) can be implemented, in a way that does not involve many function evaluations, as follows:</p><pre><code class="language-julia">   for i=1:maxit
       fλ=f(λ)
       fλp=f(λ+δ)
       fλm=f(λ-δ)
       fp=(fλp-fλm)/(2δ)
       fpp=(fλp-2*fλ+fλm)/(δ^2)
       Δλ=2*fλ*fp/(2*fp^2-fλ*fpp);
       λ=λ-Δλ;
       @show (i,λ)
       if (abs(Δλ)&lt;tol)
          return λ
       end
   end</code></pre><p>Let us now test the code on a benchmark problem:</p><pre><code class="language-julia">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; λ=halley(nep)
(i, λ) = (1, -0.13876571372157542)
(i, λ) = (2,  0.15938372556136426)
(i, λ) = (3, -0.15955391446207692)
(i, λ) = (4, -0.15955391823299248)</code></pre><p>Clearly, the algorithm terminates after 4 iterations. We can verify that this is actually a solution easily if we also have an approximate eigenvector. An eigenvector can be computed/estimated by essentially one step of inverse iteration, on the matrix <span>$M(λ)$</span>:</p><pre><code class="language-julia">julia&gt; x=normalize(compute_Mder(nep,λ)\ones(size(nep,1)))
5-element Array{Float64,1}:
  0.14358324743994907 
  0.9731847884093298  
 -0.12527093093249475 
  0.031821422867456914
  0.12485915894832478 </code></pre><p>The residual norm  <span>$||M(λ)x||$</span> does indeed become almost zero so it seems we have a solution:</p><pre><code class="language-julia">julia&gt; norm(compute_Mlincomb(nep,λ,x))
7.093661646042283e-16</code></pre><h2><a class="nav-anchor" id="Implementation-in-NEP-PACK-(full-version)-1" href="#Implementation-in-NEP-PACK-(full-version)-1">Implementation in NEP-PACK (full version)</a></h2><p>In the following we illustrate a more advanced usage of the NEP-PACK method development: NEP-PACKs logging facility  and error estimation. See <a href="../logger/"><code>Logger</code></a> and <a href="../errmeasure/"><code>Errmeasure</code></a>. This gives access to other ways to measure error as well as a logging and  inspection of error history in a way that is the same for all solvers and simplifies comparisons.</p><pre><code class="language-julia">using NonlinearEigenproblems, LinearAlgebra, Plots
function halley(nep::NEP;λ=0.0,δ=sqrt(eps()),maxit=100,
                tol=eps()*100,logger=0,
                errmeasure = DefaultErrmeasure(nep))
    # Setup the logger.
    @parse_logger_param!(logger);

    n=size(nep,1);
    f=s-&gt; det(compute_Mder(nep,s)); # The objective function


    for i=1:maxit
        fλ=f(λ)
        fλp=f(λ+δ)
        fλm=f(λ-δ)
        fp=(fλp-fλm)/(2δ)
        fpp=(fλp-2*fλ+fλm)/(δ^2)
        Δλ=2*fλ*fp/(2*fp^2-fλ*fpp);
        λ=λ-Δλ;
        # Compute an eigenvector. This will not work if the
        # eigenvector is orthogonal to ones(n)
        x=normalize(compute_Mder(nep,λ)\ones(n));
        err=estimate_error(errmeasure,λ,x)  # Estimate the error
        push_iteration_info!(logger,i; λ=λ,err=err) # Put it into the log
        if (err&lt;tol)
            return (λ,x)
        end
    end
end</code></pre><p>We can now run our new method using  with a <code>logger=1</code> keyword argument so we get the standardized output of iteration info:</p><pre><code class="language-julia-repl">julia&gt; (λ,x)=halley(nep,logger=1);
iter 1 err:0.010384216303530201 λ=-0.13876571372157542
iter 2 err:8.082978338039669e-5 λ=-0.15938372556136426
iter 3 err:1.7901681647471861e-9 λ=-0.15955391446207692
iter 4 err:1.0389976569127096e-16 λ=-0.15955391823299248
julia&gt; norm(compute_Mlincomb(nep,λ,x))
7.093661646042283e-16</code></pre><p>The use of the NEP-PACK logging functionality makes it very easy to visualize the error. If you now want to plot the error history, you can use the <a href="../logger/#NonlinearEigenproblems.NEPCore.ErrorLogger"><code>ErrorLogger</code></a>:</p><pre><code class="language-julia-repl">julia&gt; mylogger=ErrorLogger()
julia&gt; (λ,x)=halley(nep,logger=mylogger);
julia&gt; plot(mylogger.errs[1:10,1],yaxis=:log)</code></pre><p>We clearly observe the superlinear convergence:</p><p><img src="../newmethod_convergence.svg" alt/></p><p><img src="http://jarlebring.se/onepixel.png?NEPPACKDOC_NEWMETHOD" alt="To the top"/></p><footer><hr/><a class="previous" href="../tutorial_nano1/"><span class="direction">Previous</span><span class="title">Tutorial 8 (gmsh + nanophotonics)</span></a><a class="next" href="../tutorial_linsolve/"><span class="direction">Next</span><span class="title">Tutorial 10 (Linear solvers)</span></a></footer></article></body></html>
