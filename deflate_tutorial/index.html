<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 4 (Deflation) · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../methods/">NEP Methods</a></li><li><a class="toctext" href="../types/">NEP Types</a></li><li><a class="toctext" href="../linsolvers/">LinSolver</a></li><li><a class="toctext" href="../errmeasure/">Error measure</a></li><li><a class="toctext" href="../logger/">Logger</a></li><li><a class="toctext" href="../transformations/">NEP Transformations</a></li><li><a class="toctext" href="../gallery/">NEP Gallery</a></li><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li class="current"><a class="toctext" href>Tutorial 4 (Deflation)</a><ul class="internal"><li><a class="toctext" href="#Background-1">Background</a></li><li><a class="toctext" href="#Deflation-in-NEP-PACK-1">Deflation in NEP-PACK</a></li><li><a class="toctext" href="#Repeated-deflation-1">Repeated deflation</a></li><li><a class="toctext" href="#The-theory-in-the-background-1">The theory in the background</a></li></ul></li><li><a class="toctext" href="../tutorial_call_python/">Tutorial 5 (Python NEP)</a></li><li><a class="toctext" href="../tutorial_matlab1/">Tutorial 6 (MATLAB 1)</a></li><li><a class="toctext" href="../tutorial_fortran1/">Tutorial 7 (FORTRAN 1)</a></li><li><a class="toctext" href="../tutorial_nano1/">Tutorial 8 (gmsh + nanophotonics)</a></li><li><a class="toctext" href="../tutorial_newmethod/">Tutorial 9 (New solver)</a></li><li><a class="toctext" href="../tutorial_linsolve/">Tutorial 10 (Linear solvers)</a></li><li><a class="toctext" href="../hydrotutorial/">Tutorial 11 (Orr-Somerfeld)</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Tutorial 4 (Deflation)</a></li></ul><a class="edit-page" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/deflate_tutorial.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial 4 (Deflation)</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial:-Computing-several-solutions-with-deflation-1" href="#Tutorial:-Computing-several-solutions-with-deflation-1">Tutorial: Computing several solutions with deflation</a></h1><h2><a class="nav-anchor" id="Background-1" href="#Background-1">Background</a></h2><p>Several algorithms for NEPs compute one solution to the NEP given a starting value. In many applications several solutions are of interest. Let us first consider the trivial partial &quot;work-around&quot;: You can try to run an algorithm which computes one eigenvalue twice with different starting values, e.g., quasinewton as in this example:</p><pre><code class="language-julia">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; (λ1,_)=quasinewton(nep,λ=0,v=ones(size(nep,1)))
(-0.3587189459686377 + 0.0im, Complex{Float64}[4.41411+0.0im, -2.22171+0.0im, 4.31544+0.0im, -7.76501+0.0im, -9.51261+0.0im])
julia&gt; (λ2,_)=quasinewton(nep,λ=1im,v=ones(size(nep,1)))
(-0.04093521177097875 + 1.4860115309416284im, Complex{Float64}[-3.28271+11.7399im, 5.08623-8.05479im, 7.16697-6.25547im, -2.69349+4.63954im, -9.91065+14.4678im])</code></pre><p>This simple approach often suffers from the problem called <em>reconvergence</em> (we obtain the same solution again) or solutions of interest may be missed. In this case we get reconvergence when we use starting value <code>-1</code>:</p><pre><code class="language-julia">julia&gt; (λ3,_)=quasinewton(nep,λ=-1,v=ones(size(nep,1)))
(-0.358718945968621 + 0.0im, Complex{Float64}[-6.65881+0.0im, 3.35151+0.0im, -6.50997+0.0im, 11.7137+0.0im, 14.3501+0.0im])</code></pre><p>Note that applying the algorithm with starting values <code>λ=0</code> and <code>λ=-1</code> lead to the same solution. Other solution methods do not suffer from this, e.g., <a href="../methods/#NonlinearEigenproblems.NEPSolver.blocknewton">block Newton method</a>, <a href="../methods/#NonlinearEigenproblems.NEPSolver.iar">the infinite Arnoldi method</a> and <a href="../methods/#NonlinearEigenproblems.NEPSolver.nleigs">nleigs</a> since they compute several solutions at once. Another attempt to remedy reconvergence is to use the technique called <em>deflation</em>.</p><h2><a class="nav-anchor" id="Deflation-in-NEP-PACK-1" href="#Deflation-in-NEP-PACK-1">Deflation in NEP-PACK</a></h2><p>The term deflation is referring to making something smaller (in the sense of opposite of inflating a balloon). In this case we can make the solution set smaller. We compute a solution and subsequently construct a deflated problem, which has the same solutions as the original problem except of the solution we have already computed.</p><p>A general solver independent deflation technique is available in NEP-PACK based on increasing the problem size. (There are also NEP-solver deflation techniques incoprorated in, e.g., in <a href="../methods/#NonlinearEigenproblems.NEPSolver.nlar">the nonlinear Arnoldi method</a> and <a href="../methods/#NonlinearEigenproblems.NEPSolver.jd_betcke">the Jacobi-Davidson method</a>.) The solver independent technique is inspired by what is described in the <a href="http://sma.epfl.ch/~anchpcommon/students/effenberger.pdf">PhD thesis of Cedric Effenberger</a>. It is implemented in the method <a href="../transformations/#NonlinearEigenproblems.NEPTypes.effenberger_deflation">effenberger_deflation</a>.</p><p>In NEP-PACK, this type of deflation is implemented in the function <code>deflate_eigpair</code>, which takes a NEP and an eigenpair as input and returns a new NEP.</p><pre><code class="language-julia">julia&gt; # first compute a solution
julia&gt; (λ1,v1)=quasinewton(nep,λ=0,v=ones(size(nep,1)))
julia&gt; # Construct a deflated NEP where we remove (λ1,v1)
julia&gt; dnep=deflate_eigpair(nep,λ1,v1)
julia&gt; # The dnep is a new NEP but with dimension increased by one
julia&gt; size(nep)
(5, 5)
julia&gt; size(dnep)
(6, 6)</code></pre><p>We now illustrate that we can avoid reconvergence:</p><pre><code class="language-julia">julia&gt; (λ4,v4)=quasinewton(dnep,λ=-1,v=ones(size(dnep,1)),maxit=1000)
(0.8347353572199264 + 0.0im, Complex{Float64}[10.6614+0.0im, 0.351814+0.0im, -0.940539+0.0im, 1.10798+0.0im, 3.53392+0.0im, -0.447213+0.0im])</code></pre><p>Note: In contrast to the initial example, starting value <code>λ=-1</code> does <em>not</em> lead to converge to the eigenvalue we obtained from starting value <code>λ=0</code>.</p><p>The computed solution is indeed a solution to the original NEP since <code>M(λ4)</code> is singular:</p><pre><code class="language-julia">julia&gt; minimum(svdvals(compute_Mder(nep,λ4)))
1.2941045763733582e-14</code></pre><p>In fact, you can even start with the first starting value <code>λ=0</code>, and get a new solution</p><pre><code class="language-julia">julia&gt; quasinewton(dnep,λ=0,v=ones(size(dnep,1)),maxit=1000)
(0.8347353572199577 + 0.0im, Complex{Float64}[9.28596+0.0im, 0.306425+0.0im, -0.819196+0.0im, 0.965031+0.0im, 3.07799+0.0im, -0.389516+0.0im])</code></pre><h2><a class="nav-anchor" id="Repeated-deflation-1" href="#Repeated-deflation-1">Repeated deflation</a></h2><p>The above procedure can be repeated by calling <code>deflate_eigpair</code> on the deflated NEP. This effectively deflates another eigenpair (but without creating a recursive deflated nep structure).</p><pre><code class="language-julia">function multiple_deflation(nep,λ0,p)
   n=size(nep,1);
   dnep=nep;
   for k=1:p
      # Compute one solution of the deflated problem
      (λ2,v2)=quasinewton(dnep,λ=λ0,v=ones(size(dnep,1)),maxit=1000);
      # expand the invariant pair
      dnep=deflate_eigpair(dnep,λ2,v2)
   end
   return get_deflated_eigpairs(dnep);

end</code></pre><p>We can now compute several solutions by calling <code>multiple_deflation</code>. Note that we use the same starting eigenvalue for all eigenvalues: <code>0.5im</code>. It has to be complex in this case, since if it was real, we would not find complex solution and this problem only has two real eigenvalues.</p><pre><code class="language-julia">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; (Λ,VV)=multiple_deflation(nep,0.5im,3)
(Complex{Float64}[-0.358719+1.33901e-14im, 0.834735+7.05729e-15im, -0.0409352+1.48601im], Complex{Float64}[-0.0148325-0.316707im -0.670282+0.268543im -0.41261+0.229832im; 0.00746549+0.159405im -0.0881321+0.0353094im 0.360381-0.0796982im; … ; 0.0260924+0.557131im -0.298976+0.119782im -0.201138+0.0524051im; 0.0319648+0.68252im -0.528234+0.211633im -0.668441+0.121828im])</code></pre><p>The values in <code>Λ</code> and <code>VV</code> are eigenpairs:</p><pre><code class="language-julia">julia&gt; norm(compute_Mlincomb(nep,Λ[1],VV[:,1]))
2.0521012310648373e-13
julia&gt; norm(compute_Mlincomb(nep,Λ[2],VV[:,2]))
2.8707903010898464e-13
julia&gt; norm(compute_Mlincomb(nep,Λ[3],VV[:,3]))
1.883394132275381e-13</code></pre><h2><a class="nav-anchor" id="The-theory-in-the-background-1" href="#The-theory-in-the-background-1">The theory in the background</a></h2><p>The deflation is based on a theory for NEP essentially stating that if <span>$(s,x)$</span> is an eigenpair, then the extended nonlinear eigenvalue problem</p><div>\[T(λ):=\begin{bmatrix}M(λ)&amp;M(λ)x(s-λ)^{-1}\\ x^T &amp; 0\end{bmatrix}\]</div><p>has the same eigenvalues as the original problem (under certain quite general conditions which are assumed to be satisfied). More eigenpairs can be deflated with techniques of partial Schur factorizations (which the user does not need to use). When we create a deflated NEP, we create the NEP <code>T</code>.</p><p>There are several ways to represent the <span>$T$</span>, which is why deflation has several modes. If you run</p><pre><code class="language-julia">julia&gt; dnep=deflate_eigpair(nep,λ1,v1,mode=:SPMF)</code></pre><p>the <code>dnep</code> will be of the type <code>AbstractSPMF</code>. More precisely, if</p><div>\[M(λ)=A_1f_1(λ)+\cdots+A_mf_m(λ)\]</div><p>the deflated NEP will be</p><div>\[T(λ)=
\begin{bmatrix}A_1&amp;0\\0 &amp; 0\end{bmatrix}f_1(λ)+\cdots+
\begin{bmatrix}A_m&amp;0\\0 &amp; 0\end{bmatrix}f_m(λ)+
\begin{bmatrix}0&amp;A_1x\\0 &amp; 0\end{bmatrix}\frac{f_1(λ)}{s-λ}+\cdots+
\begin{bmatrix}0&amp;A_mx\\0 &amp; 0\end{bmatrix}\frac{f_m(λ)}{s-λ}+
\begin{bmatrix}0&amp;0\\x^T &amp; 0\end{bmatrix}\]</div><p>Clearly, the deflated NEP will have more SPMF-terms, and the <code>mode=:SPMF</code>, is not recommended if you have many SPMF-terms. (Some additional exploitation is however implemented, since we can use the fact that the introduced terms are of low rank, and therefore naturally represented as a <code>LowRankFactorizedNEP</code>.)</p><p>If you select <code>mode=:Generic</code>, the compute functions are implemented without the use of SPMF, and can be more efficient if the NEP has many SPMF-terms. When <code>mode=:MM</code> the compute-functions are all implemented by calls to <code>compute_MM</code>. This will not be efficient if <code>compute_Mder(nep,λ,der)</code> where  <code>der&gt;0</code> is needed.</p><p><img src="http://jarlebring.se/onepixel.png?NEPPACKDOC_DEFLATION" alt="To the top"/></p><footer><hr/><a class="previous" href="../bemtutorial/"><span class="direction">Previous</span><span class="title">Tutorial 3 (BEM)</span></a><a class="next" href="../tutorial_call_python/"><span class="direction">Next</span><span class="title">Tutorial 5 (Python NEP)</span></a></footer></article></body></html>
