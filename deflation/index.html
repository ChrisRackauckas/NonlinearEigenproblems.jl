<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Deflation · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../methods/">NEP-Solvers</a></li><li><a class="toctext" href="../types/">Types &amp; Data structures</a></li><li><a class="toctext" href="../compute_functions/">Compute functions</a></li><li><a class="toctext" href="../linsolvers/">Linear solvers</a></li><li><a class="toctext" href="../innersolvers/">Projection</a></li><li><a class="toctext" href="../errmeasure/">Measuring the error</a></li><li><a class="toctext" href="../logger/">Logger</a></li><li><a class="toctext" href="../transformations/">Transformations</a></li><li class="current"><a class="toctext" href>Deflation</a><ul class="internal"><li><a class="toctext" href="#Theory-1">Theory</a></li><li><a class="toctext" href="#Functions-1">Functions</a></li></ul></li><li><a class="toctext" href="../gallery/">Gallery</a></li></ul></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="toctext" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="toctext" href="../tutorial_call_python/">Tutorial 5 (Python)</a></li><li><a class="toctext" href="../tutorial_matlab1/">Tutorial 6 (MATLAB)</a></li><li><a class="toctext" href="../tutorial_fortran1/">Tutorial 7 (FORTRAN)</a></li><li><a class="toctext" href="../tutorial_nano1/">Tutorial 8 (gmsh + nanophotonics)</a></li><li><a class="toctext" href="../tutorial_newmethod/">Tutorial 9 (New solver)</a></li><li><a class="toctext" href="../tutorial_linsolve/">Tutorial 10 (Linear solvers)</a></li><li><a class="toctext" href="../hydrotutorial/">Tutorial 11 (Orr–Somerfeld)</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Deflation</a></li></ul><a class="edit-page" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/deflation.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Deflation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Deflation-1" href="#Deflation-1">Deflation</a></h1><p>Several NEP-algorithms are able to find one eigenvalue, but may have difficulties finding several eigenvalues. Deflation is a transformation technique which can transform a NEP by effectively removing computed eigenvalues, and allowing several eigenvalues to be computed by repeated application of the same NEP-algorithm.</p><p>NEP-PACK provides a solver-independent implementation of deflation which can be combined (essentially) with any NEP-solver.  NEP-PACK also has some NEP-solver deflation techniques and reconvergence avoidance techniques  incoprorated directly in the solver, e.g., in the nonlinear Arnoldi method (<a href="../methods/#NonlinearEigenproblems.NEPSolver.nlar"><code>nlar</code></a>), the Jacobi-Davidson method (<a href="../methods/#NonlinearEigenproblems.NEPSolver.jd_betcke"><code>jd_betcke</code></a>) and Broyden&#39;s method (<a href="../methods/#NonlinearEigenproblems.NEPSolver.broyden"><code>broyden</code></a>).</p><p>The technique takes a NEP and a solution and creates a bigger NEP with one dimension larger but where the eigenvalue is removed from the solution set. Due to the abstraction of NEP-objects in NEP-PACK, the deflated NEP is again a NEP and we can apply the NEP-solver to the deflated NEP.</p><ul><li>Given a NEP (which can be a deflated NEP) <code>nep</code> and an eigenpair <code>(λ,v)</code> you can compute a deflated NEP by calling <code>dnep=</code><a href="#NonlinearEigenproblems.NEPTypes.deflate_eigpair"><code>deflate_eigpair</code></a><code>(nep,λ,v)</code> and <code>dnep</code> will essentially have the same eigenvalues as <code>nep</code>, except <code>λ</code>.</li><li>The transformation changes the eigenvectors such that the eigenvectors of <code>nep</code> and <code>dnep</code> will be different. To extract the eigenvectors (and the eigenvalues) you can call <a href="#NonlinearEigenproblems.NEPTypes.get_deflated_eigpairs"><code>get_deflated_eigpairs</code></a><code>(dnep)</code>.</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>More elaborate deflation examples can be found in <a href="../deflate_tutorial/">the tutorial on deflation</a>.</p></div></div><h2><a class="nav-anchor" id="Theory-1" href="#Theory-1">Theory</a></h2><p>The theory follows the presentation of the technique in <a href="http://sma.epfl.ch/~anchpcommon/students/effenberger.pdf">the PhD thesis of Cedric Effenberger</a>. It can be summarized as follows, in a somewhat simplified form (for the index one case). The deflation is based on a theory for NEPs essentially stating that if <span>$(s,x)$</span> is an eigenpair, then under certain general conditions (which we implicitly assume are satisfied),  the extended nonlinear eigenvalue problem</p><div>\[T(λ):=\begin{bmatrix}M(λ)&amp;M(λ)x(s-λ)^{-1}\\ x^T &amp; 0\end{bmatrix}\]</div><p>has the same eigenvalues as the original problem except for the eigenvalue <span>$s$</span> which is no longer part of the solution set. We have effectively removed (i.e. deflated) the eigenpair <code>(s,x)</code>. More eigenpairs can be deflated with techniques of partial Schur factorizations, which the user does not need to be aware of, due to the abstraction provided by the functions below. When we create a deflated NEP, we create the NEP <span>$T$</span>.</p><p>There are several ways to represent the <span>$T$</span>, which is why deflation has several modes. If you run</p><pre><code class="language-julia">julia&gt; dnep=deflate_eigpair(nep,λ1,v1,mode=:SPMF)</code></pre><p>the <code>dnep</code> will be of the type <a href="../types/#NonlinearEigenproblems.NEPTypes.AbstractSPMF"><code>AbstractSPMF</code></a>. More precisely, if</p><div>\[M(λ)=A_1f_1(λ)+\cdots+A_mf_m(λ)\]</div><p>the deflated NEP will be</p><div>\[T(λ)=
\begin{bmatrix}A_1&amp;0\\0 &amp; 0\end{bmatrix}f_1(λ)+\cdots+
\begin{bmatrix}A_m&amp;0\\0 &amp; 0\end{bmatrix}f_m(λ)+\]</div><div>\[\begin{bmatrix}0&amp;A_1x\\0 &amp; 0\end{bmatrix}\frac{f_1(λ)}{s-λ}+\cdots+
\begin{bmatrix}0&amp;A_mx\\0 &amp; 0\end{bmatrix}\frac{f_m(λ)}{s-λ}+
\begin{bmatrix}0&amp;0\\x^T &amp; 0\end{bmatrix}\]</div><p>Clearly, the deflated NEP has more SPMF-terms than the original <code>NEP</code>. When the parameter <code>mode=:SPMF</code> is set, the deflation method will explicitly construct an <a href="../types/#NonlinearEigenproblems.NEPTypes.SPMF_NEP"><code>SPMF_NEP</code></a>. This is not recommended if you have many SPMF-terms in the original problem, but can be efficient when you only have a few terms. (Some additional exploitation is however implemented, since we can use the fact that the introduced terms are of low rank, and therefore naturally represented as a <code>LowRankFactorizedNEP</code>.)</p><p>If you select <code>mode=:Generic</code>, the compute functions are implemented without the use of SPMF, and can be more efficient if the NEP has many SPMF-terms. When <code>mode=:MM</code> the compute-functions are all implemented by calls to <code>compute_MM</code>. This will not be efficient if <code>compute_Mder(nep,λ,der)</code> where  <code>der&gt;0</code> is needed.</p><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.deflate_eigpair" href="#NonlinearEigenproblems.NEPTypes.deflate_eigpair"><code>NonlinearEigenproblems.NEPTypes.deflate_eigpair</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">dnep=deflate_eigpair(orgnep::NEP,λ,v,[mode=:Auto])</code></pre><p>This function creates a deflated NEP based on <span>$(λ,v)$</span>, which are assumed to an eigenpair of <code>nep</code>. Effectively, the function will return <code>dnep::NEP</code> which has the same solutions as orgnep, except those corresponding to <span>$(λ,v)$</span>. Deflation is typically used to avoid reconvergence.</p><p>If <code>orgnep</code> is a <code>DeflatedNEP</code>, the <code>orgnep</code> the deflation in <code>orgnep</code> will be updated.</p><p>The <code>mode</code> kwarg can be <code>:Auto</code>, <code>:Generic</code>, <code>:SPMF</code>, <code>:MM</code>. This specifies how the deflated NEP should be represented. Which mode is the most efficient depends on many problem properties. If the original NEP is an <code>AbstractSPMF</code> with only a few terms, <code>mode=:SPMF</code> may be efficient. The SPMF-mode is based on a diagonalization of the deflated invariant pair and is not necessarily robust when you deflate eigenvalues near to each other. When <code>mode=:MM</code> is used, all compute functions are implemented via calls to the <code>compute_MM</code>. This can work well for small dense problems. The <code>:Generic</code> is based on an explicit derivation of the problem (via binomial expansion) which can be efficient if low order derivates are needed. If <code>:Auto</code> is selected, NEP-PACK tries to determine which one is the most efficient based on the <code>orgnep</code>.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; (λ,v)=newton(nep,v=ones(size(nep,1)));
julia&gt; dnep=deflate_eigpair(nep,λ,v)
julia&gt; (λ2,v2)=augnewton(dnep,v=ones(size(dnep,1)));  # this converges to different eigval
julia&gt; using LinearAlgebra;
julia&gt; minimum(svdvals(compute_Mder(nep,λ2)))
2.5161012836775824e-17</code></pre><p>The function <a href="#NonlinearEigenproblems.NEPTypes.get_deflated_eigpairs"><code>get_deflated_eigpairs()</code></a> extracts the eigenpairs that have been deflated. The returned pairs are eigenpairs of the original NEP:</p><pre><code class="language-julia-repl">julia&gt; dnep=deflate_eigpair(dnep,λ2,v2);
julia&gt; (D,V)=get_deflated_eigpairs(dnep)
julia&gt; norm(compute_Mlincomb(nep,D[1],V[:,1]))
2.3970746442479104e-16
julia&gt; norm(compute_Mlincomb(nep,D[2],V[:,2]))
8.101585801848734e-16</code></pre><p><strong>References</strong></p><ul><li>C. Effenberger, Robust solution methods for nonlinear eigenvalue problems, PhD thesis, 2013, EPF Lausanne</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.get_deflated_eigpairs" href="#NonlinearEigenproblems.NEPTypes.get_deflated_eigpairs"><code>NonlinearEigenproblems.NEPTypes.get_deflated_eigpairs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">(D,V)=get_deflated_eigpairs(S,V,n)
(D,V)=get_deflated_eigpairs(dnep::DeflatedNEP [λ,v])</code></pre><p>Returns a vector of eigenvalues <code>D</code> and a matrix with corresponding eigenvectors <code>V</code> of the invariant pair <code>S,V</code>. The eigenpairs correspond to the original problem, underlying the <code>DeflatedNEP</code>. The optional parameters <code>λ,v</code> allows the inclusion of an additional eigpair. Essentially, the optional parameters are the expanding the deflation and the running <code>get_deflated_eigpairs</code>  with kwarg, i.e.,</p><pre><code class="language-julia">(D,V)=get_deflated_eigpairs(deflate_eigpair(dnep,λ,v))`</code></pre><p>See example in <a href="#NonlinearEigenproblems.NEPTypes.deflate_eigpair"><code>deflate_eigpair</code></a>.</p></div></div></section><p><img src="http://jarlebring.se/onepixel.png?NEPPACKDOC_DEFLATIONM" alt="To the top"/></p><footer><hr/><a class="previous" href="../transformations/"><span class="direction">Previous</span><span class="title">Transformations</span></a><a class="next" href="../gallery/"><span class="direction">Next</span><span class="title">Gallery</span></a></footer></article></body></html>
