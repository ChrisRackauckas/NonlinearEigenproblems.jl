<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>LinSolver · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../methods/">NEP Methods</a></li><li><a class="toctext" href="../types/">NEP Types</a></li><li class="current"><a class="toctext" href>LinSolver</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#EigSolvers-1">EigSolvers</a></li></ul></li><li><a class="toctext" href="../errmeasure/">Error measure</a></li><li><a class="toctext" href="../logger/">Logger</a></li><li><a class="toctext" href="../transformations/">NEP Transformations</a></li><li><a class="toctext" href="../gallery/">NEP Gallery</a></li><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="toctext" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="toctext" href="../tutorial_call_python/">Tutorial 5 (Python NEP)</a></li><li><a class="toctext" href="../tutorial_matlab1/">Tutorial 6 (MATLAB 1)</a></li><li><a class="toctext" href="../tutorial_fortran1/">Tutorial 7 (FORTRAN 1)</a></li><li><a class="toctext" href="../tutorial_nano1/">Tutorial 8 (gmsh + nanophotonics)</a></li><li><a class="toctext" href="../tutorial_newmethod/">Tutorial 9 (New solver)</a></li><li><a class="toctext" href="../tutorial_linsolve/">Tutorial 10 (Linear solvers)</a></li><li><a class="toctext" href="../hydrotutorial/">Tutorial 11 (Orr-Somerfeld)</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>LinSolver</a></li></ul><a class="edit-page" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/linsolvers.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>LinSolver</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="LinSolvers-1" href="#LinSolvers-1">LinSolvers</a></h1><p>Most NEP-algorithms need to solve the linear system associated with <code>M(λ)</code>. We provide an interface to specify which solver to use or define your own solver.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.LinSolver" href="#NonlinearEigenproblems.LinSolvers.LinSolver"><code>NonlinearEigenproblems.LinSolvers.LinSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type LinSolver</code></pre><p>Structs inheriting from this type are able to solve linear systems associated with a NEP, for a specific <code>λ</code>-value. The most common are direct solvers such as <a href="#NonlinearEigenproblems.LinSolvers.FactorizeLinSolver"><code>FactorizeLinSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.BackslashLinSolver"><code>BackslashLinSolver</code></a> and iterative solvers such as <a href="#NonlinearEigenproblems.LinSolvers.GMRESLinSolver"><code>GMRESLinSolver</code></a>.</p><p>The LinSolver objects are usually created by the NEP-algorithms through creator functions, which are passed as parameters.</p><p><strong>Example</strong></p><p>The most common usecase is that you want to pass a <code>linsolvercreator</code>-function as a parameter to the NEP-algorithm. This example shows how you can use solvers based on backslash or <code>factorize()</code>. In the example, <code>BackslashLinSolver</code> does not exploit that the system matrix remains the same throughout the algorithm and is therefore slower.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; using BenchmarkTools
julia&gt; v0=ones(size(nep,1));
julia&gt; @btime λ,v=quasinewton(nep,λ=-1,v=v0, linsolvercreator=DefaultLinSolverCreator());
  199.540 ms (4929 allocations: 59.83 MiB)
julia&gt; @btime λ,v=quasinewton(nep,λ=-1,v=v0, linsolvercreator=BackslashLinSolverCreator());
  1.632 s (6137 allocations: 702.85 MiB)</code></pre><p><strong>Example</strong></p><p>The <code>LinSolver</code>s are constructed for extendability. This example creates our own <code>LinSolver</code> which uses an explicit formula for the inverse if the NEP has dimension 2x2.</p><p>Create the types and a creator.</p><pre><code class="language-julia">julia&gt; using LinearAlgebra
julia&gt; struct MyLinSolver &lt;: LinSolver
   M::Matrix{ComplexF64}
end
julia&gt; function my_linsolvercreator(nep,λ)
   M=compute_Mder(nep,λ);
   return MyLinSolver(M);
end</code></pre><p>Explicit import <code>lin_solve</code> to show how to solve a linear system.</p><pre><code class="language-julia-repl">julia&gt; import NonlinearEigenproblems.LinSolvers.lin_solve;
julia&gt; function lin_solve(solver::MyLinSolver,b::AbstractVecOrMat;tol=0)
   M=solver.M;
   invM=(1/(det(M)))*[M[2,2] -M[1,2];-M[2,1] M[1,1]]
   return invM*b
end
julia&gt; nep=SPMF_NEP([[1.0 3.0; 4.0 5.0], [2.0 1.0; -1 2.0]], [S-&gt;S^2,S-&gt;exp(S)])
julia&gt; λ,v=quasinewton(nep,λ=-1,v=[1;1],linsolvercreator=my_linsolvercreator);</code></pre><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.lin_solve"><code>lin_solve</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.FactorizeLinSolver"><code>FactorizeLinSolver</code></a>, <a href="@ref"><code>DefaultLinSolverCreator</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.BackslashLinSolver"><code>BackslashLinSolver</code></a>, <a href="@ref"><code>BackslashLinSolverCreator</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.GMRESLinSolver"><code>GMRESLinSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.GMRESLinSolverCreator"><code>GMRESLinSolverCreator</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/638967a4093c2468dcd5a9509aa4e3b754214371/src/LinSolvers.jl#L32-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.lin_solve" href="#NonlinearEigenproblems.LinSolvers.lin_solve"><code>NonlinearEigenproblems.LinSolvers.lin_solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">lin_solve(solver::LinSolver, b::AbstractVecOrMat; tol=0)</code></pre><p>This function solves the linear system represented in <code>solver::LinSolver</code> with a right-hand side <code>b</code>. The <code>tol</code> kwarg is controlling how accurate the linear system needs to be solved. A NEP-algorithm will call this solver every time a linear system associated with <code>M(λ)</code> needs to be solved.</p><p>This function must be overloaded if a user wants to define their own way of solving linear systems. See <a href="#NonlinearEigenproblems.LinSolvers.LinSolver"><code>LinSolver</code></a> for examples.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/638967a4093c2468dcd5a9509aa4e3b754214371/src/LinSolvers.jl#L120-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.FactorizeLinSolver" href="#NonlinearEigenproblems.LinSolvers.FactorizeLinSolver"><code>NonlinearEigenproblems.LinSolvers.FactorizeLinSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct FactorizeLinSolver &lt;: LinSolver</code></pre><p>This represents the linear solver associated with julia <code>factorize()</code>. See <a href="#NonlinearEigenproblems.LinSolvers.LinSolver"><code>LinSolver</code></a> and <a href="#NonlinearEigenproblems.LinSolvers.FactorizeLinSolverCreator"><code>FactorizeLinSolverCreator</code></a> for examples.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/638967a4093c2468dcd5a9509aa4e3b754214371/src/LinSolvers.jl#L98-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.FactorizeLinSolverCreator" href="#NonlinearEigenproblems.LinSolvers.FactorizeLinSolverCreator"><code>NonlinearEigenproblems.LinSolvers.FactorizeLinSolverCreator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FactorizeLinSolverCreator(;unfpack_refinements,max_factorizations,nep,precomp_values)</code></pre><p><code>FactorizeLinSolverCreator</code>-objects can instantiate <code>FactorizeLinSolver</code> objects via the <code>create_linsolver</code> function.</p><p>The <code>FactorizeLinSolver</code> is based on <code>factorize</code>-calls. The time point of the call to <code>factorize</code> can be controlled by parameters to <code>FactorizeLinSolverCreator</code>:</p><ul><li><p>By default, the <code>factorize</code> call is carried out by the instantiation of the <code>FactorizeLinSolver</code>, i.e., when the NEP-solver calls <code>create_linsolver</code>.</p></li><li><p>You can also precompute the factorization, at the time point when you instantiate <code>FactorizeLinSolverCreator</code>. If you set <code>precomp_values::Vector{Number}</code> to a non-empty vector, and set <code>nep</code> kwarg, the factorization (of all λ-values in the <code>precomp_values</code>) will be computed  when the <code>FactorizeLinSolverCreator</code> is instantiated. If the NEP-solver calls a <code>create_linsolver</code> with a λ-value from that vector, the factorization will be used (otherwise it will be computed).</p></li></ul><p>Further recycling is possible. If the variable <code>max_factorizations</code> is set to a positive value, the object will store that many factorizations for possible reuse. Every <code>lin_solve</code>-call then computes a factorization, unless a <code>lin_solve</code>-call for that <code>λ</code> has been computed earlier. This procedure can at most store <code>max_factorization</code> (which can be set <code>Inf</code>).</p><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.FactorizeLinSolver"><code>FactorizeLinSolver</code></a>, <a href="@ref"><code>create_linsolver</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/638967a4093c2468dcd5a9509aa4e3b754214371/src/NewLinSolvers.jl#L37-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.BackslashLinSolver" href="#NonlinearEigenproblems.LinSolvers.BackslashLinSolver"><code>NonlinearEigenproblems.LinSolvers.BackslashLinSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct BackslashLinSolver &lt;: LinSolver</code></pre><p>This represents a linear solver corresponding to the backslash operator (no pre-factorization).</p><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.LinSolver"><code>LinSolver</code></a> and <a href="@ref"><code>BackslashLinSolverCreator</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/638967a4093c2468dcd5a9509aa4e3b754214371/src/LinSolvers.jl#L148-L154">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>backslash_linsolvercreator</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.GMRESLinSolver" href="#NonlinearEigenproblems.LinSolvers.GMRESLinSolver"><code>NonlinearEigenproblems.LinSolvers.GMRESLinSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct GMRESLinSolver &lt;: LinSolver</code></pre><p>This represents a solver done with the julia GMRES implementation.</p><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.LinSolver"><code>LinSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.GMRESLinSolverCreator"><code>GMRESLinSolverCreator</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/638967a4093c2468dcd5a9509aa4e3b754214371/src/LinSolvers.jl#L172-L178">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.GMRESLinSolverCreator" href="#NonlinearEigenproblems.LinSolvers.GMRESLinSolverCreator"><code>NonlinearEigenproblems.LinSolvers.GMRESLinSolverCreator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GMRESLinSolverCreator(;kwargs...)</code></pre><p>This is the creator for the GMRES-method. Instantiate this object if you want to use GMRES as your linear system solver. The <code>kwargs</code> are stored and used as keyword arguments in the call to gmres. See list of keyword in the <a href="https://juliamath.github.io/IterativeSolvers.jl/dev/linear_systems/gmres/">IterativeSolvers.jl manual</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/638967a4093c2468dcd5a9509aa4e3b754214371/src/NewLinSolvers.jl#L126-L135">source</a></section><h1><a class="nav-anchor" id="EigSolvers-1" href="#EigSolvers-1">EigSolvers</a></h1><p>Some NEP-algorithms need to solve an associated linear eigenvalue problem. associated with <code>M(λ)</code>. You will likely only need the native eigensolvers in Julia. Nevertheless, we provide an interface to specify which solver to use or define your own solver.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.EigSolver" href="#NonlinearEigenproblems.LinSolvers.EigSolver"><code>NonlinearEigenproblems.LinSolvers.EigSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type EigSolver</code></pre><p>Structs inheriting from this type are able to solve linear eigenvalue problems arising in certain methods, such as, e.g., <code>mslp</code>, <code>sgiter</code>, and <code>polyeig</code>.</p><p>The <code>EigSolver</code> objects are passed as types to the NEP-algorithms, which uses it to dispatch the correct version of the function <a href="#NonlinearEigenproblems.LinSolvers.eig_solve"><code>eig_solve</code></a>.</p><p><strong>Example</strong></p><p>The most common usecase is that you do not want to specify anything in particular, since the <a href="#NonlinearEigenproblems.LinSolvers.DefaultEigSolver"><code>DefaultEigSolver</code></a> will use a dense or a sparse method depending on you problem. However, this example shows how you can force <code>mslp</code> to use the sparse solver.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; λ,v = mslp(nep, eigsolvertype=NativeEigSSolver);
julia&gt; norm(compute_Mlincomb(nep,λ,v))
1.0324139764567768e-15</code></pre><p><strong>Example</strong></p><p>The <code>EigSolver</code>s are constructed for extendability. As an illustartion this example creates a naive <code>EigSolver</code> which casts the problem to a standard linear eigenproblem and calls the built-in function to solve it.</p><p>Create the types and a creator.</p><pre><code class="language-julia-repl">julia&gt; struct MyEigSolver &lt;: EigSolver
   A
   E
   function MyEigSolver(A,E)
      return new(A,E)
   end
end

julia&gt; import NonlinearEigenproblems.LinSolvers.eig_solve;
julia&gt; function eig_solve(solver::MyEigSolver;nev = 1, target = 0)
   M = solver.E \ solver.A
   eig = eigen(M)
   i = argmin(abs.(eig.values))
   return eig.values[i], eig.vectors[:,i]
end
julia&gt; nep=nep_gallery(&quot;dep0&quot;, 50);
julia&gt; λ,v = mslp(nep, eigsolvertype=MyEigSolver, tol=1e-5);
julia&gt; norm(compute_Mlincomb(nep,λ,v))
3.0777795031319117e-10</code></pre><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.eig_solve"><code>eig_solve</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.DefaultEigSolver"><code>DefaultEigSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.NativeEigSolver"><code>NativeEigSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.NativeEigSSolver"><code>NativeEigSSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.eig_solve"><code>eig_solve</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/638967a4093c2468dcd5a9509aa4e3b754214371/src/LinSolvers.jl#L202-L257">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.eig_solve" href="#NonlinearEigenproblems.LinSolvers.eig_solve"><code>NonlinearEigenproblems.LinSolvers.eig_solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">eig_solve(solver::EigSolver; [nev,] [target,])</code></pre><p>This function solves the linear eigenvalue problem represented in <code>solver::EigSolver</code>. The <code>nev</code> kwarg is controlling the number of eigenvalues aimed for, and <code>target</code> specifies around which point the eigenvalues are computed. The former has a defalut value equalt to the seize of the problem, and the latter has a defalut value 0.</p><p>Return values are of the form (Vector, Matrix) where the former contains the eigenvalues and the latter the eigenvectors.</p><p>This function must be overloaded if a user wants to define their own way of solving linear eigenvalue problems. See <a href="#NonlinearEigenproblems.LinSolvers.EigSolver"><code>EigSolver</code></a> for examples.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/638967a4093c2468dcd5a9509aa4e3b754214371/src/LinSolvers.jl#L398-L411">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.DefaultEigSolver" href="#NonlinearEigenproblems.LinSolvers.DefaultEigSolver"><code>NonlinearEigenproblems.LinSolvers.DefaultEigSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct DefaultEigSolver &lt;: EigSolver</code></pre><p>A linear eigenvalueproblem solver that calls checks for sparsity and accordingly assigns an appropriate solver.</p><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.EigSolver"><code>EigSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.eig_solve"><code>eig_solve</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.NativeEigSolver"><code>NativeEigSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.NativeEigSSolver"><code>NativeEigSSolver</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/638967a4093c2468dcd5a9509aa4e3b754214371/src/LinSolvers.jl#L366-L373">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.NativeEigSolver" href="#NonlinearEigenproblems.LinSolvers.NativeEigSolver"><code>NonlinearEigenproblems.LinSolvers.NativeEigSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct NativeEigSolver &lt;: EigSolver</code></pre><p>A linear eigenvalueproblem solver that calls Julia&#39;s in-built eigen()</p><p>Constructed as <code>NativeEigSolver(A, [B,])</code>, and solves the problem</p><div>\[Ax = λBx\]</div><p>The paramter <code>B</code> is optional an default is indentity, for which a standard linear eigenproblem is solved.</p><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.EigSolver"><code>EigSolver</code></a> and <a href="#NonlinearEigenproblems.LinSolvers.eig_solve"><code>eig_solve</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/638967a4093c2468dcd5a9509aa4e3b754214371/src/LinSolvers.jl#L262-L275">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.NativeEigSSolver" href="#NonlinearEigenproblems.LinSolvers.NativeEigSSolver"><code>NonlinearEigenproblems.LinSolvers.NativeEigSSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct NativeEigSSolver &lt;: EigSolver</code></pre><p>A linear eigenvalueproblem solver for large and sparse problems that calls Julia&#39;s in-built eigs()</p><p>Constructed as <code>NativeEigSSolver(A, [B,])</code>, and solves the problem</p><div>\[Ax = λBx\]</div><p>The paramter <code>B</code> is optional an default is indentity, for which a standard linear eigenproblem is solved.</p><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.EigSolver"><code>EigSolver</code></a> and <a href="#NonlinearEigenproblems.LinSolvers.eig_solve"><code>eig_solve</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/638967a4093c2468dcd5a9509aa4e3b754214371/src/LinSolvers.jl#L306-L320">source</a></section><footer><hr/><a class="previous" href="../types/"><span class="direction">Previous</span><span class="title">NEP Types</span></a><a class="next" href="../errmeasure/"><span class="direction">Next</span><span class="title">Error measure</span></a></footer></article></body></html>
