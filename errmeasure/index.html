<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Error measure · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../methods/">NEP Methods</a></li><li><a class="toctext" href="../types/">NEP Types</a></li><li><a class="toctext" href="../linsolvers/">LinSolver</a></li><li class="current"><a class="toctext" href>Error measure</a><ul class="internal"><li><a class="toctext" href="#Standard-usage-1">Standard usage</a></li><li><a class="toctext" href="#User-defined-error-measure-1">User defined error measure</a></li><li><a class="toctext" href="#A-user-defined-type-1">A user defined type</a></li><li><a class="toctext" href="#As-a-NEP-solver-developer-1">As a NEP-solver developer</a></li></ul></li><li><a class="toctext" href="../transformations/">NEP Transformations</a></li><li><a class="toctext" href="../gallery/">NEP Gallery</a></li><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 2 (BEM)</a></li><li><a class="toctext" href="../deflate_tutorial/">Tutorial 3 (Deflation)</a></li><li><a class="toctext" href="../tutorial_call_python/">Tutorial 4 (Python NEP)</a></li><li><a class="toctext" href="../tutorial_matlab1/">Tutorial 5 (MATLAB 1)</a></li><li><a class="toctext" href="../tutorial_fortran1/">Tutorial 6 (FORTRAN 1)</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Error measure</a></li></ul><a class="edit-page" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/errmeasure.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Error measure</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Measuring-the-error-1" href="#Measuring-the-error-1">Measuring the error</a></h1><p>** This only works on NEP-PACK version 0.2.6 and onwards **</p><p>All iterative algorithms need some form of termination criteria. In NEP-PACK, all NEP-solvers provide the possibility to specify the desired tolerance, as well as how the error is measured or estimated. The tolerance is specified in the kwarg  <code>tol</code> (which is a real number) and the way to measure the error is given in <code>errmeasure</code>.</p><h2><a class="nav-anchor" id="Standard-usage-1" href="#Standard-usage-1">Standard usage</a></h2><p>NEP-PACK comes with several ways to measure errors for many NEP-types.</p><ul><li><code>errmeasure=ResidualErrmeasure</code>: The error is estimated by the use</li></ul><p>of the residual norm:</p><div>\[{\mathrm err}=\frac{\|M(λ)v\|}{\|v\|}.\]</div><ul><li><code>errmeasure=BackwardErrmeasure</code>: The error is estimated by using the backward error bounds. This error measure will not work for all NEPs. Default implementation is provided for any <code>AbstractSPMF</code>. If your NEP is an <code>AbstractSPMF</code> with terms:</li></ul><div>\[M(λ)=A_1f_1(λ)+\cdots+A_mf_m(λ)\]</div><p>the error will be estimated by</p><div>\[{\mathrm err}=\frac{\|M(λ)v\|}{\|v\|}
\frac{1}{\|A_1\|_F|f_1(λ)|+\cdots+\|A_m\|_F|f_m(λ)|}.\]</div><p>In other words, the <code>BackwardErrmeasure</code> is a weighting of the <code>ResidualErrmeasure</code>.</p><ul><li><code>errmeasure=DefaultErrmeasure</code>: When this <code>errmeasure</code> is specified, NEP-PACK tries to determine a error measure for you. In general, <code>BackwardErrmeasure</code> will be preferred if possible.</li></ul><p>Example:</p><p>Most NEP-solvers take the <code>errmeasure</code> as an kwarg.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; # Solve the problem to residual norm 1e-8
julia&gt; (λ,v)=mslp(nep,errmeasure=ResidualErrmeasure,tol=1e-8)
julia&gt; norm(compute_Mlincomb(nep,λ,v))/norm(v) # It&#39;s smaller than tol?
3.503700819937386e-9
julia&gt; nep isa AbstractSPMF # Is it an AbstractSPMF so we can use BackwardErrmeasure?
true
julia&gt; (λ,v)=mslp(nep,errmeasure=BackwardErrmeasure,tol=1e-10)
julia&gt; factor=abs(fv[1](λ))*norm(Av[1])+
     abs(fv[2](λ))*norm(Av[2])+abs(fv[3](λ))*norm(Av[3]);
julia&gt; norm(compute_Mlincomb(nep,λ,v))/(norm(v)*factor)
1.659169482386331e-11</code></pre><h2><a class="nav-anchor" id="User-defined-error-measure-1" href="#User-defined-error-measure-1">User defined error measure</a></h2><p>There are two ways that a user can specify how to measure the error.</p><h3><a class="nav-anchor" id="Function-handle-1" href="#Function-handle-1">Function handle</a></h3><p>The easiest is that the user gives a function handle which is called to obtain the error. The <code>errmeasure</code> can be a function, which takes two parameters as input <code>(λ,v)</code> and returns the error </p><p>The most common situation is that you want to report the error (as a function of iteration) with a reference solutions.  If we want to get a very accurate approximation of the true error, we can run the  algorithm twice, and the second time we run the algorithm we use the result of the first run as a reference. </p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; v0=ones(size(nep,1));
julia&gt; (λref,v)=resinv(nep,v=v0,λ=230^2+1im,displaylevel=1);
julia&gt; myerrmeasure = (λ,v) -&gt; abs(λ-λref)/abs(λ);
julia&gt; (λ,v)=resinv(nep,v=v0,λ=250^2+1im,displaylevel=1,tol=1e-10,errmeasure=myerrmeasure);
Iteration:  1 errmeasure:1.274091618457501296e-01 
Iteration:  2 errmeasure:9.535794095609478882e-01 
...
Iteration: 49 errmeasure:1.269396691930517923e-10 
Iteration: 50 errmeasure:7.608430406801784718e-11 </code></pre><h2><a class="nav-anchor" id="A-user-defined-type-1" href="#A-user-defined-type-1">A user defined type</a></h2><p>Julia can be faster when we use types instead of function handles. It is  possible to provide carry out the same simulation as above with a user defined type. </p><p>You first need to define a new type</p><pre><code class="language-julia-repl">julia&gt; struct RefErrmeasure &lt;: Errmeasure; nep::NEP; end</code></pre><p>The error measure should then provided in the function  <code>estimate_error</code>:</p><pre><code class="language-julia-repl">julia&gt; v0=ones(size(nep,1));
julia&gt; (λref,v)=resinv(nep,v=v0,λ=230^2+1im,displaylevel=1);
julia&gt; function NonlinearEigenproblems.estimate_error(e::RefErrmeasure,λ,v)
         return abs(λ-λref)/abs(λ);
       end
julia&gt; (λ,v)=resinv(nep,v=v0,λ=250^2+1im,displaylevel=1,tol=1e-10,errmeasure=RefErrmeasure);
Iteration:  1 errmeasure:1.274091618457501296e-01 
...
Iteration: 49 errmeasure:1.269396691930517923e-10 
Iteration: 50 errmeasure:7.608430406801784718e-11 </code></pre><h2><a class="nav-anchor" id="As-a-NEP-solver-developer-1" href="#As-a-NEP-solver-developer-1">As a NEP-solver developer</a></h2><p>NEP-solvers should use the <code>Errmeasure</code> as follows. The NEP-solver should take as input a <code>ErrmeasureType</code> (which corresponds to either a function or a type, but this you will not have to worry about).</p><pre><code class="language-julia">function mysolver(nep::NEP;errmeasure::ErrmeasureType=DefaultErrmeasure)</code></pre><p>Before the main iteration, you need to initialize the error measure computation. The precomptued data  is stored in a variable typically called <code>ermdata</code>: </p><pre><code class="language-julia">   ermdata=init_errmeasure(errmeasure,nep);</code></pre><p>In the main for loop you want to call the <code>estimate_error</code> function:</p><pre><code class="language-julia">for k=1:maxit
    err=estimate_error(ermdata,λ,v)
    if (err &lt; 1e-10)
       return (λ,v)
    end 
    ....

end </code></pre><footer><hr/><a class="previous" href="../linsolvers/"><span class="direction">Previous</span><span class="title">LinSolver</span></a><a class="next" href="../transformations/"><span class="direction">Next</span><span class="title">NEP Transformations</span></a></footer></article></body></html>
