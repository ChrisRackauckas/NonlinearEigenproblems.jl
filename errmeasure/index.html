<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Measuring the error · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../methods/">NEP-Solvers</a></li><li><a class="toctext" href="../types/">NEP Types</a></li><li><a class="toctext" href="../linsolvers/">LinSolvers</a></li><li><a class="toctext" href="../innersolvers/">Inner solvers</a></li><li class="current"><a class="toctext" href>Measuring the error</a><ul class="internal"><li><a class="toctext" href="#Standard-usage-1">Standard usage</a></li><li><a class="toctext" href="#User-defined-error-measure-1">User defined error measure</a></li><li><a class="toctext" href="#As-a-NEP-solver-developer-1">As a NEP-solver developer</a></li><li><a class="toctext" href="#Methods-and-types-1">Methods and types</a></li></ul></li><li><a class="toctext" href="../logger/">Logger</a></li><li><a class="toctext" href="../transformations/">Transforming NEPs</a></li><li><a class="toctext" href="../gallery/">Gallery</a></li></ul></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="toctext" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="toctext" href="../tutorial_call_python/">Tutorial 5 (Python)</a></li><li><a class="toctext" href="../tutorial_matlab1/">Tutorial 6 (MATLAB)</a></li><li><a class="toctext" href="../tutorial_fortran1/">Tutorial 7 (FORTRAN)</a></li><li><a class="toctext" href="../tutorial_nano1/">Tutorial 8 (gmsh + nanophotonics)</a></li><li><a class="toctext" href="../tutorial_newmethod/">Tutorial 9 (New solver)</a></li><li><a class="toctext" href="../tutorial_linsolve/">Tutorial 10 (Linear solvers)</a></li><li><a class="toctext" href="../hydrotutorial/">Tutorial 11 (Orr-Somerfeld)</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Measuring the error</a></li></ul><a class="edit-page" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/errmeasure.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Measuring the error</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Measuring-the-error-1" href="#Measuring-the-error-1">Measuring the error</a></h1><p>All iterative algorithms need some form of termination criteria. In NEP-PACK, all NEP-solvers provide the possibility to specify the desired tolerance, as well as how the error is measured or estimated. The tolerance is specified in the kwarg  <code>tol</code> (which is a real number) and the way to measure the error is given in <code>errmeasure</code>.</p><h2><a class="nav-anchor" id="Standard-usage-1" href="#Standard-usage-1">Standard usage</a></h2><p>NEP-PACK comes with several ways to measure errors for many NEP-types.</p><ul><li><code>errmeasure=ResidualErrmeasure</code>: The error is estimated by the use of the residual norm:</li></ul><div>\[\mathrm{err}=\frac{\|M(λ)v\|}{\|v\|}.\]</div><ul><li><code>errmeasure=BackwardErrmeasure</code>: The error is estimated by using the backward error bounds. This error measure will not work for all NEPs. An implementation is provided for any <code>AbstractSPMF</code>. If your NEP is an <code>AbstractSPMF</code> with terms:<div>\[M(λ)=A_1f_1(λ)+\cdots+A_mf_m(λ)\]</div>the error will be estimated by<div>\[\mathrm{err}=\frac{\|M(λ)v\|}{\|v\|}\frac{1}{\|A_1\|_F|f_1(λ)|+\cdots+\|A_m\|_F|f_m(λ)|}.\]</div>In other words, the <code>BackwardErrmeasure</code> is a weighting of the <code>ResidualErrmeasure</code>.</li><li><code>errmeasure=DefaultErrmeasure</code>: When this <code>errmeasure</code> is specified, NEP-PACK tries to determine a error measure for you. In general, <code>BackwardErrmeasure</code> will be preferred if possible. This behavior may change in future versions of NEP-PACK.</li></ul><p>Example: Most NEP-solvers take the <code>errmeasure</code> as an kwarg.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; # Solve the problem to residual norm 1e-8
julia&gt; (λ,v)=mslp(nep,errmeasure=ResidualErrmeasure,tol=1e-8)
julia&gt; norm(compute_Mlincomb(nep,λ,v))/norm(v) # It&#39;s smaller than tol?
3.503700819937386e-9
julia&gt; nep isa AbstractSPMF # Is it an AbstractSPMF so we can use BackwardErrmeasure?
true
julia&gt; (λ,v)=mslp(nep,errmeasure=BackwardErrmeasure,tol=1e-10)
julia&gt; factor=abs(fv[1](λ))*norm(Av[1])+
     abs(fv[2](λ))*norm(Av[2])+abs(fv[3](λ))*norm(Av[3]);
julia&gt; norm(compute_Mlincomb(nep,λ,v))/(norm(v)*factor)
1.659169482386331e-11</code></pre><h2><a class="nav-anchor" id="User-defined-error-measure-1" href="#User-defined-error-measure-1">User defined error measure</a></h2><p>There are two ways that a user can specify how to measure the error.</p><h3><a class="nav-anchor" id="User-defined-error-1:-Function-handle-1" href="#User-defined-error-1:-Function-handle-1">User defined error 1: Function handle</a></h3><p>The user can provide a function handle which is called to obtain the error. The <code>errmeasure</code> can be a function, which takes two parameters as input <code>(λ,v)</code> and returns the error (or estimate thereof).</p><p>The most common situation is that you want to report the error (as a function of iteration) with a reference solutions. If we want to get a very accurate approximation of the true error, we can run the algorithm twice, and the second time we run the algorithm we use the result of the first run as a reference.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; v0=ones(size(nep,1));
julia&gt; (λref,v)=resinv(nep,v=v0,λ=230^2+1im,logger=1);
julia&gt; myerrmeasure = (λ,v) -&gt; abs(λ-λref)/abs(λ);
julia&gt; (λ,v)=resinv(nep,v=v0,λ=250^2+1im,logger=1,tol=1e-10,errmeasure=myerrmeasure);
Iteration:  1 errmeasure:1.274091618457501296e-01
Iteration:  2 errmeasure:9.535794095609478882e-01
...
Iteration: 49 errmeasure:1.269396691930517923e-10
Iteration: 50 errmeasure:7.608430406801784718e-11</code></pre><h3><a class="nav-anchor" id="User-defined-error-2:-A-user-defined-type-1" href="#User-defined-error-2:-A-user-defined-type-1">User defined error 2: A user defined type</a></h3><p>Due to the multiple dispatch and handling of types in Julia, code may run faster if one uses types instead of function handles. It is possible to do the same simulation as above with a user defined type.</p><p>You first need to define a new type</p><pre><code class="language-julia-repl">julia&gt; struct RefErrmeasure &lt;: Errmeasure; nep::NEP; end</code></pre><p>The error measure should then provided in the function <code>estimate_error</code>:</p><pre><code class="language-julia-repl">julia&gt; v0=ones(size(nep,1));
julia&gt; (λref,v)=resinv(nep,v=v0,λ=230^2+1im,logger=1);
julia&gt; function NonlinearEigenproblems.estimate_error(e::RefErrmeasure,λ,v)
         return abs(λ-λref)/abs(λ);
       end
julia&gt; (λ,v)=resinv(nep,v=v0,λ=250^2+1im,logger=1,tol=1e-10,errmeasure=RefErrmeasure);
Iteration:  1 errmeasure:1.274091618457501296e-01
...
Iteration: 49 errmeasure:1.269396691930517923e-10
Iteration: 50 errmeasure:7.608430406801784718e-11</code></pre><h2><a class="nav-anchor" id="As-a-NEP-solver-developer-1" href="#As-a-NEP-solver-developer-1">As a NEP-solver developer</a></h2><p>NEP-solvers should use the <code>Errmeasure</code> as follows. The NEP-solver should take as input a <code>ErrmeasureType</code>. This corresponds to either a function or a type, but if you follow the procedure below, you will not have to worry about that.</p><pre><code class="language-julia">function mysolver(nep::NEP;errmeasure::ErrmeasureType=DefaultErrmeasure)</code></pre><p>Before the main iteration, you need to initialize the error measure computation. The precomptued data is stored in a variable typically called <code>ermdata</code>:</p><pre><code class="language-julia">   ermdata=init_errmeasure(errmeasure,nep);</code></pre><p>In the main for loop you want to call the <code>estimate_error</code> function:</p><pre><code class="language-julia">for k=1:maxit
    err=estimate_error(ermdata,λ,v)
    if (err &lt; 1e-10)
       return (λ,v)
    end
    ....

end</code></pre><h2><a class="nav-anchor" id="Methods-and-types-1" href="#Methods-and-types-1">Methods and types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.Errmeasure" href="#NonlinearEigenproblems.NEPTypes.Errmeasure"><code>NonlinearEigenproblems.NEPTypes.Errmeasure</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type Errmeasure; end</code></pre><p>Concrete subtypes of <code>Errmeasure</code> represent specific ways of measuring the error of an eigenpair. NEP-solvers take a type as input and then instantiate a <code>Errmeasure</code>. As a NEP-solver user, you use the type as follows</p><pre><code class="language-julia">julia&gt; quasinewton(nep,errmeasure=ResidualErrmeasure)</code></pre><p>User-specified ways of measuring error can be given by creating a new subtype of <code>Errmeasure</code> and using it as a <code>errmeasure</code> keyword. You need to specify the way to measure the error in the method <code>estimate_error</code> and (optionally) <code>init_errmeasure</code>.</p><p><strong>Example</strong></p><p>This shows how to compute a reference solution and then use this as a reference solution. The error in the second run will be effectively the eigenvalue error. </p><pre><code class="language-julia">julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; (λref,vref)=quasinewton(nep,λ=-1);
julia&gt; struct EigvalError &lt;: Errmeasure; nep::NEP; end
julia&gt; function NonlinearEigenproblems.estimate_error(E::EigvalError,λ,v)
return abs(λref-λ);
end
julia&gt; (λ,v)=quasinewton(nep,errmeasure=EigvalError,λ=-1.0 ,logger=1,tol=5e-13)
Precomputing linsolver
Iteration:  1 errmeasure:2.466988587467300320e-03, λ=-1.0 + 0.0im
Iteration:  2 errmeasure:4.625160667012763183e-01, λ=-0.539950921886191 + 0.0im
Iteration:  3 errmeasure:2.799848726755167494e-01, λ=-1.282451861262984 + 0.0im
Iteration:  4 errmeasure:3.422925625951256379e-02, λ=-1.0366962448469799 + 0.0im
Iteration:  5 errmeasure:5.530128437585268841e-04, λ=-1.0019139757437088 + 0.0im
Iteration:  6 errmeasure:1.159388768512403800e-04, λ=-1.002351049710616 + 0.0im
Iteration:  7 errmeasure:2.658434455016234210e-06, λ=-1.0024643301530123 + 0.0im
Iteration:  8 errmeasure:1.726871190488310503e-07, λ=-1.0024668159003483 + 0.0im
Iteration:  9 errmeasure:4.819693533164581822e-09, λ=-1.0024669934071608 + 0.0im
Iteration: 10 errmeasure:5.234268574128009277e-10, λ=-1.0024669880640404 + 0.0im
Iteration: 11 errmeasure:3.762568034915148019e-11, λ=-1.002466988625093 + 0.0im
Iteration: 12 errmeasure:3.205657961302676995e-12, λ=-1.0024669885842616 + 0.0im
Iteration: 13 errmeasure:3.352873534367972752e-14, λ=-1.0024669885874338 + 0.0im</code></pre><p>Note that this can also be achieved by providing a function handle:</p><pre><code class="language-julia">julia&gt; myerrmeasure= (λ,v) -&gt; abs(λref-λ);
julia&gt; (λ,v)=quasinewton(nep,errmeasure=myerrmeasure,λ=-1.0 ,logger=1,tol=5e-13)
...
Iteration: 12 errmeasure:3.205657961302676995e-12, λ=-1.0024669885842616 + 0.0im
Iteration: 13 errmeasure:3.352873534367972752e-14, λ=-1.0024669885874338 + 0.0im</code></pre><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.DefaultErrmeasure"><code>DefaultErrmeasure</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.ResidualErrmeasure"><code>ResidualErrmeasure</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.BackwardErrmeasure"><code>BackwardErrmeasure</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.estimate_error"><code>estimate_error</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.init_errmeasure"><code>init_errmeasure</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.estimate_error" href="#NonlinearEigenproblems.NEPTypes.estimate_error"><code>NonlinearEigenproblems.NEPTypes.estimate_error</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function estimate_error(E::Errmeasure,λ,v)</code></pre><p>Returns the error estimate for the eigenpair <code>(λ,v)</code>. The way to measure the error is specified in <code>Errmeasure</code>.</p><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.Errmeasure"><code>Errmeasure</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.init_errmeasure" href="#NonlinearEigenproblems.NEPTypes.init_errmeasure"><code>NonlinearEigenproblems.NEPTypes.init_errmeasure</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function init_errmeasure(E::Errmeasure,nep)</code></pre><p>This function is called in a precomputation phase for an error measure. For user defined <code>Errmeasure</code>, you do not need to overload this if your <code>Errmeasure</code> contains only one field which is a <code>NEP</code>.</p><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.Errmeasure"><code>Errmeasure</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.DefaultErrmeasure" href="#NonlinearEigenproblems.NEPTypes.DefaultErrmeasure"><code>NonlinearEigenproblems.NEPTypes.DefaultErrmeasure</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct DefaultErrmeasure &lt;: Errmeasure</code></pre><p>When you specify this <code>Errmeasure</code>, NEP-PACK tries to determine a suitable <code>Errmeasure</code> based on the type of the <code>NEP</code>. Note that this behavior may change in future versions.</p><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.Errmeasure"><code>Errmeasure</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.ResidualErrmeasure" href="#NonlinearEigenproblems.NEPTypes.ResidualErrmeasure"><code>NonlinearEigenproblems.NEPTypes.ResidualErrmeasure</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct ResidualErrmeasure &lt;: Errmeasure</code></pre><p>This <code>Errmeasure</code> species that the residual norm should be used to measure the error.</p><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.Errmeasure"><code>Errmeasure</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.BackwardErrmeasure" href="#NonlinearEigenproblems.NEPTypes.BackwardErrmeasure"><code>NonlinearEigenproblems.NEPTypes.BackwardErrmeasure</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct BackwardErrmeasure &lt;: Errmeasure</code></pre><p>This <code>Errmeasure</code> provides a way to compute the backward error. The backward error estimate are only given for NEPs which are subtypes of  <code>AbstractSPMF</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; (λ,v)=quasinewton(nep,λ=-1,errmeasure=BackwardErrmeasure,tol=1e-10);</code></pre><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.Errmeasure"><code>Errmeasure</code></a></p></div></div></section><footer><hr/><a class="previous" href="../innersolvers/"><span class="direction">Previous</span><span class="title">Inner solvers</span></a><a class="next" href="../logger/"><span class="direction">Next</span><span class="title">Logger</span></a></footer></article></body></html>
