<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Measuring the error · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../methods/">NEP-Solvers</a></li><li><a class="toctext" href="../types/">Types &amp; Data structures</a></li><li><a class="toctext" href="../compute_functions/">Compute functions</a></li><li><a class="toctext" href="../linsolvers/">Linear solvers</a></li><li><a class="toctext" href="../innersolvers/">Projection</a></li><li class="current"><a class="toctext" href>Measuring the error</a><ul class="internal"><li><a class="toctext" href="#Standard-usage-1">Standard usage</a></li><li><a class="toctext" href="#User-defined-error-measure-1">User defined error measure</a></li><li><a class="toctext" href="#As-a-NEP-solver-developer-1">As a NEP-solver developer</a></li><li><a class="toctext" href="#Methods-and-types-1">Methods and types</a></li></ul></li><li><a class="toctext" href="../logger/">Logger</a></li><li><a class="toctext" href="../transformations/">Transformations</a></li><li><a class="toctext" href="../deflation/">Tutorial: Computing several solutions with deflation</a></li><li><a class="toctext" href="../gallery/">Gallery</a></li></ul></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="toctext" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="toctext" href="../tutorial_call_python/">Tutorial 5 (Python)</a></li><li><a class="toctext" href="../tutorial_matlab1/">Tutorial 6 (MATLAB)</a></li><li><a class="toctext" href="../tutorial_fortran1/">Tutorial 7 (FORTRAN)</a></li><li><a class="toctext" href="../tutorial_nano1/">Tutorial 8 (gmsh + nanophotonics)</a></li><li><a class="toctext" href="../tutorial_newmethod/">Tutorial 9 (New solver)</a></li><li><a class="toctext" href="../tutorial_linsolve/">Tutorial 10 (Linear solvers)</a></li><li><a class="toctext" href="../hydrotutorial/">Tutorial 11 (Orr–Somerfeld)</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Measuring the error</a></li></ul><a class="edit-page" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/errmeasure.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Measuring the error</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Measuring-the-error-1" href="#Measuring-the-error-1">Measuring the error</a></h1><p>All iterative algorithms need some form of termination criteria. In NEP-PACK, all NEP-solvers provide the possibility to specify the desired tolerance, as well as how the error is measured or estimated. The tolerance is specified in the kwarg  <code>tol</code> (which is a real number) and the way to measure the error is given in <code>errmeasure</code>.</p><h2><a class="nav-anchor" id="Standard-usage-1" href="#Standard-usage-1">Standard usage</a></h2><p>NEP-PACK comes with several ways to measure errors for many NEP-types.</p><ul><li><code>errmeasure=</code><a href="#NonlinearEigenproblems.NEPTypes.ResidualErrmeasure"><code>ResidualErrmeasure</code></a><code>(nep)</code>: The error is estimated by the use of the residual norm:</li></ul><div>\[\mathrm{err}=\frac{\|M(λ)v\|}{\|v\|}.\]</div><ul><li><p><code>errmeasure=</code><a href="@ref"><code>StandardSPMFErrmeasure</code></a><code>(nep)</code>: The error is estimated by using backward error theory. This error measure will not work for all NEPs. An implementation is provided for any <code>AbstractSPMF</code>. If your NEP is an <code>AbstractSPMF</code> with terms:</p><div>\[M(λ)=A_1f_1(λ)+\cdots+A_mf_m(λ)\]</div><p>the error will be estimated by</p><div>\[\mathrm{err}=\frac{\|M(λ)v\|}{\|v\|}\frac{1}{\|A_1\|_F|f_1(λ)|+\cdots+\|A_m\|_F|f_m(λ)|}.\]</div><p>In other words, the <code>StandardSPMFErrmeasure</code> is a weighting of the <code>ResidualErrmeasure</code>.</p></li><li><p><code>errmeasure=</code><a href="#NonlinearEigenproblems.NEPTypes.DefaultErrmeasure"><code>DefaultErrmeasure</code></a><code>(nep)</code>: When this <code>errmeasure</code> is specified, NEP-PACK tries to determine a error measure for you. In general, <code>StandardSPMFErrmeasure</code> will be preferred if possible. This behavior may change in future versions of NEP-PACK.</p></li><li><p><code>errmeasure=</code><a href="#NonlinearEigenproblems.NEPTypes.EigvalReferenceErrmeasure"><code>EigvalReferenceErrmeasure</code></a><code>(nep,λref)</code>: This errmeasure is used when an exact (or very accurate) eigenvalue is already known. Typically, if you wish to visualize the eigenvalue error of a specific method, you run the method twice and use the result of the first run as to instantiate this error measure and get real eigenvalue errors as output.</p></li><li><p><code>errmeasure=(λ,v)-&gt; compute_error(λ,v)</code>: A user defined error measure can be specified using a function. The function should be take an eigenpair as input, and return a real value. See <a href="#NonlinearEigenproblems.NEPTypes.ErrmeasureType"><code>ErrmeasureType</code></a> for an example.</p></li></ul><p>Example: Most NEP-solvers take the <code>errmeasure</code> as an kwarg.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; # Solve the problem to residual norm 1e-8
julia&gt; (λ,v)=mslp(nep,errmeasure=ResidualErrmeasure(nep),tol=1e-8)
julia&gt; norm(compute_Mlincomb(nep,λ,v))/norm(v) # It&#39;s smaller than tol?
3.503700819937386e-9
julia&gt; nep isa AbstractSPMF # Is it an AbstractSPMF so we can use StandardSPMFErrmeasure?
true
julia&gt; (λ,v)=mslp(nep,errmeasure=StandardSPMFErrmeasure(nep),tol=1e-10)
julia&gt; factor=abs(fv[1](λ))*norm(Av[1])+
     abs(fv[2](λ))*norm(Av[2])+abs(fv[3](λ))*norm(Av[3]);
julia&gt; norm(compute_Mlincomb(nep,λ,v))/(norm(v)*factor)
1.659169482386331e-11</code></pre><h2><a class="nav-anchor" id="User-defined-error-measure-1" href="#User-defined-error-measure-1">User defined error measure</a></h2><p>There are two ways that a user can specify how to measure the error.</p><h3><a class="nav-anchor" id="User-defined-error-1:-Function-handle-1" href="#User-defined-error-1:-Function-handle-1">User defined error 1: Function handle</a></h3><p>The user can provide a function handle which is called to obtain the error. The <code>errmeasure</code> can be a function, which takes two parameters as input <code>(λ,v)</code> and returns the error (or estimate thereof).</p><p>The most common situation is that you want to report the error (as a function of iteration) with a reference solutions. If we want to get a very accurate approximation of the true error, we can run the algorithm twice, and the second time we run the algorithm we use the result of the first run as a reference.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; v0=ones(size(nep,1));
julia&gt; (λref,_)=resinv(nep,v=v0,λ=-0.1,logger=1);
julia&gt; myerrmeasure = (λ,v) -&gt; abs(λ-λref)/abs(λ);
julia&gt; (λ,v)=resinv(nep,v=v0,λ=-0.1,logger=1,tol=1e-10,errmeasure=myerrmeasure);
Precomputing linsolver
iter 1 err:0.02854168838549373 λ=-0.1 + 0.0im
iter 2 err:0.8397508140476416 λ=-0.6418389474323298 + 0.0im
iter 3 err:0.17336372619725743 λ=-0.08765753239354723 + 0.0im
iter 4 err:0.0005771170619943501 λ=-0.1029135620110966 + 0.0im
iter 5 err:4.762006833879597e-7 λ=-0.10285411985934721 + 0.0im
iter 6 err:4.074039107701665e-7 λ=-0.10285421074175707 + 0.0im
iter 7 err:2.6448037288912206e-8 λ=-0.10285417155884034 + 0.0im
iter 8 err:1.3926542408883378e-9 λ=-0.10285416898178967 + 0.0im
iter 9 err:6.324560618281378e-11 λ=-0.10285416884505445 + 0.0im</code></pre><h3><a class="nav-anchor" id="User-defined-error-2:-A-user-defined-type-1" href="#User-defined-error-2:-A-user-defined-type-1">User defined error 2: A user defined type</a></h3><p>Due to the multiple dispatch and handling of types in Julia, code may run faster if one uses types instead of function handles. It is possible to do the same simulation as above with a user defined type.</p><p>You first need to define a new type</p><pre><code class="language-julia-repl">julia&gt; struct RefErrmeasure &lt;: Errmeasure; end</code></pre><p>The error measure should then provided in the function <code>estimate_error</code> which we now define as the relative eigenvalue error:</p><pre><code class="language-julia-repl">julia&gt; v0=ones(size(nep,1));
julia&gt; (λref,v)=resinv(nep,v=v0,λ=230^2+1im,logger=0);
julia&gt; function NonlinearEigenproblems.estimate_error(e::RefErrmeasure,λ,v)
         return abs(λ-λref)/abs(λ);
       end
julia&gt; (λ,v)=resinv(nep,v=v0,λ=250^2+1im,logger=1,tol=1e-10,errmeasure=RefErrmeasure());
iter 1 err:0.12740916184575013 λ=62500.0 + 1.0im
iter 2 err:0.9535794095609479 λ=1.175146205389422e6 + 6663.738915456258im
iter 3 err:2.4041334742321228 λ=-38815.06145769358 + 1301.0064120392753im
....
iter 50 err:7.608430406801785e-11 λ=54550.13915567685 + 459.51715820395947im</code></pre><p>The printouts of the last call correspond to the relative eigenvalue error.</p><h2><a class="nav-anchor" id="As-a-NEP-solver-developer-1" href="#As-a-NEP-solver-developer-1">As a NEP-solver developer</a></h2><p>NEP-solvers should use the <code>Errmeasure</code> as follows. The NEP-solver should take as input an object of the type <code>Errmeasure</code>  or function. The fact that it can be different types, is transparent and a NEP-solver developer does not have to do anything to take care of that if the following procedure is followed.</p><p>Suppose your solver is defined in a function with this signature:</p><pre><code class="language-julia">function mysolver(nep::NEP;errmeasure::ErrmeasureType=DefaultErrmeasure(nep))</code></pre><p>In the main for loop you want to call the <code>estimate_error</code> function:</p><pre><code class="language-julia">for k=1:maxit
    err=estimate_error(errmeasure,λ,v)
    if (err &lt; 1e-10)
       return (λ,v)
    end
    ....

end</code></pre><h2><a class="nav-anchor" id="Methods-and-types-1" href="#Methods-and-types-1">Methods and types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.Errmeasure" href="#NonlinearEigenproblems.NEPTypes.Errmeasure"><code>NonlinearEigenproblems.NEPTypes.Errmeasure</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type Errmeasure; end</code></pre><p>Concrete subtypes of <code>Errmeasure</code> represent specific ways of measuring the error of an eigenpair. NEP-solvers take such an object as input. As a NEP-solver user, you use the type as follows</p><pre><code class="language-julia">julia&gt; quasinewton(nep,errmeasure=ResidualErrmeasure(nep))</code></pre><p>User-specified ways of measuring error can be given by creating a new subtype of <code>Errmeasure</code> and using it as a <code>errmeasure</code> keyword. You need to specify the way to measure the error in the method <code>estimate_error</code>.</p><p>Note that in practice a <code>Function</code> can essentially be used instead of a <code>Errmeasure</code>-object, which is a simple way to have user-defined error measures. See <a href="#NonlinearEigenproblems.NEPTypes.ErrmeasureType"><code>ErrmeasureType</code></a>.</p><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.ErrmeasureType"><code>ErrmeasureType</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.DefaultErrmeasure"><code>DefaultErrmeasure</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.ResidualErrmeasure"><code>ResidualErrmeasure</code></a>, <a href="@ref"><code>BackwardErrmeasure</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.estimate_error"><code>estimate_error</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.EigvalReferenceErrmeasure"><code>EigvalReferenceErrmeasure</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.DefaultErrmeasure" href="#NonlinearEigenproblems.NEPTypes.DefaultErrmeasure"><code>NonlinearEigenproblems.NEPTypes.DefaultErrmeasure</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct DefaultErrmeasure &lt;: Errmeasure
function DefaultErrmeasure(nep::NEP)</code></pre><p>When you specify this <code>Errmeasure</code>, NEP-PACK tries to determine a suitable <code>Errmeasure</code> based on the type of the <code>NEP</code>. Note that this behavior may change in future versions.</p><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.Errmeasure"><code>Errmeasure</code></a></p></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>StandardSPMFErrmeasure</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.ResidualErrmeasure" href="#NonlinearEigenproblems.NEPTypes.ResidualErrmeasure"><code>NonlinearEigenproblems.NEPTypes.ResidualErrmeasure</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct ResidualErrmeasure &lt;: Errmeasure
function ResidualErrmeasure(nep::NEP)</code></pre><p>This <code>Errmeasure</code> species that the residual norm should be used to measure the error.</p><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.Errmeasure"><code>Errmeasure</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.EigvalReferenceErrmeasure" href="#NonlinearEigenproblems.NEPTypes.EigvalReferenceErrmeasure"><code>NonlinearEigenproblems.NEPTypes.EigvalReferenceErrmeasure</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct EigvalReferenceErrmeasure{X&lt;:Number} &lt;: Errmeasure
function EigvalReferenceErrmeasure(λref,nep)</code></pre><p>Use the difference between a precomputed λ-value (reference solution) and the eigenvalue estimate as the error measure.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; using LinearAlgebra
julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; (λref,vref)=quasinewton(nep,λ=-1,v=ones(size(nep,1)));
julia&gt; (λ,v)=quasinewton(nep,errmeasure=EigvalReferenceErrmeasure(nep,λref),λ=-1.0 ,logger=1,tol=5e-13,v=ones(size(nep,1)))
Precomputing linsolver
iter 1 err:0.0024669885857651064 λ=-1.0 + 0.0im
iter 2 err:0.2961339774298044 λ=-0.7063330111559607 + 0.0im
iter 3 err:0.11050908031267426 λ=-0.8919579082730908 + 0.0im
iter 4 err:0.007291415670313883 λ=-1.009758404256079 + 0.0im
iter 5 err:8.460128136422718e-5 λ=-1.0023823873044009 + 0.0im
iter 6 err:9.01533362851481e-7 λ=-1.0024660870524023 + 0.0im
iter 7 err:8.006004341698514e-7 λ=-1.0024677891861993 + 0.0im
iter 8 err:3.889644784038637e-8 λ=-1.0024669496893173 + 0.0im
iter 9 err:3.2391431759037914e-9 λ=-1.0024669918249083 + 0.0im
iter 10 err:2.418489852828998e-10 λ=-1.0024669883439161 + 0.0im
iter 11 err:2.0229151687090052e-11 λ=-1.0024669886059943 + 0.0im
iter 12 err:0.0 λ=-1.002466988585765 + 0.0im</code></pre><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.Errmeasure"><code>Errmeasure</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.estimate_error" href="#NonlinearEigenproblems.NEPTypes.estimate_error"><code>NonlinearEigenproblems.NEPTypes.estimate_error</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function estimate_error(E::ErrmeasureType,λ,v)</code></pre><p>Returns the error estimate for the eigenpair <code>(λ,v)</code>. The way to measure the error is specified in <code>E</code>, which can be an <code>Errmeasure</code> or a <code>Function</code>.</p><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.Errmeasure"><code>Errmeasure</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.ErrmeasureType"><code>ErrmeasureType</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.ErrmeasureType" href="#NonlinearEigenproblems.NEPTypes.ErrmeasureType"><code>NonlinearEigenproblems.NEPTypes.ErrmeasureType</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">ErrmeasureType = Union{Type{&lt;:Errmeasure}, Function}</code></pre><p>The <code>ErrmeasureType</code> represents (essentially) what you can insert in the <code>errmeasure</code> keyword argument for most NEP-solvers. It can be a function or an  <a href="#NonlinearEigenproblems.NEPTypes.Errmeasure"><code>Errmeasure</code></a> object. If it is a <code>Function</code> this function will be used to obtain error estimate.</p><p><strong>Example</strong></p><p>This shows how to compute a reference solution and then use this as a reference solution. The error in the second run will be effectively the eigenvector error (appropriately normalized).</p><pre><code class="language-julia">julia&gt; using LinearAlgebra
julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; (λref,vref)=quasinewton(nep,λ=-1,v=ones(size(nep,1)));
julia&gt; myerrmeasure=(λ,v) -&gt; norm(vref/vref[1]-v/v[1])
julia&gt; (λ,v)=quasinewton(nep,errmeasure=myerrmeasure,λ=-1.0 ,logger=1,tol=5e-13,v=ones(size(nep,1)))
Precomputing linsolver
iter 1 err:0.0024669885857651064 λ=-1.0 + 0.0im
iter 2 err:0.2961339774298044 λ=-0.7063330111559607 + 0.0im
iter 3 err:0.11050908031267426 λ=-0.8919579082730908 + 0.0im
iter 4 err:0.007291415670313883 λ=-1.009758404256079 + 0.0im
iter 5 err:8.460128136422718e-5 λ=-1.0023823873044009 + 0.0im
iter 6 err:9.01533362851481e-7 λ=-1.0024660870524023 + 0.0im
iter 7 err:8.006004341698514e-7 λ=-1.0024677891861993 + 0.0im
iter 8 err:3.889644784038637e-8 λ=-1.0024669496893173 + 0.0im
iter 9 err:3.2391431759037914e-9 λ=-1.0024669918249083 + 0.0im
iter 10 err:2.418489852828998e-10 λ=-1.0024669883439161 + 0.0im
iter 11 err:2.0229151687090052e-11 λ=-1.0024669886059943 + 0.0im
iter 12 err:0.0 λ=-1.002466988585765 + 0.0im</code></pre><p>The eigenvalue error can be measured with the <a href="#NonlinearEigenproblems.NEPTypes.EigvalReferenceErrmeasure"><code>EigvalReferenceErrmeasure</code></a>.</p><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.Errmeasure"><code>Errmeasure</code></a></p></div></div></section><footer><hr/><a class="previous" href="../innersolvers/"><span class="direction">Previous</span><span class="title">Projection</span></a><a class="next" href="../logger/"><span class="direction">Next</span><span class="title">Logger</span></a></footer></article></body></html>
