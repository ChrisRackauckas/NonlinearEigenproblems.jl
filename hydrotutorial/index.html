<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 11 (Orr-Somerfeld) · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../methods/">NEP Methods</a></li><li><a class="toctext" href="../types/">NEP Types</a></li><li><a class="toctext" href="../linsolvers/">LinSolver</a></li><li><a class="toctext" href="../errmeasure/">Error measure</a></li><li><a class="toctext" href="../logger/">Logger</a></li><li><a class="toctext" href="../transformations/">NEP Transformations</a></li><li><a class="toctext" href="../gallery/">NEP Gallery</a></li><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="toctext" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="toctext" href="../tutorial_call_python/">Tutorial 5 (Python NEP)</a></li><li><a class="toctext" href="../tutorial_matlab1/">Tutorial 6 (MATLAB 1)</a></li><li><a class="toctext" href="../tutorial_fortran1/">Tutorial 7 (FORTRAN 1)</a></li><li><a class="toctext" href="../tutorial_nano1/">Tutorial 8 (gmsh + nanophotonics)</a></li><li><a class="toctext" href="../tutorial_newmethod/">Tutorial 9 (New solver)</a></li><li><a class="toctext" href="../tutorial_linsolve/">Tutorial 10 (Linear solvers)</a></li><li class="current"><a class="toctext" href>Tutorial 11 (Orr-Somerfeld)</a><ul class="internal"><li><a class="toctext" href="#Background-1">Background</a></li><li><a class="toctext" href="#Formulation-as-a-nonlinear-eigenvalue-problem-1">Formulation as a nonlinear eigenvalue problem</a></li><li><a class="toctext" href="#Problem-setup-in-NEP-PACK-1">Problem setup in NEP-PACK</a></li><li><a class="toctext" href="#Solving-with-NEP-PACK-1">Solving with NEP-PACK</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Tutorial 11 (Orr-Somerfeld)</a></li></ul><a class="edit-page" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/hydrotutorial.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial 11 (Orr-Somerfeld)</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial:-Stability-of-parallel-shear-flows-1" href="#Tutorial:-Stability-of-parallel-shear-flows-1">Tutorial: Stability of parallel shear flows</a></h1><h2><a class="nav-anchor" id="Background-1" href="#Background-1">Background</a></h2><p>Stability analysis of flows is a very important problem in fluid mechanics.  Linearizing the Navier-Stokes equations around the mean flow and then eliminating pressure gives us the Orr-Sommerfeld and Squire equations, which are a system of fourth order PDEs describing the dynamics:</p><div>\[\left(\Big(\dfrac{\partial }{\partial t}+U\dfrac{\partial }{\partial x}\Big)\nabla^2-U&#39;&#39;\dfrac{\partial }{\partial x}-\frac{1}{Re}\nabla^4\right)v = 0\\
\left(\dfrac{\partial }{\partial t}+U\dfrac{\partial }{\partial x}-\frac{1}{Re}\nabla^2\right)\eta = -U&#39;&#39;\dfrac{\partial v}{\partial z}\]</div><p>More precisely, these equations stem from modeling using a mean base laminar flow <span>$\overline{U} = \begin{pmatrix}U(y)&amp; 0&amp; 0\end{pmatrix}$</span> and the perturbation <span>$u&#39; = \begin{pmatrix}u&amp; v&amp; w\end{pmatrix}$</span>. The normal vorticity is denoted <span>$\eta$</span>.</p><p>This is a text-book model for fluid flows. This model is often used to study stability by making a plane wave ansatz and a transformation, and subsequently rewriting the discretized problem as a large standard eigenvalue problem <a href="https://www.springer.com/gp/book/9780387989853#aboutBook">Chapter 7, Stability and Transition in Shear Flows, Schmid, Peter J., Henningson, Dan S</a>. We will here show that the plane wave ansatz directly leads to a NEP, which can be solved with methods in NEP-PACK without any additional transformations. We reproduce computational results in the above reference.</p><p>We thank Miguel Beneitez and Prabal Negi, Department of Mechanics, KTH for the valuable discussions and the discretization code.</p><h2><a class="nav-anchor" id="Formulation-as-a-nonlinear-eigenvalue-problem-1" href="#Formulation-as-a-nonlinear-eigenvalue-problem-1">Formulation as a nonlinear eigenvalue problem</a></h2><p>To study stability we use the plane wave perturbations ansatz </p><div>\[v(x,y,z,t) = \tilde{v}(y)\exp(i(\alpha x+\beta z-\omega t))\\
\eta(x,y,z,t) = \tilde{\eta}(y)\exp(i(\alpha x+\beta z-\omega t)),\]</div><p>which transforms the system to</p><div>\[\left((-i\omega+i\alpha U)(\mathcal{D}^2-\alpha^2-\beta^2)-i\alpha U&#39;&#39;-\frac{1}{Re}(\mathcal{D}^2-\alpha^2-\beta^2)^2\right)\tilde{v} = 0,\\
\left((-i\omega+i\alpha U)-\frac{1}{Re}(\mathcal{D}^2-\alpha^2-\beta^2)\right)\eta = -i\beta U&#39;\tilde{v},\]</div><p>where <span>$\mathcal{D}$</span> denotes the 1-D differential operator <span>$\frac{\partial }{\partial y}$</span>. In this example, we consider the boundary conditions <span>$\tilde{v} = \mathcal{D}\tilde{v} = \tilde{\eta} = 0$</span>. We assume that <span>$\beta$</span> and <span>$\omega$</span> are given and we wish to solve for the eigenvalue <span>$\alpha\in\mathbb{C}$</span>.</p><p>This is usually done by using a transformation of the form </p><div>\[\begin{pmatrix}\tilde{v}\\ \tilde{\eta}\end{pmatrix} = \begin{pmatrix}\tilde{V}\\ \tilde{E}\end{pmatrix}\exp(-\alpha y)\]</div><p>which reduces the power of <span>$\alpha$</span> from four to two. The problem is then discretized and solved as a quadratic eigenvalue problem. See Chapter 7 in Schmid-Henningson for details.  </p><p>Rather than using the transformation approach described in the book of  Schmid-Henningson, we  simply discretize <span>$\mathcal{D}$</span> to <span>$D$</span> (using a suitable numerical discretization) which leads to a polynomial eigenvalue problem of fourth order. </p><p>We define diagonal matrices <span>$U_0$</span>, <span>$U_1$</span> and <span>$U_2$</span>  as follows. </p><div>\[U_0 = diag(U(y_0),U(y_1),\ldots,U(y_n)),\\
U_1 = diag(U&#39;(y_0),U&#39;(y_1),\ldots,U&#39;(y_n)),\\
U_2 = diag(U&#39;&#39;(y_0),U&#39;&#39;(y_1),\ldots,U&#39;&#39;(y_n)).\\\]</div><p>Here <span>$\{y_i\}_{i=1,\ldots,n}$</span> denotes the y-coordinates of the <span>$n$</span> grid points used for discretization. The discretized problem after expanding the powers gives </p><div>\[\left[-\frac{I}{Re}\alpha^4-iU_0\alpha^3+\left(\frac{2D^2}{Re}+\left(i\omega-
\frac{2\beta^2}{Re}\right)I\right)\alpha^2\right.+\\
\left.\left(iU_0(D^2-\beta^2I)-U_2\right)\alpha +\Big(\frac{2\beta^2D^2}{Re}-\frac{D^4}{Re}-\frac{\beta^4I}{Re}+i\omega(\beta^2I-D^2)\Big)\right]\tilde{v} = 0\\
i\beta U_1\tilde{v}+\left[\frac{I}{Re}\alpha^2 + iU_0 \alpha +\left(\left(\frac{\beta^2}{Re}-i\omega\right)I-\frac{D^2}{Re}\right)\right]\tilde{\eta} = 0\]</div><p>This can be be formulated as a polynomial eigenvalue problem where</p><div>\[M(\lambda) = A_0+A_1\lambda+A_2\lambda^2+A_3\lambda^3+A_4\lambda^4,\]</div><p>and the matrices <span>$A_0,\ldots,A_4$</span> are given by</p><div>\[A_0 = \begin{pmatrix}\frac{2\beta^2D^2}{Re}-\frac{D^4}{Re}-\frac{\beta^4I}{Re}+i\omega(\beta^2I-D^2)&amp; 0\\ i\beta U_1&amp;\left(\frac{\beta^2}{Re}-i\omega\right)I-\frac{D^2}{Re}\end{pmatrix}\\
A_1 = \begin{pmatrix}-iU_0&amp; 0\\0&amp; 0\end{pmatrix}\\
A_2 = \begin{pmatrix}\frac{2D^2}{Re}+\left(i\omega-
\frac{2\beta^2}{Re}\right)I&amp; 0\\0&amp; \frac{I}{Re}\end{pmatrix}\\
A_3 = \begin{pmatrix}iU_0(D^2-\beta^2I)-U_2&amp; 0\\0&amp; iU_0\end{pmatrix}\\
A_4 = \begin{pmatrix}-\frac{I}{Re}&amp; 0\\0&amp; 0\end{pmatrix}\]</div><h2><a class="nav-anchor" id="Problem-setup-in-NEP-PACK-1" href="#Problem-setup-in-NEP-PACK-1">Problem setup in NEP-PACK</a></h2><p>We begin by initializing the parameters to the values used to generate the data in Table 7.1 in Schmid-Henningson. </p><pre><code class="language-julia">## Parameters
N = 256;      # Number of interior points
Re = 2000;    # Reynolds number
ω  = 0.3;     # Input frequency
β  = 0.0;     # Spanwise wavenumber</code></pre><p>To set up the matrices <span>$A_i$</span>, we need the discretized matrices corresponding to the operators <span>$\mathcal{D}^2$</span> and <span>$\mathcal{D}^4$</span>. Here, we do this using Chebyshev nodes. </p><pre><code class="language-julia">## Çhebyshev discretization of differential operators
yF,DM = chebdif(N+2, 4);    
D2 = DM[2:N+1,2:N+1,2];              #D^2

yF,D4 = cheb4c(N+2);
eye = Matrix{Float64}(I, N, N);      #D^4</code></pre><p>The code for implementation of <code>chebdif()</code> and <code>cheb4c()</code> is provided in <a href="https://nep-pack.github.io/NonlinearEigenproblems.jl/cheb4c.jl">cheb4c.jl</a> and <a href="https://nep-pack.github.io/NonlinearEigenproblems.jl/chebdif.jl">chebdif.jl</a>. We can now set up the coefficient matrices and create a corresponding PEP object.</p><pre><code class="language-julia">#Setup coefficient matrices
A4 = [-eye/Re zeros(N,N);zeros(N,N) zeros(N,N)];
A3 = [-1im*diagm(0 =&gt; U) zeros(N,N);zeros(N,N) zeros(N,N)];
A2 = [(1im*ω-2β^2/Re)*eye+2D2/Re zeros(N,N);zeros(N,N) eye/Re];
A1 = [1im*(diagm(0 =&gt; U)*(D2-eye*β^2)-Upp*eye) zeros(N,N);zeros(N,N) 1im*diagm(0=&gt;U)];
A0 = [2β^2*D2/Re-D4/Re-β^4*eye/Re+1im*ω*(β^2*eye-D2) zeros(N,N);1im*β*diagm(0 =&gt; Up) (-1im*ω+β^2/Re)*eye-D2/Re];

#Create a PEP object
nep = PEP([A0,A1,A2,A3,A4]);</code></pre><h2><a class="nav-anchor" id="Solving-with-NEP-PACK-1" href="#Solving-with-NEP-PACK-1">Solving with NEP-PACK</a></h2><p>Before we proceed to using one of NEP-PACK&#39;s methods, we have to consider the issue of poorly scaled coefficient matrices. Hence, direct application of NEP-PACK&#39;s solvers on this problem is not adequate. </p><pre><code class="language-julia-repl">julia&gt; norm(A0)
8.37194982854379e13
julia&gt; norm(A1)
473949.06740743306
julia&gt; norm(A2)
303285.4108872535
julia&gt; norm(A3)
9.817076958035932
julia&gt; norm(A4)
0.008</code></pre><p>We can get around this issue by scaling the PEP with NEP-PACK&#39;s <code>shift_and_scale()</code> , and solving the scaled problem <span>$T(\lambda) = M(100\lambda)$</span> instead. </p><pre><code class="language-julia">sc=100;
nep1 = shift_and_scale(nep,scale=sc);
mult_scale= norm(nep1.A[end]);
nep2 = PEP(nep1.A ./ mult_scale)</code></pre><p>The scaled PEP has much better scaled coefficient matrices.</p><pre><code class="language-julia-repl">julia&gt; norm.(get_Av(nep2))
5-element Array{Float64,1}:
    1.0464937285679738e8
   59.24363342592913    
 3791.0676360906696     
   12.271346197544913   
    1.0 </code></pre><p>In this example, we are interested in computing several eigenvalues and our region of interest for the spectrum is in the first quadrant. We use the Tensor Infinite Arnoldi (TIAR) method implemented in <a href="../methods/#NonlinearEigenproblems.NEPSolver.tiar"><code>tiar()</code></a>. The method is called twice with different shifts <code>σ</code>. </p><pre><code class="language-julia-repl">λ1,v1 = tiar(nep2,σ=0.006,v=ones(size(nep,1)),neigs=10,maxit=200,tol=1e-14)
λ2,v2 = tiar(nep2,σ=0.005+0.005i,v=ones(size(nep,1)),neigs=10,maxit=200,tol=1e-14)
λtotal = [λ1;λ2];</code></pre><p>The computed eigenvalues are scaled back to get the eigenvalues of the original problem.</p><pre><code class="language-julia"> julia&gt; λ_orig = sc*λtotal
20-element Array{Complex{Float64},1}:
  0.3765784040323032 + 0.09959915134763689im 
 0.30865495875240445 + 0.008960297181538185im
  0.4087137042139992 + 0.15906877547743775im 
  0.9787481874161135 + 0.0443939782417711im  
  0.3430534698620533 + 0.049837687199345705im
 -0.2863097014631293 - 0.9011417554715162im  
  0.6116671743160434 + 0.14049254864376023im 
 0.40933722321954447 + 0.15820580776369225im 
 0.43950860634751715 + 0.22808195062035772im 
 0.37687009160849716 + 0.09924325053688597im 
 0.47944942696208637 + 0.40059913080096726im 
  0.4934801111510124 + 0.520295324777746im   
   0.496596553706975 + 0.480303769976205im   
 0.49307795048742775 + 0.6085434637464817im  
  0.5095613980300516 + 0.6639488620533516im  
  0.4998069928360967 + 0.3870365082453997im  
  0.4861657916302239 + 0.45751028495939855im 
  0.4766598864386299 + 0.5557787925858408im  
  0.4684227095574837 + 0.4353215518427161im  
  0.5014319544500476 + 0.5889845608687214im  </code></pre><p>This reproduces all the three eigenvalues in Table 7.1 in Schmid-Henningson. We plot the computed eigenvalues.</p><br>
<img src="https://nep-pack.github.io/NonlinearEigenproblems.jl/eigvals.png" height=450><p>This is in agreement with Figure 7.2 from Schmid-Henningson for the eigenvalues in the first quadrant.</p><br>
<img src="https://nep-pack.github.io/NonlinearEigenproblems.jl/henningson.png" height=450><footer><hr/><a class="previous" href="../tutorial_linsolve/"><span class="direction">Previous</span><span class="title">Tutorial 10 (Linear solvers)</span></a></footer></article></body></html>
