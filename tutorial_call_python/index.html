<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 5 (Python) · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../methods/">NEP-Solvers</a></li><li><a class="toctext" href="../types/">NEP Types</a></li><li><a class="toctext" href="../compute_functions/">Compute functions</a></li><li><a class="toctext" href="../linsolvers/">LinSolvers</a></li><li><a class="toctext" href="../innersolvers/">Projection</a></li><li><a class="toctext" href="../errmeasure/">Measuring the error</a></li><li><a class="toctext" href="../logger/">Logger</a></li><li><a class="toctext" href="../transformations/">Transformations</a></li><li><a class="toctext" href="../deflation/">Deflation</a></li><li><a class="toctext" href="../gallery/">Gallery</a></li></ul></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="toctext" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li class="current"><a class="toctext" href>Tutorial 5 (Python)</a><ul class="internal"><li><a class="toctext" href="#A-problem-defined-in-Python-1">A problem defined in Python</a></li><li><a class="toctext" href="#Interfacing-Python-code-1">Interfacing Python code</a></li><li><a class="toctext" href="#Implementation-in-NEP-PACK-(using-Mder_Mlincomb_NEP)-1">Implementation in NEP-PACK (using <code>Mder_Mlincomb_NEP</code>)</a></li><li><a class="toctext" href="#Implementation-in-NEP-PACK-(using-new-type)-1">Implementation in NEP-PACK  (using new type)</a></li></ul></li><li><a class="toctext" href="../tutorial_matlab1/">Tutorial 6 (MATLAB)</a></li><li><a class="toctext" href="../tutorial_fortran1/">Tutorial 7 (FORTRAN)</a></li><li><a class="toctext" href="../tutorial_nano1/">Tutorial 8 (gmsh + nanophotonics)</a></li><li><a class="toctext" href="../tutorial_newmethod/">Tutorial 9 (New solver)</a></li><li><a class="toctext" href="../tutorial_linsolve/">Tutorial 10 (Linear solvers)</a></li><li><a class="toctext" href="../hydrotutorial/">Tutorial 11 (Orr-Somerfeld)</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href>Tutorial 5 (Python)</a></li></ul><a class="edit-page" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/tutorial_call_python.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial 5 (Python)</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial:-Solving-NEP-defined-in-Python-1" href="#Tutorial:-Solving-NEP-defined-in-Python-1">Tutorial: Solving NEP defined in Python</a></h1><h2><a class="nav-anchor" id="A-problem-defined-in-Python-1" href="#A-problem-defined-in-Python-1">A problem defined in Python</a></h2><p>Julia is a great programming language, but your problem may not be easy to define in Julia code, e.g., for legacy reasons. Don&#39;t let that prevent you from using the package. We now show how a problem defined in Python can be solved with NEP-PACK.</p><p>One of the advantages of the Julia language is that it is reasonably easy to interface with code written in other languages. In this tutorial we work with Python, and the two following tutorials we interface <a href="../tutorial_matlab1/">MATLAB</a> and <a href="../tutorial_fortran1/">fortran</a>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>To work with NEPs defined in <a href="https://www.python.org/">Python</a> you need to have Python installed on your computer. With the pakcage <a href="https://github.com/JuliaPy/PyCall.jl">PyCall</a> it is possible to let Julia control execution of Python code.</p></div></div><p>The following python code correspond to the NEP</p><div>\[M(λ)=\begin{bmatrix}1&amp;2\newline3&amp;4\end{bmatrix}+
λ\begin{bmatrix}0&amp;0\newline0&amp;1\end{bmatrix}+
e^λ\begin{bmatrix}1&amp;1\newline1&amp;1\end{bmatrix}\]</div><p>The code has two functions: one that can compute an evaluation of <span>$M(λ)$</span> and one that can form a linear combination of derivatives</p><div>\[  \sum_{i=1}^kM^{(k)}(λ)x_i.\]</div><p>Put a file  <code>mynep.py</code>  in your current directory with the following contents:</p><pre><code class="language-python">import numpy as np;
import cmath as m;
def compute_M(s):
    &quot;&quot;&quot;Compute the matrix M(s) for a given eigenvalue approximation&quot;&quot;&quot;
    A=np.matrix(&#39;1 2; 3 4&#39;);  B=np.matrix(&#39;0 0; 0 1&#39;);   C=np.matrix(&#39;1 1; 1 1&#39;);
    M=A+s*B+m.exp(s)*C
    return M

def compute_Mlincomb(s,X):
    &quot;&quot;&quot;Compute the linear combination of derivatives for value s&quot;&quot;&quot;
    A=np.matrix(&#39;1 2; 3 4&#39;);  B=np.matrix(&#39;0 0; 0 1&#39;);   C=np.matrix(&#39;1 1; 1 1&#39;);

    X=np.matrix(X) # Explicitly convert to matrix
    z=np.zeros((2,1));
    # Zeroth derivative
    z=z+A*X[:,0]
    z=z+B*(s*X[:,0])
    z=z+C*(m.exp(s)*X[:,0])

    # First derivative
    if (np.size(X,1)&gt;1):
        z=z+B*(X[:,1])+C*(m.exp(s)*X[:,1])
    # Higher derivatives
    if (np.size(X,1)&gt;1):
        for k in range(2,np.size(X,1)):
            z=z+C*(m.exp(s)*X[:,k])
    return z</code></pre><h2><a class="nav-anchor" id="Interfacing-Python-code-1" href="#Interfacing-Python-code-1">Interfacing Python code</a></h2><p>We first initiate <code>PyCall</code> as follows. Note that the <code>pushfirst!</code> command is needed, otherwise the module defined in the file <code>mynep.py</code> we gave above will not be found. (<code>PyCall</code> does not include the current directory in the module search path by default.)</p><pre><code class="language-julia">using PyCall;
pushfirst!(PyVector(pyimport(&quot;sys&quot;).&quot;path&quot;), &quot;&quot;);
mynep = pyimport(&quot;mynep&quot;)</code></pre><p>This gives us direct access to the <code>compute_M</code> and <code>compute_Mlincomb</code> functions from python, e.g., if we want to evaluate <span>$M(3+3i)$</span> we run this code</p><pre><code class="language-julia-repl">julia&gt; mynep.compute_M(3+3im)
2×2 Array{Complex{Float64},2}:
 -18.8845+2.83447im  -17.8845+2.83447im
 -16.8845+2.83447im  -12.8845+5.83447im</code></pre><h2><a class="nav-anchor" id="Implementation-in-NEP-PACK-(using-Mder_Mlincomb_NEP)-1" href="#Implementation-in-NEP-PACK-(using-Mder_Mlincomb_NEP)-1">Implementation in NEP-PACK (using <code>Mder_Mlincomb_NEP</code>)</a></h2><p>We can now use the Python interface to define a NEP in Julia. The type <code>Mder_Mlincomb_NEP</code> is a special type made for this situation. The required inputs are the size, called <code>n</code>; a function to compute <span>$M(λ)$</span>, called <code>fder</code>; and a function to compute <span>$\sum_{i=1}^kM^{(k)}(λ)x_i$</span>, called <code>flincomb</code>. The extra <code>0</code> passed in the definition defines that <span>$M(λ)$</span> is available, but no higher derivatives.</p><pre><code class="language-julia">using NonlinearEigenproblems
n=2;
fder = (λ,der) -&gt; mynep.compute_M(complex(λ));
flincomb =  (λ,X) -&gt; mynep.compute_Mlincomb(complex(λ),complex(reshape(X,size(X,1),size(X,2))));
nep=Mder_Mlincomb_NEP(n,fder,0,flincomb);</code></pre><p>We can compare the Python call with the NEP-PACK call</p><pre><code class="language-julia-repl">julia&gt; compute_Mder(nep,3+3im)
2×2 Array{Complex{Float64},2}:
 -18.8845+2.83447im  -17.8845+2.83447im
 -16.8845+2.83447im  -12.8845+5.83447im</code></pre><p>We continue by computing some eigenvalues of the the NEP using the Infinite Arnoldi method (<a href="../methods/#NonlinearEigenproblems.NEPSolver.iar"><code>iar</code></a>).</p><pre><code class="language-julia-repl">julia&gt; (λ,v)=iar(nep,v=[1;1],σ=1,logger=0,neigs=3);
julia&gt; λ
3-element Array{Complex{Float64},1}:
  0.6748316143423988 + 7.336803319821954e-19im
 0.11742590291190791 - 3.649946317867008im    
 0.11742590291191168 + 3.6499463178670144im  </code></pre><p>We can verify that we actually computed solutions as follows:</p><pre><code class="language-julia-repl">julia&gt; norm(compute_Mlincomb(nep,λ[1],v[:,1]))
1.106424240899132e-15</code></pre><h2><a class="nav-anchor" id="Implementation-in-NEP-PACK-(using-new-type)-1" href="#Implementation-in-NEP-PACK-(using-new-type)-1">Implementation in NEP-PACK  (using new type)</a></h2><p>The previous implementation utilizes the convenience type <code>Mder_Mlincomb_NEP</code>, and solves the problem in a satisfactory way. Nevertheless, to illustrate more of the inner workings of NEP-PACK we solve the problem in a second way, by defining our own type. The first thing we need to do is to define the <code>size</code>-function, which is hard-coded in this example.</p><pre><code class="language-julia">import NonlinearEigenproblems.size # We will overload these functions
import NonlinearEigenproblems.compute_Mlincomb;
import NonlinearEigenproblems.compute_Mder;
struct PyNEP &lt;: NEP # Set up a dummy type for our specific NEP
end
size(::PyNEP) = (2,2) # Trivial function definitions
size(::PyNEP,::Int) = 2</code></pre><p>As explained in <a href="../types/">NEPTypes</a>, a NEP is defined by its compute functions. Here is how you define two compute functions that call our python-defined NEP:</p><pre><code class="language-julia">function compute_Mder(::PyNEP,s::Number,der::Integer=0)
    if (der&gt;0)
        error(&quot;Higher derivatives not implemented&quot;);
    end
    return mynep.compute_M(complex(s)); # Call python
end
function compute_Mlincomb(::PyNEP,s::Number,X::AbstractVecOrMat)
    XX=complex(reshape(X,size(X,1),size(X,2))) # Turn into a matrix
    return mynep.compute_Mlincomb(complex(s),XX); # Call python
end</code></pre><p>We now create an object of our newly created type and we can access the NEP with the NEP-PACK specific compute functions:</p><pre><code class="language-julia-repl">julia&gt; pynep=PyNEP();
julia&gt; compute_Mder(pynep,3+3im)
2×2 Array{Complex{Float64},2}:
 -18.8845+2.83447im  -17.8845+2.83447im
 -16.8845+2.83447im  -12.8845+5.83447im</code></pre><p>The behavior is the same as above. Since a NEP-object is defined by its compute functions, we can now use many NEP-solvers to solve this problem. We again use <a href="../methods/#NonlinearEigenproblems.NEPSolver.iar"><code>iar</code></a>:</p><pre><code class="language-julia-repl">julia&gt; (λ2,v2)=iar(pynep,v=[1;1],σ=1,logger=0,neigs=3);
julia&gt; λ2
3-element Array{Complex{Float64},1}:
  0.6748316143423988 + 7.336803319821954e-19im
 0.11742590291190791 - 3.649946317867008im    
 0.11742590291191168 + 3.6499463178670144im   </code></pre><p>We can compare with the eigenvalues computed above and, again, verify that we actually computed solutions as follows:</p><pre><code class="language-julia-repl">julia&gt; norm(compute_Mlincomb(pynep,λ2[1],v2[:,1]))
1.106424240899132e-15</code></pre><p>Residual is almost zero, so we have a solution.</p><p>Note: The above functionality can also be achieved with  <code>Mder_NEP</code> in the development version of NEP-PACK</p><p><img src="http://jarlebring.se/onepixel.png?NEPPACKDOC_PYTHON1" alt="To the top"/></p><footer><hr/><a class="previous" href="../deflate_tutorial/"><span class="direction">Previous</span><span class="title">Tutorial 4 (Deflation)</span></a><a class="next" href="../tutorial_matlab1/"><span class="direction">Next</span><span class="title">Tutorial 6 (MATLAB)</span></a></footer></article></body></html>
