<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="NEP-PACK team">
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>NEP Methods - NEPPACK</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">
  <link href="../assets/Documenter.css" rel="stylesheet">
  
  <script>
    // Current page data
    var mkdocs_page_name = "NEP Methods";
    var mkdocs_page_input_path = "methods.md";
    var mkdocs_page_url = "/methods/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> NEPPACK</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Introduction</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">NEP Methods</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#nep-methods">NEP Methods</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#newton-type-methods">Newton type methods</a></li>
        
            <li><a class="toctree-l3" href="#projection-methods">Projection methods</a></li>
        
            <li><a class="toctree-l3" href="#arnoldi-type-methods">Arnoldi type methods</a></li>
        
            <li><a class="toctree-l3" href="#class-specific-methods">Class specific methods</a></li>
        
        </ul>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../types/">NEP Types</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../transformations/">NEP transformations</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../gallery/">NEP Gallery</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">NEPPACK</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>NEP Methods</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://gitr.sys.kth.se/nep-pack/nep-pack-alpha/"> Edit on Gitr</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p><a id='NEP-Methods-1'></a></p>
<h1 id="nep-methods">NEP Methods</h1>
<p>The NEP solver methods implemented in NEP-pack, are accessed by the functions below. The functions all return $λ,v,w$ where $λ$ is either a number (eigenvalue) a vector of eigenvalues $v$ is either a vector containing an eigenvector or a matrix whose columns corresponding to the eigenvectors.</p>
<p>The first parameter optional parameter in all NEP solver methods is a type. This type specifies which arithmetic should be used for the algorithm.</p>
<p>Example:</p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;)
julia&gt; λ,v=augnewton(Complex128,nep,v=ones(5))
(0.8347353572199425 + 0.0im, Complex{Float64}[0.480386+0.0im, 0.0631636+0.0im, -0.136405+0.0im, 0.214274+0.0im, 0.378581+0.0im])
julia&gt; typeof(λ)
Complex{Float64}
julia&gt; λ,v=augnewton(Float16,nep,v=ones(5))
(Float16(0.8223), Float16[0.47388, 0.063904, -0.13843, 0.21692, 0.38306])
julia&gt; typeof(λ)
Float16
</code></pre>

<p><a id='Newton-type-methods-1'></a></p>
<h2 id="newton-type-methods">Newton type methods</h2>
<p><a id='NEPSolver.newton' href='#NEPSolver.newton'>#</a>
<strong><code>NEPSolver.newton</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>λ,v = newton([eltype],nep::NEP;[errmeasure,][tol,][maxit,][λ,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max])
</code></pre>

<p>Applies Newton-Raphsons method on the system of nonlinear equations with <code>n+1</code> unknowns:</p>
<p>$$
M(λ)v=0
$$</p>
<p>$$
c^Hv-1=0
$$</p>
<p>The kwarg <code>errmeasure</code> is a function handle which can be used to specify how the error is measured to be used in termination (default is absolute residual norm). The iteration is continued until errmeausure is less than <code>tol</code>. <code>λ</code> and <code>v</code> are starting approximations. <code>c</code> is the orthogonalization vector.  If <code>c=0</code> the current approximation will be used for the orthogonalization. <code>armijo_factor</code> specifies if an Armijo rule should be applied, and its value specifies the scaling factor of the step length (per reduction step). The variable <code>armijo_max</code> specifies the maximum number of step length reductions.</p>
<p><strong>Example</strong></p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; λ,v=newton(nep);
julia&gt; minimum(svdvals(compute_Mder(nep,λ)))
1.6066157878930876e-16
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>Nichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.</li>
<li>A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/nep-pack-alpha/blob/e0bca745415575e9ff5e6a813737c1782769fc2f/src/method_newton.jl#L12-L43' class='documenter-source'>source</a><br></p>
<p><a id='NEPSolver.augnewton' href='#NEPSolver.augnewton'>#</a>
<strong><code>NEPSolver.augnewton</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>augnewton([eltype], nep::NEP; [errmeasure,][tol,][maxit,][λ,][v,][c,][displaylevel,][linsolvercreator,][armijo_factor,][armijo_max])
</code></pre>

<p>Run the augmented Newton method. The method is equivalent to <code>newton()</code> in exact arithmetic,  but works only with operations on vectors of length <code>n</code>. The <code>linsolvecreator</code> is used to initiate linear solvers. See <code>newton()</code> for other parameters.</p>
<p><strong>Example</strong></p>
<p>This illustrates the equivalence between <code>newton</code> and <code>augnewton</code>.</p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;dep1&quot;)
julia&gt; λ1,v1=newton(nep,maxit=20,v=ones(size(nep,1)),λ=0)
julia&gt; λ2,v2=augnewton(nep,maxit=20,v=ones(size(nep,1)),λ=0)
julia&gt; λ1-λ2
0.0 + 0.0im
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>Nichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.</li>
<li>A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/nep-pack-alpha/blob/e0bca745415575e9ff5e6a813737c1782769fc2f/src/method_newton.jl#L255-L275' class='documenter-source'>source</a><br></p>
<p><a id='NEPSolver.resinv' href='#NEPSolver.resinv'>#</a>
<strong><code>NEPSolver.resinv</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>λ,v = resinv([eltype],nep::NEP;[errmeasure,][tol,][maxit,][λ,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max,][linsolvecreator])
</code></pre>

<p>Applies residual inverse iteration method for nonlinear eigenvalue problems. The kwarg <code>linsolvecreator</code> is a function which specifies how the linear system is created. The function calls <code>compute_rf</code> for the computation of the Rayleigh functional. See <code>newton()</code> for other parameters.</p>
<p><strong>Example</strong></p>
<p>The example shows how to specify if the method should run in real or complex mode (or any other <code>Number</code> type).</p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; λ,v=resinv(nep,λ=-2,v=ones(size(nep,1)))
julia&gt; typeof(λ)
Complex{Float64}
julia&gt; norm(compute_Mlincomb(nep,λ,v))
1.817030659827106e-14
julia&gt; λ,v=resinv(Float64,nep,λ=-2,v=ones(size(nep,1)))
julia&gt; typeof(λ)
Float64
julia&gt; norm(compute_Mlincomb(nep,λ,v))
1.817030659827106e-14
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>A. Neumaier, Residual inverse iteration for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 22 (1985) 914-923</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/nep-pack-alpha/blob/e0bca745415575e9ff5e6a813737c1782769fc2f/src/method_newton.jl#L121-L151' class='documenter-source'>source</a><br></p>
<p><a id='NEPSolver.quasinewton' href='#NEPSolver.quasinewton'>#</a>
<strong><code>NEPSolver.quasinewton</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>quasinewton([T=Complex128],nep,[errmeasure,][tol,][maxit,][λ,][v][ws][displaylevel][linsolvercreator,][armijo_factor,][armijo_max])
</code></pre>

<p>An implementation of the quasi-Newton approach referred to as quasi-Newton 2 in the reference. The method involves one linear system solve per iteration corresponding with the matrix $M(λ)$, where $λ$ is constant. The vector <code>ws</code> is a representation of the normalization, in the sense that $c^T=w_s^TM(λ)$, where all iterates satisfy $c^Tx_i=1$. See <code>newton()</code> for other parameters.</p>
<p><strong>Example</strong></p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;pep0&quot;)
julia&gt; λ,v=quasinewton(nep,v=ones(size(nep,1)));
julia&gt; norm(compute_Mlincomb(nep,λ,v))/norm(v)
6.301479387102376e-15
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>Jarlebring, Koskela, Mele, Disguised and new Quasi-Newton methods for nonlinear eigenvalue problems, arxiv preprint: https://arxiv.org/abs/1702.08492</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/nep-pack-alpha/blob/e0bca745415575e9ff5e6a813737c1782769fc2f/src/method_newton.jl#L361-L380' class='documenter-source'>source</a><br></p>
<p><a id='NEPSolver.mslp' href='#NEPSolver.mslp'>#</a>
<strong><code>NEPSolver.mslp</code></strong> &mdash; <em>Function</em>.</p>
<pre><code> mslp([eltype],nep::NEP;[errmeasure,][tol,][maxit,][λ,][v,][displaylevel,][eigsolvertype::DataType][armijo_factor=1,][armijo_max])
</code></pre>

<p>Runs the method of successive linear problems. The  method requires the solution of a generalized eigenvalue problem in every iteration. The method used for the eigenvalue computation is specified in eigsolvertype. See <code>newton</code> for other parameters.</p>
<p><strong>Example</strong></p>
<p>Create a rational NEP with SPMFs.</p>
<pre><code class="julia-repl">julia&gt; Av=[ones(3,3),eye(3,3),triu(ones(3,3))];
julia&gt; fv=[S-&gt; S, S -&gt; S^2, S::AbstractArray -&gt; inv(full(S)-eye(S)*10)]
julia&gt; nep=SPMF_NEP(Av,fv)
julia&gt; (λ,v)=mslp(nep)
julia&gt; compute_Mlincomb(nep,λ,v)
3-element Array{Complex{Float64},1}:
 -1.38778e-17+1.65715e-18im
 -5.55112e-17+1.30633e-17im
 -4.16334e-17-1.54436e-17im
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/nep-pack-alpha/blob/e0bca745415575e9ff5e6a813737c1782769fc2f/src/method_mslp.jl#L7-L33' class='documenter-source'>source</a><br></p>
<p><a id='NEPSolver.rfi' href='#NEPSolver.rfi'>#</a>
<strong><code>NEPSolver.rfi</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>rfi(nep,nept,[λ=0,][errmeasure=default_errmeasure,][tol=eps()*100,][maxit=100,][v=randn,][u=randn,][displaylevel=0,][linsolvecreator=default_linsolvecreator,])
</code></pre>

<p>Two-sided Rayleigh functional Iteration, as given as Algorithm 4 in  "Nonlinear Eigenvalue Problems: Newton-type Methods and Nonlinear Rayleigh Functionals", by Kathrin Schreiber.</p>
<p><a target='_blank' href='https://github.com/nep-pack/nep-pack-alpha/blob/e0bca745415575e9ff5e6a813737c1782769fc2f/src/method_rfi.jl#L3-L7' class='documenter-source'>source</a><br></p>
<p><a id='NEPSolver.newtonqr' href='#NEPSolver.newtonqr'>#</a>
<strong><code>NEPSolver.newtonqr</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>Newton-QR method.
</code></pre>

<p><a target='_blank' href='https://github.com/nep-pack/nep-pack-alpha/blob/e0bca745415575e9ff5e6a813737c1782769fc2f/src/method_newton.jl#L464-L466' class='documenter-source'>source</a><br></p>
<p><a id='NEPSolver.implicitdet' href='#NEPSolver.implicitdet'>#</a>
<strong><code>NEPSolver.implicitdet</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>Implicit determinant method
</code></pre>

<p><a target='_blank' href='https://github.com/nep-pack/nep-pack-alpha/blob/e0bca745415575e9ff5e6a813737c1782769fc2f/src/method_newton.jl#L529-L531' class='documenter-source'>source</a><br></p>
<p><a id='Projection-methods-1'></a></p>
<h2 id="projection-methods">Projection methods</h2>
<pre><code>NEPSolver.nlar
</code></pre>

<p><a id='Arnoldi-type-methods-1'></a></p>
<h2 id="arnoldi-type-methods">Arnoldi type methods</h2>
<p><a id='NEPSolver.iar' href='#NEPSolver.iar'>#</a>
<strong><code>NEPSolver.iar</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>iar(nep,[maxit=30,][σ=0,][γ=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])
</code></pre>

<p><strong>Infinite Arnoldi method</strong></p>
<p>Infinite Arnoldi method, as described in Algorithm 2 in  "A linear eigenvalue algorithm for the nonlinear eigenvalue problem", by Jarlebring, Elias and Michiels, Wim and Meerbergen, Karl.</p>
<p><a target='_blank' href='https://github.com/nep-pack/nep-pack-alpha/blob/e0bca745415575e9ff5e6a813737c1782769fc2f/src/method_iar.jl#L5-L10' class='documenter-source'>source</a><br></p>
<p><a id='NEPSolver.tiar' href='#NEPSolver.tiar'>#</a>
<strong><code>NEPSolver.tiar</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>tiar(nep,[maxit=30,][σ=0,][γ=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])
</code></pre>

<p><strong>Tensor Infinite Arnoldi method</strong></p>
<p>Tensor Infinite Arnoldi method, as described in Algorithm 2 in  "The Waveguide Eigenvalue Problem and the Tensor Infinite Arnoldi Method", by Jarlebring, Elias and Mele, Giampaolo and Runborg, Olof.</p>
<p><a target='_blank' href='https://github.com/nep-pack/nep-pack-alpha/blob/e0bca745415575e9ff5e6a813737c1782769fc2f/src/method_tiar.jl#L4-L9' class='documenter-source'>source</a><br></p>
<p><a id='NEPSolver.infbilanczos' href='#NEPSolver.infbilanczos'>#</a>
<strong><code>NEPSolver.infbilanczos</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>λv,V,U=infbilanczos([eltype],nep, nept,[linsolvecreator,][linsolvertcreator,][v,][u,][σ,][γ,][tol,][Neig,][errmeasure,][displaylevel,][maxit,][check_error_every])
</code></pre>

<p>Executes the Infinite Bi-Lanczos method on the problem defined by <code>nep::NEP</code> and <code>nept::NEP</code>. <code>nep:NEP</code> is the original nonlinear eigenvalue problem and <code>nept::NEP</code> is its (hermitian) transpose: $M(lambda^*)^H$.  <code>v</code> and <code>u</code> are starting vectors, <code>σ</code> is the shift and <code>γ</code> the scaling.  See <code>newton()</code> for other parameters.</p>
<p><strong>Example:</strong></p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; A=get_Av(nep); fv=get_fv(nep);
julia&gt; nept=SPMF_NEP([A[1]',A[2]',A[3]'],fv); # Create the transposed NEP
julia&gt; λv,V=infbilanczos(nep,nept,Neig=3)
julia&gt; norm(compute_Mlincomb(nep,λv[1],V[:,1]))
</code></pre>

<p><strong>References:</strong></p>
<ul>
<li>The infinite bi-Lanczos method for nonlinear eigenvalue problems, S. W. Gaaf and E. Jarlebring, arxiv: 1607.03454, to appear in SIAM J. Scientific Computing</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/nep-pack-alpha/blob/e0bca745415575e9ff5e6a813737c1782769fc2f/src/method_infbilanczos.jl#L3-L24' class='documenter-source'>source</a><br></p>
<p><a id='Class-specific-methods-1'></a></p>
<h2 id="class-specific-methods">Class specific methods</h2>
<p><a id='Companion-linearizations-1'></a></p>
<h3 id="companion-linearizations">Companion linearizations</h3>
<p><a id='Rational-?-1'></a></p>
<h3 id="rational">Rational ?</h3>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../types/" class="btn btn-neutral float-right" title="NEP Types">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href=".." class="btn btn-neutral" title="Introduction"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>
    
  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href=".." style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../types/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script src="../js/theme.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="../assets/mathjaxhelper.js"></script>

</body>
</html>
