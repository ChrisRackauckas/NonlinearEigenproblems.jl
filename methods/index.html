<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="NEP-PACK team">
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>NEP Methods - NEP-PACK</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">
  <link href="../assets/Documenter.css" rel="stylesheet">
  
  <script>
    // Current page data
    var mkdocs_page_name = "NEP Methods";
    var mkdocs_page_input_path = "methods.md";
    var mkdocs_page_url = "/methods/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> NEP-PACK</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Introduction</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">NEP Methods</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#nep-methods">NEP Methods</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#newton-type-methods">Newton type methods</a></li>
        
            <li><a class="toctree-l3" href="#projection-methods">Projection methods</a></li>
        
            <li><a class="toctree-l3" href="#arnoldi-and-krylov-based-methods">Arnoldi and Krylov based methods</a></li>
        
            <li><a class="toctree-l3" href="#class-specific-methods">Class specific methods</a></li>
        
        </ul>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../types/">NEP Types</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../linsolvers/">LinSolver</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../transformations/">NEP transformations</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../gallery/">NEP Gallery</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../development/">Developer info</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">NEP-PACK</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>NEP Methods</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/nep-pack/NonlinearEigenproblems.jl/edit/master/docs/methods.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p><a id='NEP-Methods-1'></a></p>
<h1 id="nep-methods">NEP Methods</h1>
<p>The NEP solver methods implemented in NEP-PACK, are accessed by the functions below. The functions all return $λ,v,w$ where $λ$ is either a number (eigenvalue) a vector of eigenvalues $v$ is either a vector containing an eigenvector or a matrix whose columns corresponding to the eigenvectors.</p>
<p>The first parameter optional parameter in all NEP solver methods is a type. This type specifies which arithmetic should be used for the algorithm.</p>
<p>Example:</p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;)
julia&gt; λ,v=augnewton(Complex128,nep,v=ones(5))
(0.8347353572199425 + 0.0im, Complex{Float64}[0.480386+0.0im, 0.0631636+0.0im, -0.136405+0.0im, 0.214274+0.0im, 0.378581+0.0im])
julia&gt; typeof(λ)
Complex{Float64}
julia&gt; λ,v=augnewton(Float16,nep,v=ones(5))
(Float16(0.8223), Float16[0.47388, 0.063904, -0.13843, 0.21692, 0.38306])
julia&gt; typeof(λ)
Float16
</code></pre>

<p><a id='Newton-type-methods-1'></a></p>
<h2 id="newton-type-methods">Newton type methods</h2>
<p><a id='NonlinearEigenproblems.NEPSolver.newton' href='#NonlinearEigenproblems.NEPSolver.newton'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.newton</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>λ,v = newton([eltype],nep::NEP;[errmeasure,][tol,][maxit,][λ,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max])
</code></pre>

<p>Applies Newton-Raphsons method on the system of nonlinear equations with <code>n+1</code> unknowns:</p>
<p>$$
M(λ)v=0
$$</p>
<p>$$
c^Hv-1=0
$$</p>
<p>The kwarg <code>errmeasure</code> is a function handle which can be used to specify how the error is measured to be used in termination (default is absolute residual norm). The iteration is continued until <code>errmeasure</code> is less than <code>tol</code>. <code>λ</code> and <code>v</code> are starting approximations. <code>c</code> is the orthogonalization vector.  If <code>c=0</code> the current approximation will be used for the orthogonalization. <code>armijo_factor</code> specifies if an Armijo rule should be applied, and its value specifies the scaling factor of the step length (per reduction step). The variable <code>armijo_max</code> specifies the maximum number of step length reductions.</p>
<p><strong>Example</strong></p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; λ,v=newton(nep);
julia&gt; minimum(svdvals(compute_Mder(nep,λ)))
1.6066157878930876e-16
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>Nichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.</li>
<li>A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_newton.jl#L17-L48' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.augnewton' href='#NonlinearEigenproblems.NEPSolver.augnewton'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.augnewton</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>augnewton([eltype], nep::NEP; [errmeasure,][tol,][maxit,][λ,][v,][c,][displaylevel,][linsolvercreator,][armijo_factor,][armijo_max])
</code></pre>

<p>Run the augmented Newton method. The method is equivalent to <code>newton()</code> in exact arithmetic,  but works only with operations on vectors of length <code>n</code>. The <code>linsolvecreator</code> is used to initiate linear solvers. See <code>newton()</code> for other parameters.</p>
<p><strong>Example</strong></p>
<p>This illustrates the equivalence between <code>newton</code> and <code>augnewton</code>.</p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;dep1&quot;)
julia&gt; λ1,v1=newton(nep,maxit=20,v=ones(size(nep,1)),λ=0)
julia&gt; λ2,v2=augnewton(nep,maxit=20,v=ones(size(nep,1)),λ=0)
julia&gt; λ1-λ2
0.0 + 0.0im
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>Nichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.</li>
<li>A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_newton.jl#L258-L278' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.resinv' href='#NonlinearEigenproblems.NEPSolver.resinv'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.resinv</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>λ,v = resinv([eltype],nep::NEP;[errmeasure,][tol,][maxit,][λ,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max,][linsolvecreator])
</code></pre>

<p>Applies residual inverse iteration method for nonlinear eigenvalue problems. The kwarg <code>linsolvecreator</code> is a function which specifies how the linear system is created. The function calls <code>compute_rf</code> for the computation of the Rayleigh functional. See <code>newton()</code> for other parameters.</p>
<p><strong>Example</strong></p>
<p>The example shows how to specify if the method should run in real or complex mode (or any other <code>Number</code> type).</p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; λ,v=resinv(nep,λ=-2,v=ones(size(nep,1)))
julia&gt; typeof(λ)
Complex{Float64}
julia&gt; norm(compute_Mlincomb(nep,λ,v))
1.817030659827106e-14
julia&gt; λ,v=resinv(Float64,nep,λ=-2,v=ones(size(nep,1)))
julia&gt; typeof(λ)
Float64
julia&gt; norm(compute_Mlincomb(nep,λ,v))
1.817030659827106e-14
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>A. Neumaier, Residual inverse iteration for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 22 (1985) 914-923</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_newton.jl#L125-L155' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.quasinewton' href='#NonlinearEigenproblems.NEPSolver.quasinewton'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.quasinewton</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>quasinewton([T=ComplexF64],nep,[errmeasure,][tol,][maxit,][λ,][v][ws][displaylevel][linsolvercreator,][armijo_factor,][armijo_max])
</code></pre>

<p>An implementation of the quasi-Newton approach referred to as quasi-Newton 2 in the reference. The method involves one linear system solve per iteration corresponding with the matrix $M(λ)$, where $λ$ is constant. The vector <code>ws</code> is a representation of the normalization, in the sense that $c^T=w_s^TM(λ)$, where all iterates satisfy $c^Tx_i=1$. See <code>newton()</code> for other parameters.</p>
<p><strong>Example</strong></p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;pep0&quot;)
julia&gt; λ,v=quasinewton(nep,v=ones(size(nep,1)));
julia&gt; norm(compute_Mlincomb(nep,λ,v))/norm(v)
6.301479387102376e-15
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>Jarlebring, Koskela, Mele, Disguised and new Quasi-Newton methods for nonlinear eigenvalue problems, Numer. Algorithms, 79:311-335, 2018. <a href="https://arxiv.org/abs/1702.08492">preprint</a></li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_newton.jl#L364-L383' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.mslp' href='#NonlinearEigenproblems.NEPSolver.mslp'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.mslp</code></strong> &mdash; <em>Function</em>.</p>
<pre><code> mslp([eltype],nep::NEP;[errmeasure,][tol,][maxit,][λ,][v,][displaylevel,][eigsolvertype::DataType][armijo_factor=1,][armijo_max])
</code></pre>

<p>Runs the method of successive linear problems. The  method requires the solution of a generalized eigenvalue problem in every iteration. The method used for the eigenvalue computation is specified in eigsolvertype. See <code>newton</code> for other parameters.</p>
<p><strong>Example</strong></p>
<p>Create a rational NEP with SPMFs.</p>
<pre><code class="julia-repl">julia&gt; Av=[ones(3,3),eye(3,3),triu(ones(3,3))];
julia&gt; fv=[S-&gt; S, S -&gt; S^2, S::AbstractArray -&gt; inv(Matrix(S)-eye(S)*10)]
julia&gt; nep=SPMF_NEP(Av,fv)
julia&gt; (λ,v)=mslp(nep)
julia&gt; compute_Mlincomb(nep,λ,v)
3-element Array{Complex{Float64},1}:
 -1.38778e-17+1.65715e-18im
 -5.55112e-17+1.30633e-17im
 -4.16334e-17-1.54436e-17im
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_mslp.jl#L7-L33' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.rfi' href='#NonlinearEigenproblems.NEPSolver.rfi'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.rfi</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>rfi(nep,nept,[λ=0,][errmeasure=default_errmeasure,][tol=eps()*100,][maxit=100,][v=randn,][u=randn,][displaylevel=0,][linsolvecreator=default_linsolvecreator,])
</code></pre>

<p>This is an implementation of the two-sided Rayleigh functional Iteration (RFI) to compute an eigentriplet of the problem specified by <code>nep</code>. This method requires the transpose of the NEP, specified in <code>nept</code>. <code>λ</code>, <code>u</code> and <code>v</code> are initial guesses for the eigenvalue, the right eigenvector and the left eigenvector respectively. A <code>NoConvergenceException</code> is thrown if an eigentriplet is not found in <code>maxit</code> iterations.</p>
<p><strong>Example</strong></p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; nept=DEP([nep.A[1]',nep.A[2]'])
julia&gt; λ,v,u=rfi_b(nep,nept)
julia&gt; compute_resnorm(nep,λ,v) % v is a right eigenvector
4.347204570675246e-16
julia&gt; compute_resnorm(nept,λ,u) % u is a left eigenvector
7.173081573164097e-16
</code></pre>

<p><strong>Reference</strong></p>
<ul>
<li>Algorithm 4 in  Schreiber, Nonlinear Eigenvalue Problems: Newton-type Methods and Nonlinear Rayleigh Functionals, PhD thesis, TU Berlin, 2008.</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_rfi.jl#L7-L28' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.blocknewton' href='#NonlinearEigenproblems.NEPSolver.blocknewton'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.blocknewton</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>(S,X)=blocknewton(nep [S,] [X,] [errmeasure,] [tol,] [maxit,] [armijo_factor,] [armijo_max,] [displaylevel])
</code></pre>

<p>Applies the block Newton method to <code>nep::AbstractSPMF</code>. The method computes an invariant pair <code>(S,X)</code> using the block Newton approach of Kressner. The variables <code>S</code>,<code>X</code> correspond to starting approximations. The function <code>errmeasure</code> shoule be defined for errmeasure(S,X) and meausures the error in the pair <code>(S,X)</code>. See <code>newton()</code> for the other parameters.</p>
<p><strong>Example</strong></p>
<p>The example shows that <code>compute_MM()</code> becomes zero when a solution has been computed.</p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;,3);
julia&gt; (S,X)= blocknewton(nep)
julia&gt; compute_MM(nep,S,X)
3×2 Array{Complex{Float64},2}:
 -2.22045e-16-1.0842e-19im  -2.08167e-17+0.0im
  1.94289e-16-1.0842e-19im  -5.55112e-17-6.77626e-20im
  7.63278e-17-1.0842e-19im   2.77556e-17-2.71051e-20im
</code></pre>

<p>This example solves the <code>gun</code> problem from the Berlin-Manchester collection</p>
<pre><code class="julia-repl">julia&gt; using NonlinearEigenproblems.Gallery
julia&gt; nep=nep_gallery(&quot;nlevp_native_gun&quot;);
julia&gt; II=[1.0 0; 0 1]; S=150^2*II; V=[II;zeros(size(nep,1)-2,2)];
julia&gt; (Z,X)=blocknewton(nep,S=S,X=V,displaylevel=1,armijo_factor=0.5,maxit=20)
Iteration 1: Error: 6.081316e+03
Iteration 2: Error: 1.701970e-02 Armijo scaling=0.031250
Iteration 3: Error: 1.814887e-02 Armijo scaling=0.250000
...
Iteration 13: Error: 6.257442e-09
Iteration 14: Error: 2.525942e-15
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>D. Kressner A block Newton method for nonlinear eigenvalue problems, Numer. Math., 114 (2) (2009), pp. 355-372</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_blocknewton.jl#L7-L46' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.newtonqr' href='#NonlinearEigenproblems.NEPSolver.newtonqr'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.newtonqr</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>λ,v = newtonqr([eltype],nep::NEP;[errmeasure,][tol,][maxit,][λ,][v,][c,][displaylevel])
</code></pre>

<p>This function implements the Newton-QR method as formulated in the reference. The method ivolves the computation of a rank-revealing QR factorization of $M(λ)$, with the idea that on convergence the the last diagonal element $R[n,n]$ of the upper-triangular matrix $R$ becomes zero as a result of $M(λ)$ becoming singular. Since the computation of a QR factorization is expensive, it is advisable to use this method for problems of small size or problems with a certain structure that makes the QR computation less expensive. See <a href="./#NonlinearEigenproblems.NEPSolver.newton"><code>newton</code></a> for description of the function arguements.</p>
<p><strong>Example</strong></p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;pep0&quot;)
julia&gt; λ,v=newtonqr(nep,v=ones(size(nep,1)));
julia&gt; norm(compute_Mlincomb(nep,λ,v))/norm(v)
1.0442559980785471e-14
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>Kublanovskaya, V. N., (1970).  On an approach to the solution of the generalized latent value problem for λ-matrices, SIAM J. Numer. Anal. 7, 532–537</li>
<li>Güttel, S., &amp; Tisseur, F. (2017). The nonlinear eigenvalue problem. Acta Numerica, 26, 1-94. doi:10.1017/S0962492917000034</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_newton.jl#L470-L489' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.implicitdet' href='#NonlinearEigenproblems.NEPSolver.implicitdet'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.implicitdet</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>λ,v = implicitdet([eltype],nep::NEP;[errmeasure,][tol,][maxit,][λ,][v,][c,][displaylevel])
</code></pre>

<p>This function implements the Implicit determinant method as formulated Algorithm 4.3 in the reference. The method applies Newton-Raphson to the equation $det(M(λ))/det(G(λ)) = 0$, where $G(λ)$ is a saddle point matrix with $M(λ)$ in the (1,1) block. The (2,1) and (1,2) blocks of $G(λ)$ are set to $c^H$ and $c$ respectively. Note that $G(λ)$ can be non-singular even when $M(λ)$ is singular. See reference for more information. See <a href="./#NonlinearEigenproblems.NEPSolver.newton"><code>newton</code></a> for description of the function arguements.</p>
<p><strong>Example</strong></p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;pep0&quot;)
julia&gt; λ,v=implicitdet(nep,v=ones(size(nep,1)));
julia&gt; norm(compute_Mlincomb(nep,λ,v))/norm(v)
3.75723275262885e-14
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>Spence, A., &amp; Poulton, C. (2005). Photonic band structure calculations using nonlinear eigenvalue techniques, J. Comput. Phys., 204 (2005), pp. 65–8</li>
<li>Güttel, S., &amp; Tisseur, F. (2017). The nonlinear eigenvalue problem. Acta Numerica, 26, 1-94. doi:10.1017/S0962492917000034</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_newton.jl#L556-L576' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.broyden' href='#NonlinearEigenproblems.NEPSolver.broyden'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.broyden</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>S,V = broyden([eltype,]nep::NEP[,approxnep::NEP];kwargs)
</code></pre>

<p>Runs Broydens method (with deflation) for the nonlinear eigenvalue problem defined by nep. An approximate nep can be provided which is used as an initialization of starting matrix/vectors.</p>
<p>The method computes an invariant pair and can therefore find several eigenvalues. The retured value is (S,V) is an invariant pair and the eigenvalues are on the diagonal of S.</p>
<p><strong>Example</strong></p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; S,V=broyden(nep);
julia&gt; λ=S[1,1]
-0.3587189459686267 - 3.0010731412746105e-31im
julia&gt; minimum(svdvals(compute_Mder(nep,λ)))
1.6066157878930856e-16
julia&gt; λ=S[2,2]
-0.04093521177097334 + 1.486011530941621im
julia&gt; minimum(svdvals(compute_Mder(nep,λ)))
4.159109513753696e-16
julia&gt; λ=S[3,3]
0.8347353572199486 + 1.5032076225139986e-14im
julia&gt; minimum(svdvals(compute_Mder(nep,λ)))
1.296144276122994e-14
julia&gt; broyden(nep,displaylevel=2,check_error_every=1);  % Prints out a lot more convergence info
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>Jarlebring, Broyden’s method for nonlinear eigenproblems, 2018, https://arxiv.org/pdf/1802.07322</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_broyden.jl#L520-L554' class='documenter-source'>source</a><br></p>
<p><a id='Projection-methods-1'></a></p>
<h2 id="projection-methods">Projection methods</h2>
<p><a id='NonlinearEigenproblems.NEPSolver.nlar' href='#NonlinearEigenproblems.NEPSolver.nlar'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.nlar</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>function nlar([eltype],nep::ProjectableNEP,[orthmethod=ModifiedGramSchmidt],[neigs=10],[errmeasure=default_errmeasure],[tol=eps(real(T))*100],[maxit=100],[λ0=0],[v0=randn(T,size(nep,1))],[displaylevel=0],[linsolvercreator=default_linsolvercreator],[R=0.01],[eigval_sorter=residual_eigval_sorter],[qrfact_orth=false],[max_subspace=100],[num_restart_ritz_vecs=8],[inner_solver_method=DefaultInnerSolver])
</code></pre>

<p>The function implements the Nonlinear Arnoldi method, which finds <code>neigs</code> eigenpairs(or throws a <code>NoConvergenceException</code>) by projecting the problem to a subspace that is expanded in the course  of the algorithm. The basis is orthogonalized either by using the QR method if <code>qrfact_orth</code> is <code>true</code> or else by an orthogonalization method <code>orthmethod</code>). This entails solving a smaller projected problem using a method specified by <code>inner_solver_method</code>. (<code>λ0</code>,<code>v0</code>) is the initial guess for the eigenpair. <code>linsolvercreator</code> specifies how the linear system is created and solved. <code>R</code> is a parameter used by the function specified by <code>eigval_sorter</code> to reject those ritz values that are within a distance <code>R</code> from any of the converged eigenvalues, so that repeated convergence to the same eigenpair can be avoided. <code>max_subspace</code> is the maximum allowable size of the basis befor the algorithm restarts using a basis made of <code>num_restart_ritz_vecs</code> ritz vectors and the eigenvectors that the algorithm has converged to.</p>
<p><strong>Example</strong></p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;dep0_tridiag&quot;);
julia&gt; λ,v=nlar(nep,tol=1e-5,neigs=1,maxit=50);
julia&gt; norm(compute_Mlincomb(nep,λ[1],v))
7.722757003764154e-7
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>H. Voss, An Arnoldi method for nonlinear eigenvalue problems. BIT. Numer. Math. 44: 387-401, 2004.</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_nlar.jl#L12-L33' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.jd_betcke' href='#NonlinearEigenproblems.NEPSolver.jd_betcke'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.jd_betcke</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>jd_betcke([eltype]], nep::ProjectableNEP; [Neig=1], [tol=eps(real(T))*100], [maxit=100], [λ=zero(T)], [orthmethod=DGKS],  [errmeasure=default_errmeasure], [linsolvercreator=default_linsolvercreator], [v = randn(size(nep,1))], [displaylevel=0], [inner_solver_method=DefaultInnerSolver], [projtype=:PetrovGalerkin], [target=zero(T)])
</code></pre>

<p>The function computes eigenvalues using Jacobi-Davidson method, which is a projection method. The projected problems are solved using a solver spcified through the type <code>inner_solver_method</code>. For numerical stability the basis is kept orthogonal, and the method for orthogonalization is specified by <code>orthmethod</code>, see the package <code>IterativeSolvers.jl</code>. The function tries to compute <code>Neig</code> number of eigenvalues, and throws a <code>NoConvergenceException</code> if it cannot. The value <code>λ</code> and the vector <code>v</code> are initial guesses for an eigenpair. <code>linsolvercreator</code> is a function which specifies how the linear system is created and solved. The <code>target</code> is the center around which eiganvlues are computed. <code>errmeasure</code> is a function handle which can be used to specify how the error is measured. By default the method uses a Petrov-Galerkin framework, with a trial (left) and test (right) space, hence $W^H T(λ) V$ is the projection considered. By specifying  <code>projtype</code> to be <code>:Galerkin</code> then <code>W=V</code>.</p>
<p><strong>Example</strong></p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;,50);
julia&gt; λ,v=jd_betcke(nep,tol=1e-5,maxit=20);
julia&gt; norm(compute_Mlincomb(nep,λ[1],v[:,1]))
1.2277391762692744e-8
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>T. Betcke and H. Voss, A Jacobi-Davidson-type projection method for nonlinear eigenvalue problems. Future Gener. Comput. Syst. 20, 3 (2004), pp. 363-372.</li>
<li>H. Voss, A Jacobi–Davidson method for nonlinear eigenproblems. In: International Conference on Computational Science. Springer, Berlin, Heidelberg, 2004. pp. 34-41.</li>
</ul>
<p>See also</p>
<ul>
<li>C. Effenberger, Robust successive computation of eigenpairs for nonlinear eigenvalue problems. SIAM J. Matrix Anal. Appl. 34, 3 (2013), pp. 1231-1256.</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_jd.jl#L27-L52' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.jd_effenberger' href='#NonlinearEigenproblems.NEPSolver.jd_effenberger'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.jd_effenberger</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>jd_effenberger([eltype]], nep::ProjectableNEP; [maxit=100], [Neig=1], [inner_solver_method=DefaultInnerSolver], [orthmethod=DGKS], [linsolvercreator=default_linsolvercreator], [tol=eps(real(T))*100], [λ=zero(T)], [v = rand(T,size(nep,1))], [target=zero(T)],  [displaylevel=0])
</code></pre>

<p>The function computes eigenvalues using the Jacobi-Davidson method, which is a projection method. Repreated eigenvalues are avoided by using deflation, as presented in the reference by Effenberger. The projected problems are solved using a solver spcified through the type <code>inner_solver_method</code>. For numerical stability the basis is kept orthogonal, and the method for orthogonalization is specified by <code>orthmethod</code>, see the package <code>IterativeSolvers.jl</code>. The function tries to compute <code>Neig</code> number of eigenvalues, and throws a <code>NoConvergenceException</code> if it cannot. The value <code>λ</code> and the vector <code>v</code> are initial guesses for an eigenpair. <code>linsolvercreator</code> is a function which specifies how the linear system is created and solved. The <code>target</code> is the center around which eiganvalues are computed.</p>
<p><strong>Example</strong></p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;,100);
julia&gt; λ,v=jd_effenberger(nep,maxit=30,v=ones(size(nep,1)),λ=0);
julia&gt; norm(compute_Mlincomb(nep,λ[1],v[:,1]))
1.902783771915309e-14
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>C. Effenberger, Robust successive computation of eigenpairs for nonlinear eigenvalue problems. SIAM J. Matrix Anal. Appl. 34, 3 (2013), pp. 1231-1256.</li>
</ul>
<p>See also</p>
<ul>
<li>T. Betcke and H. Voss, A Jacobi-Davidson-type projection method for nonlinear eigenvalue problems. Future Gener. Comput. Syst. 20, 3 (2004), pp. 363-372.</li>
<li>H. Voss, A Jacobi–Davidson method for nonlinear eigenproblems. In: International Conference on Computational Science. Springer, Berlin, Heidelberg, 2004. pp. 34-41.</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_jd.jl#L181-L204' class='documenter-source'>source</a><br></p>
<p><a id='Arnoldi-and-Krylov-based-methods-1'></a></p>
<h2 id="arnoldi-and-krylov-based-methods">Arnoldi and Krylov based methods</h2>
<p><a id='IAR-1'></a></p>
<h3 id="iar">IAR</h3>
<p>The Infinite ARnoldi method.</p>
<p><a id='NonlinearEigenproblems.NEPSolver.iar' href='#NonlinearEigenproblems.NEPSolver.iar'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.iar</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>iar(nep,[maxit=30,][σ=0,][γ=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])
</code></pre>

<p>Run the infinite Arnoldi method on the nonlinear eigenvalue problem stored in <code>nep</code>.</p>
<p>The target <code>σ</code> is the center around which eiganvalues are computed. The kwarg <code>errmeasure</code> is a function handle which can be used to specify how the error is measured to be used in termination (default is absolute residual norm). A Ritz pair <code>λ</code> and <code>v</code> is flagged a as converged (to an eigenpair) if <code>errmeasure</code> is less than <code>tol</code>. The vector <code>v</code> is the starting vector for constructing the Krylov space. The orthogonalization method, used in contructing the orthogonal basis of the Krylov space, is specified by <code>orthmethod</code>, see the package <code>IterativeSolvers.jl</code>. The iteration is continued until <code>Neig</code> Ritz pairs converge. This function throws a <code>NoConvergenceException</code> if the wanted eigenpairs are not computed after <code>maxit</code> iterations. The <code>linsolvercreator</code> is a function which specifies how the linear system is created and solved.</p>
<p><strong>Example</strong></p>
<pre><code class="julia-repl">julia&gt; using NonlinearEigenproblems, LinearAlgebra
julia&gt; nep=nep_gallery(&quot;dep0&quot;,100);
julia&gt; v0=ones(size(nep,1));
julia&gt; λ,v=iar(nep;v=v0,tol=1e-5,Neig=3);
julia&gt; norm(compute_Mlincomb!(nep,λ[1],v[:,1])) # Is it an eigenvalue?
julia&gt; λ    # print the computed eigenvalues
3-element Array{Complex{Float64},1}:
 -0.15606211475666945 - 0.12273439802763578im
 -0.15606211475666862 + 0.12273439802763489im
  0.23169243065648365 - 9.464790582509696e-17im
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>Algorithm 2 in Jarlebring, Michiels Meerbergen, A linear eigenvalue algorithm for the nonlinear eigenvalue problem, Numer. Math, 2012</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_iar.jl#L8-L34' class='documenter-source'>source</a><br></p>
<p><a id='IAR-Chebyshev-1'></a></p>
<h3 id="iar-chebyshev">IAR Chebyshev</h3>
<p>A Chebyshev version of the IAR method.</p>
<p><a id='NonlinearEigenproblems.NEPSolver.iar_chebyshev' href='#NonlinearEigenproblems.NEPSolver.iar_chebyshev'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.iar_chebyshev</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>iar_chebyshev(nep,[maxit=30,][σ=0,][γ=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS][a=-1,][b=1,][compute_y0_method=ComputeY0ChebAuto])
</code></pre>

<p>Run the infinite Arnoldi method (Chebyshev version) on the nonlinear eigenvalue problem stored in <code>nep</code>.</p>
<p>The target <code>σ</code> is the center around which eiganvalues are computed. The kwarg <code>errmeasure</code> is a function handle which can be used to specify how the error is measured to be used in termination (default is absolute residual norm). A Ritz pair <code>λ</code> and <code>v</code> is flagged a as converged (to an eigenpair) if <code>errmeasure</code> is less than <code>tol</code>. The vector <code>v</code> is the starting vector for constructing the Krylov space. The orthogonalization method, used in contructing the orthogonal basis of the Krylov space, is specified by <code>orthmethod</code>, see the package <code>IterativeSolvers.jl</code>. The iteration is continued until <code>Neig</code> Ritz pairs converge. This function throws a <code>NoConvergenceException</code> if the wanted eigenpairs are not computed after <code>maxit</code> iterations. The <code>linsolvercreator</code> is a function which specifies how the linear system is created and solved. The kwarg <code>compute_y0_method</code> specifying how the next vector of the Krylov space (in Chebyshev format) can be computed. See <a href="./#NonlinearEigenproblems.NEPSolver.compute_y0_cheb"><code>compute_y0_cheb</code></a> in the module NEPSolver with the command <code>?NEPSolver.compute_y0_cheb</code>.</p>
<p><strong>Example</strong></p>
<pre><code class="julia-repl">julia&gt; using NonlinearEigenproblems, LinearAlgebra
julia&gt; nep=nep_gallery(&quot;dep0&quot;,100);
julia&gt; v0=ones(size(nep,1));
julia&gt; λ,v=iar_chebyshev(nep;v=v0,tol=1e-5,Neig=3);
julia&gt; norm(compute_Mlincomb!(nep,λ[1],v[:,1])) # Is it an eigenvalue?
julia&gt; λ    # print the computed eigenvalues
3-element Array{Complex{Float64},1}:
  -0.1560621117389876 - 0.12273439561483537im
 -0.15606211173898707 + 0.12273439561483517im
  0.23169252042880578 - 7.86196165647416e-17im
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>Algorithm 2 in Jarlebring, Michiels Meerbergen, A linear eigenvalue algorithm for the nonlinear eigenvalue problem, Numer. Math, 2012</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_iar_chebyshev.jl#L33-L59' class='documenter-source'>source</a><br></p>
<p>For the <code>iar_chebyshev</code> the following <code>compute_y0_cheb</code> method is needed, in order to avoid explicit conversions between the Chebyshev basis and the monimial basis.</p>
<p><a id='NonlinearEigenproblems.NEPSolver.compute_y0_cheb' href='#NonlinearEigenproblems.NEPSolver.compute_y0_cheb'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.compute_y0_cheb</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>y0 = compute_y0_cheb([eltype],nep::NEPTypes.DEP,::Type{ComputeY0ChebPEP},X,Y,M0inv,precomp::AbstractPrecomputeData)
</code></pre>

<p>Computes the vector y0 used in <a href="./#NonlinearEigenproblems.NEPSolver.iar_chebyshev"><code>iar_chebyshev</code></a> given by</p>
<p>$$
 y_0 = \sum_{i=1}^N T_{i-1}(γ) x_i - \sum_{j=1}^m A_j \left( \sum_{i=1}^{N+1} T_{i-1}(-ρ \tau_j+γ) y_i \right )
$$</p>
<p>where T(c) is the vector containing $T_i(c)$ as coefficients, where $T_i$ is the i-th Chebyshev polynomial of the first kind.</p>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_iar_chebyshev.jl#L276-L284' class='documenter-source'>source</a><br></p>
<pre><code>y0 = compute_y0_cheb([eltype],nep::NEPTypes.PEP,::Type{ComputeY0ChebPEP},X,Y,M0inv,precomp::AbstractPrecomputeData)
</code></pre>

<p>Computes the vector y0 used in <a href="./#NonlinearEigenproblems.NEPSolver.iar_chebyshev"><code>iar_chebyshev</code></a> given by</p>
<p>$$
 y_0 = \sum_{j=0}^{d-1} A_{j+1} x D^j T(c) - y T(c)
$$</p>
<p>where T(c) is the vector containing $T_i(c)$ as coefficients, where $T_i$ is the i-th Chebyshev polynomial of the first kind and $D$ is the derivation matrix in Chebyshev basis.</p>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_iar_chebyshev.jl#L298-L306' class='documenter-source'>source</a><br></p>
<pre><code>y0 = compute_y0_cheb([eltype],nep::NEPTypes.SPMF_NEP,::Type{ComputeY0ChebPEP},X,Y,M0inv,precomp::AbstractPrecomputeData)
</code></pre>

<p>Computes the vector y0 used in <a href="./#NonlinearEigenproblems.NEPSolver.iar_chebyshev"><code>iar_chebyshev</code></a> given by</p>
<p>$$
 y_0= \sum_{j=0}^{m} M^{(j)}(\mu) X b_j \left( D_N \right) T_N(c) - Y T_N(c)
$$</p>
<p>where T(c) is the vector containing $T_i(c)$ as coefficients, where $T_i$ is the i-th Chebyshev polynomial of the first kind and $b_j(\lambda)=(f_j(0)-f_j(\lambda))/\lambda=f[\lambda,0]$ are divided differences.</p>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_iar_chebyshev.jl#L322-L330' class='documenter-source'>source</a><br></p>
<pre><code>y0 = compute_y0_cheb([eltype],nep::NEPTypes.NEP,::Type{ComputeY0ChebNEP},X,Y,M0inv,precomp::AbstractPrecomputeData)
</code></pre>

<p>Computes the vector y0 used in <a href="./#NonlinearEigenproblems.NEPSolver.iar_chebyshev"><code>iar_chebyshev</code></a> defined as</p>
<p>$$
 y_0 =\left( \sum_{i=0}^{N-1} B \left( \frac{d}{d \theta} \right) \hat T_i(\theta) x_i \right)(0) - \sum_{i=0}^{N} T_i(c) y_i
$$</p>
<p>where $T_i$ is the i-th Chebyshev polynomial of the first kind, $ \ hat T_i$ is the i-th Chebyshev polynomial of the first kind for the interval [a,b]. For a generic <code>nep</code>, this quantity is computed by converting polynomials in monomial basis. This procedure may be numerical unstable if many iterations are required. If for the specific <code>nep</code> a closed formula is available, we suggest to overload this function.</p>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_iar_chebyshev.jl#L344-L352' class='documenter-source'>source</a><br></p>
<p><a id='TIAR-1'></a></p>
<h3 id="tiar">TIAR</h3>
<p>The Tensor Infinite ARnoldi method.</p>
<p><a id='NonlinearEigenproblems.NEPSolver.tiar' href='#NonlinearEigenproblems.NEPSolver.tiar'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.tiar</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>tiar(nep,[maxit=30,][σ=0,][γ=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])
</code></pre>

<p>Run the tensor infinite Arnoldi method on the nonlinear eigenvalue problem stored in <code>nep</code>.</p>
<p>The target <code>σ</code> is the center around which eiganvalues are computed. The kwarg <code>errmeasure</code> is a function handle which can be used to specify how the error is measured to be used in termination (default is absolute residual norm). A Ritz pair <code>λ</code> and <code>v</code> is flagged a as converged (to an eigenpair) if <code>errmeasure</code> is less than <code>tol</code>. The vector <code>v</code> is the starting vector for constructing the Krylov space. The orthogonalization method, used in contructing the orthogonal basis of the Krylov space, is specified by <code>orthmethod</code>, see the package <code>IterativeSolvers.jl</code>. The iteration is continued until <code>Neig</code> Ritz pairs converge. This function throws a <code>NoConvergenceException</code> if the wanted eigenpairs are not computed after <code>maxit</code> iterations. The <code>linsolvercreator</code> is a function which specifies how the linear system is created and solved.</p>
<p><strong>Example</strong></p>
<pre><code class="julia-repl">julia&gt; using NonlinearEigenproblems, LinearAlgebra
julia&gt; nep=nep_gallery(&quot;dep0&quot;,100);
julia&gt; v0=ones(size(nep,1));
julia&gt; λ,v=tiar(nep;v=v0,tol=1e-5,Neig=3);
julia&gt; norm(compute_Mlincomb!(nep,λ[1],v[:,1])) # Is it an eigenvalue?
julia&gt; λ    # print the computed eigenvalues
3-element Array{Complex{Float64},1}:
 -0.1560621147566685 + 0.12273439802763504im
 -0.1560621147566693 - 0.1227343980276357im
 0.23169243065648332 - 4.699260229885766e-17im

</code></pre>

<p><strong>References</strong></p>
<ul>
<li>Algorithm 2 in Jarlebring, Mele, Runborg, The Waveguide Eigenvalue Problem and the Tensor Infinite Arnoldi Method, SIAM J. Scient. computing, 39 (3), A1062-A1088, 2017</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_tiar.jl#L7-L34' class='documenter-source'>source</a><br></p>
<p><a id='Infbilanczos-1'></a></p>
<h3 id="infbilanczos">Infbilanczos</h3>
<p>The Infinite Bi-Lanczos method.</p>
<p><a id='NonlinearEigenproblems.NEPSolver.infbilanczos' href='#NonlinearEigenproblems.NEPSolver.infbilanczos'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.infbilanczos</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>λv,V,U=infbilanczos([eltype],nep, nept,[linsolvecreator,][linsolvertcreator,][v,][u,][σ,][γ,][tol,][Neig,][errmeasure,][displaylevel,][maxit,][check_error_every])
</code></pre>

<p>Executes the Infinite Bi-Lanczos method on the problem defined by <code>nep::NEP</code> and <code>nept::NEP</code>. <code>nep:NEP</code> is the original nonlinear eigenvalue problem and <code>nept::NEP</code> is its (hermitian) transpose: $M(λ^*)^H$.  <code>v</code> and <code>u</code> are starting vectors, <code>σ</code> is the shift and <code>γ</code> the scaling.  See <code>newton()</code> for other parameters.</p>
<p><strong>Example:</strong></p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; A=get_Av(nep); fv=get_fv(nep);
julia&gt; At=[copy(A[1]'),copy(A[2]'),copy(A[3]')]
julia&gt; nept=SPMF_NEP(At,fv); # Create the transposed NEP
julia&gt; λv,V=infbilanczos(nep,nept,Neig=3)
julia&gt; norm(compute_Mlincomb(nep,λv[1],V[:,1]))
</code></pre>

<p><strong>References:</strong></p>
<ul>
<li>The infinite bi-Lanczos method for nonlinear eigenvalue problems, S. W. Gaaf and E. Jarlebring, SIAM J. Sci. Comput. 39:S898-S919, 2017, <a href="https://arxiv.org/abs/1607.03454">preprint</a></li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_infbilanczos.jl#L5-L26' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.nleigs' href='#NonlinearEigenproblems.NEPSolver.nleigs'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.nleigs</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>nleigs(nep::NEP, Σ::AbstractVector{Complex{T}})
</code></pre>

<p>Find a few eigenvalues and eigenvectors of a nonlinear eigenvalue problem.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>nep</code>: An instance of a nonlinear eigenvalue problem.</li>
<li><code>Σ</code>: A vector containing the points of a polygonal target set in the complex plane.</li>
<li><code>Ξ</code>: A vector containing a discretization of the singularity set.</li>
<li><code>displaylevel</code>: Level of display (0, 1, 2).</li>
<li><code>maxdgr</code>: Max degree of approximation.</li>
<li><code>minit</code>: Min number of iterations after linearization is converged.</li>
<li><code>maxit</code>: Max number of total iterations.</li>
<li><code>tol</code>: Tolerance for residual.</li>
<li><code>tollin</code>: Tolerance for convergence of linearization.</li>
<li><code>v</code>: Starting vector.</li>
<li><code>errmeasure</code>: Function for error measure (residual norm). Called with arguments (λ,v).</li>
<li><code>isfunm</code> : Whether to use matrix functions.</li>
<li><code>static</code>: Whether to use static version of NLEIGS.</li>
<li><code>leja</code>: Use of Leja-Bagby points (0 = no, 1 = only in expansion phase, 2 = always).</li>
<li><code>nodes</code>: Prefixed interpolation nodes (only when leja is 0 or 1).</li>
<li><code>reusefact</code>: Reuse of matrix factorizations (0 = no, 1 = only after converged linearization, 2 = always).</li>
<li><code>blksize</code>: Block size for pre-allocation.</li>
<li><code>return_details</code>: Whether to return solution details (see NleigsSolutionDetails).</li>
<li><code>check_error_every</code>: Check for convergence / termination every this number of iterations.</li>
</ul>
<p><strong>Return values</strong></p>
<ul>
<li><code>λ</code>: Vector of eigenvalues of the nonlinear eigenvalue problem NLEP inside the target set Σ.</li>
<li><code>X</code>: Corresponding matrix of eigenvectors.</li>
<li><code>res</code>: Corresponding residuals.</li>
<li><code>details</code>: Solution details, if requested (see NleigsSolutionDetails).</li>
</ul>
<p><strong>References</strong></p>
<ul>
<li>S. Guettel, R. Van Beeumen, K. Meerbergen, and W. Michiels. NLEIGS: A class of fully rational Krylov methods for nonlinear eigenvalue problems. SIAM J. Sci. Comput., 36(6), A2842-A2864, 2014.</li>
<li><a href="http://twr.cs.kuleuven.be/research/software/nleps/nleigs.php">NLEIGS Matlab toolbox</a></li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_nleigs.jl#L7-L44' class='documenter-source'>source</a><br></p>
<p><a id='Class-specific-methods-1'></a></p>
<h2 id="class-specific-methods">Class specific methods</h2>
<p><a id='Companion-linearizations-1'></a></p>
<h3 id="companion-linearizations">Companion linearizations</h3>
<p><a id='NonlinearEigenproblems.NEPSolver.companion' href='#NonlinearEigenproblems.NEPSolver.companion'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.companion</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>E,A = companion(nep::Pep);
</code></pre>

<p>Linearizes a  polynomial eigenvalue problem (PEP) a to the companion form, as in the paper by Mehrmann and Voss. More precisely, for a k-th degree PEP with n-by-n coefficient matrices, this returns matrices E and A, both kn-by-kn, corresponding to the linearized problem</p>
<p>$$
Ax = λEx
$$</p>
<p><strong>Example</strong></p>
<pre><code class="julia-repl">julia&gt; pep = nep_gallery(&quot;pep0&quot;);
julia&gt; E,A = companion(pep);
julia&gt; λ, V = eigen(A,E);
julia&gt; minimum(svd(compute_Mder(pep,λ[1])).S)
2.703104679937224e-12
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>V. Mehrmann and H. Voss, Non-linear eigenvalue problems, a challenge for modern eigenvalue methods, GAMM‐Mitteilungen (2004)</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_companion.jl#L8-L29' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.polyeig' href='#NonlinearEigenproblems.NEPSolver.polyeig'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.polyeig</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>λ,v = polyeig([eltype],nep::PEP,[eigsolvertype,])
</code></pre>

<p>Linearizes a  polynomial eigenvalue problem (PEP) a to the companion form and solves the corresponding linear eigenvalue problem; see <a href="./#NonlinearEigenproblems.NEPSolver.companion"><code>companion</code></a>. The <code>eigsolvertype</code> is optinal can be used to specify how the linear problem is solved; see <a href="../linsolvers/#NonlinearEigenproblems.LinSolvers.eig_solve"><code>eig_solve</code></a>, and <a href="../linsolvers/#NonlinearEigenproblems.LinSolvers.EigSolver"><code>EigSolver</code></a>.</p>
<p><strong>Example</strong></p>
<pre><code class="julia-repl">julia&gt; pep = nep_gallery(&quot;pep0&quot;);
julia&gt; λ,V = polyeig(pep);
julia&gt; minimum(svd(compute_Mder(pep,λ[1])).S)
2.1724582040065456e-14
julia&gt; norm(compute_Mlincomb(pep,λ[2],vec(V[:,2])))
1.2210363164200074e-12
</code></pre>

<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/1de8a1560277b9cc0d2b231879f7c664e94a8d89/src/method_companion.jl#L68-L85' class='documenter-source'>source</a><br></p>
<p><a id='Rational-?-1'></a></p>
<h3 id="rational">Rational ?</h3>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../types/" class="btn btn-neutral float-right" title="NEP Types">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href=".." class="btn btn-neutral" title="Introduction"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>
    
  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/nep-pack/NonlinearEigenproblems.jl" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href=".." style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../types/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script src="../js/theme.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="../assets/mathjaxhelper.js"></script>

</body>
</html>
