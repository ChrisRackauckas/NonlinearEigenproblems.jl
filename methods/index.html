<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="NEP-PACK team">
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>NEP Methods - NEPPACK</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">
  <link href="../assets/Documenter.css" rel="stylesheet">
  
  <script>
    // Current page data
    var mkdocs_page_name = "NEP Methods";
    var mkdocs_page_input_path = "methods.md";
    var mkdocs_page_url = "/methods/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> NEPPACK</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Introduction</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">NEP Methods</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#nep-methods">NEP Methods</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#newton-type-methods">Newton type methods</a></li>
        
            <li><a class="toctree-l3" href="#projection-methods">Projection methods</a></li>
        
            <li><a class="toctree-l3" href="#arnoldi-type-methods">Arnoldi type methods</a></li>
        
            <li><a class="toctree-l3" href="#class-specific-methods">Class specific methods</a></li>
        
        </ul>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../types/">NEP Types</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../transformations/">NEP transformations</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../gallery/">NEP Gallery</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../development/">Developer info</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">NEPPACK</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>NEP Methods</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/nep-pack/NonlinearEigenproblems.jl/edit/master/docs/methods.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p><a id='NEP-Methods-1'></a></p>
<h1 id="nep-methods">NEP Methods</h1>
<p>The NEP solver methods implemented in NEP-pack, are accessed by the functions below. The functions all return $λ,v,w$ where $λ$ is either a number (eigenvalue) a vector of eigenvalues $v$ is either a vector containing an eigenvector or a matrix whose columns corresponding to the eigenvectors.</p>
<p>The first parameter optional parameter in all NEP solver methods is a type. This type specifies which arithmetic should be used for the algorithm.</p>
<p>Example:</p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;)
julia&gt; λ,v=augnewton(Complex128,nep,v=ones(5))
(0.8347353572199425 + 0.0im, Complex{Float64}[0.480386+0.0im, 0.0631636+0.0im, -0.136405+0.0im, 0.214274+0.0im, 0.378581+0.0im])
julia&gt; typeof(λ)
Complex{Float64}
julia&gt; λ,v=augnewton(Float16,nep,v=ones(5))
(Float16(0.8223), Float16[0.47388, 0.063904, -0.13843, 0.21692, 0.38306])
julia&gt; typeof(λ)
Float16
</code></pre>

<p><a id='Newton-type-methods-1'></a></p>
<h2 id="newton-type-methods">Newton type methods</h2>
<p><a id='NonlinearEigenproblems.NEPSolver.newton' href='#NonlinearEigenproblems.NEPSolver.newton'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.newton</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>λ,v = newton([eltype],nep::NEP;[errmeasure,][tol,][maxit,][λ,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max])
</code></pre>

<p>Applies Newton-Raphsons method on the system of nonlinear equations with <code>n+1</code> unknowns:</p>
<p>$$
M(λ)v=0
$$</p>
<p>$$
c^Hv-1=0
$$</p>
<p>The kwarg <code>errmeasure</code> is a function handle which can be used to specify how the error is measured to be used in termination (default is absolute residual norm). The iteration is continued until errmeausure is less than <code>tol</code>. <code>λ</code> and <code>v</code> are starting approximations. <code>c</code> is the orthogonalization vector.  If <code>c=0</code> the current approximation will be used for the orthogonalization. <code>armijo_factor</code> specifies if an Armijo rule should be applied, and its value specifies the scaling factor of the step length (per reduction step). The variable <code>armijo_max</code> specifies the maximum number of step length reductions.</p>
<p><strong>Example</strong></p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; λ,v=newton(nep);
julia&gt; minimum(svdvals(compute_Mder(nep,λ)))
1.6066157878930876e-16
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>Nichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.</li>
<li>A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d46a076d64bc751938f15b32d86af7cfad547388/src/method_newton.jl#L12-L43' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.augnewton' href='#NonlinearEigenproblems.NEPSolver.augnewton'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.augnewton</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>augnewton([eltype], nep::NEP; [errmeasure,][tol,][maxit,][λ,][v,][c,][displaylevel,][linsolvercreator,][armijo_factor,][armijo_max])
</code></pre>

<p>Run the augmented Newton method. The method is equivalent to <code>newton()</code> in exact arithmetic,  but works only with operations on vectors of length <code>n</code>. The <code>linsolvecreator</code> is used to initiate linear solvers. See <code>newton()</code> for other parameters.</p>
<p><strong>Example</strong></p>
<p>This illustrates the equivalence between <code>newton</code> and <code>augnewton</code>.</p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;dep1&quot;)
julia&gt; λ1,v1=newton(nep,maxit=20,v=ones(size(nep,1)),λ=0)
julia&gt; λ2,v2=augnewton(nep,maxit=20,v=ones(size(nep,1)),λ=0)
julia&gt; λ1-λ2
0.0 + 0.0im
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>Nichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.</li>
<li>A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d46a076d64bc751938f15b32d86af7cfad547388/src/method_newton.jl#L256-L276' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.resinv' href='#NonlinearEigenproblems.NEPSolver.resinv'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.resinv</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>λ,v = resinv([eltype],nep::NEP;[errmeasure,][tol,][maxit,][λ,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max,][linsolvecreator])
</code></pre>

<p>Applies residual inverse iteration method for nonlinear eigenvalue problems. The kwarg <code>linsolvecreator</code> is a function which specifies how the linear system is created. The function calls <code>compute_rf</code> for the computation of the Rayleigh functional. See <code>newton()</code> for other parameters.</p>
<p><strong>Example</strong></p>
<p>The example shows how to specify if the method should run in real or complex mode (or any other <code>Number</code> type).</p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; λ,v=resinv(nep,λ=-2,v=ones(size(nep,1)))
julia&gt; typeof(λ)
Complex{Float64}
julia&gt; norm(compute_Mlincomb(nep,λ,v))
1.817030659827106e-14
julia&gt; λ,v=resinv(Float64,nep,λ=-2,v=ones(size(nep,1)))
julia&gt; typeof(λ)
Float64
julia&gt; norm(compute_Mlincomb(nep,λ,v))
1.817030659827106e-14
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>A. Neumaier, Residual inverse iteration for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 22 (1985) 914-923</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d46a076d64bc751938f15b32d86af7cfad547388/src/method_newton.jl#L122-L152' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.quasinewton' href='#NonlinearEigenproblems.NEPSolver.quasinewton'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.quasinewton</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>quasinewton([T=Complex128],nep,[errmeasure,][tol,][maxit,][λ,][v][ws][displaylevel][linsolvercreator,][armijo_factor,][armijo_max])
</code></pre>

<p>An implementation of the quasi-Newton approach referred to as quasi-Newton 2 in the reference. The method involves one linear system solve per iteration corresponding with the matrix $M(λ)$, where $λ$ is constant. The vector <code>ws</code> is a representation of the normalization, in the sense that $c^T=w_s^TM(λ)$, where all iterates satisfy $c^Tx_i=1$. See <code>newton()</code> for other parameters.</p>
<p><strong>Example</strong></p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;pep0&quot;)
julia&gt; λ,v=quasinewton(nep,v=ones(size(nep,1)));
julia&gt; norm(compute_Mlincomb(nep,λ,v))/norm(v)
6.301479387102376e-15
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>Jarlebring, Koskela, Mele, Disguised and new Quasi-Newton methods for nonlinear eigenvalue problems, arxiv preprint: https://arxiv.org/abs/1702.08492</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d46a076d64bc751938f15b32d86af7cfad547388/src/method_newton.jl#L362-L381' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.mslp' href='#NonlinearEigenproblems.NEPSolver.mslp'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.mslp</code></strong> &mdash; <em>Function</em>.</p>
<pre><code> mslp([eltype],nep::NEP;[errmeasure,][tol,][maxit,][λ,][v,][displaylevel,][eigsolvertype::DataType][armijo_factor=1,][armijo_max])
</code></pre>

<p>Runs the method of successive linear problems. The  method requires the solution of a generalized eigenvalue problem in every iteration. The method used for the eigenvalue computation is specified in eigsolvertype. See <code>newton</code> for other parameters.</p>
<p><strong>Example</strong></p>
<p>Create a rational NEP with SPMFs.</p>
<pre><code class="julia-repl">julia&gt; Av=[ones(3,3),eye(3,3),triu(ones(3,3))];
julia&gt; fv=[S-&gt; S, S -&gt; S^2, S::AbstractArray -&gt; inv(full(S)-eye(S)*10)]
julia&gt; nep=SPMF_NEP(Av,fv)
julia&gt; (λ,v)=mslp(nep)
julia&gt; compute_Mlincomb(nep,λ,v)
3-element Array{Complex{Float64},1}:
 -1.38778e-17+1.65715e-18im
 -5.55112e-17+1.30633e-17im
 -4.16334e-17-1.54436e-17im
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d46a076d64bc751938f15b32d86af7cfad547388/src/method_mslp.jl#L7-L33' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.rfi' href='#NonlinearEigenproblems.NEPSolver.rfi'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.rfi</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>rfi(nep,nept,[λ=0,][errmeasure=default_errmeasure,][tol=eps()*100,][maxit=100,][v=randn,][u=randn,][displaylevel=0,][linsolvecreator=default_linsolvecreator,])
</code></pre>

<p>This is an implementation of the two-sided Rayleigh functional Iteration. This method requires the transpose of the NEP, which needs to be provided in nept.</p>
<p><strong>Example:</strong></p>
<p>julia&gt; nep=nep_gallery("dep0"); julia&gt; nept=DEP([nep.A[1]',nep.A[2]']) julia&gt; λ,v,u=rfi(nep,nept,v=ones(size(nep,1))) julia&gt; norm(compute_Mder(nep,λ)<em>v) % v is a right eigenvector 5.4672143489065705e-16 julia&gt; norm(u'</em>compute_Mder(nep,λ)) % u is a left eigenvector 4.1447913221215544e-16</p>
<p><strong>Reference</strong></p>
<ul>
<li>Algorithm 4 in  Schreiber, Nonlinear Eigenvalue Problems: Newton-type Methods and Nonlinear Rayleigh Functionals, PhD thesis, TU Berlin, 2008</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d46a076d64bc751938f15b32d86af7cfad547388/src/method_rfi.jl#L3-L20' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.newtonqr' href='#NonlinearEigenproblems.NEPSolver.newtonqr'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.newtonqr</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>Newton-QR method.
</code></pre>

<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d46a076d64bc751938f15b32d86af7cfad547388/src/method_newton.jl#L465-L467' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.implicitdet' href='#NonlinearEigenproblems.NEPSolver.implicitdet'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.implicitdet</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>Implicit determinant method
</code></pre>

<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d46a076d64bc751938f15b32d86af7cfad547388/src/method_newton.jl#L530-L532' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.broyden' href='#NonlinearEigenproblems.NEPSolver.broyden'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.broyden</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>S,V = broyden([eltype,]nep::NEP[,approxnep::NEP];kwargs)
</code></pre>

<p>Runs Broydens method (with deflation) for the nonlinear eigenvalue problem defined by nep. An approximate nep can be provided which is used as an initialization of starting matrix/vectors.</p>
<p>The method computes an invariant pair and can therefore find several eigenvalues. The retured value is (S,V) is an invariant pair and the eigenvalues are on the diagonal of S.</p>
<p><strong>Example</strong></p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; S,V=broyden(nep);
julia&gt; λ=S[1,1]
-0.3587189459686267 - 3.0010731412746105e-31im
julia&gt; minimum(svdvals(compute_Mder(nep,λ)))
1.6066157878930856e-16
julia&gt; λ=S[2,2]
-0.04093521177097334 + 1.486011530941621im
julia&gt; minimum(svdvals(compute_Mder(nep,λ)))
4.159109513753696e-16
julia&gt; λ=S[3,3]
0.8347353572199486 + 1.5032076225139986e-14im
julia&gt; minimum(svdvals(compute_Mder(nep,λ)))
1.296144276122994e-14
julia&gt; broyden(nep,displaylevel=2,check_error_every=1);  % Prints out a lot more convergence info
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>Jarlebring, Broyden’s method for nonlinear eigenproblems, 2018, https://arxiv.org/pdf/1802.07322</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d46a076d64bc751938f15b32d86af7cfad547388/src/method_broyden.jl#L532-L566' class='documenter-source'>source</a><br></p>
<p><a id='Projection-methods-1'></a></p>
<h2 id="projection-methods">Projection methods</h2>
<pre><code>nlar
</code></pre>

<p><a id='Arnoldi-type-methods-1'></a></p>
<h2 id="arnoldi-type-methods">Arnoldi type methods</h2>
<p><a id='NonlinearEigenproblems.NEPSolver.iar' href='#NonlinearEigenproblems.NEPSolver.iar'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.iar</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>iar(nep,[maxit=30,][σ=0,][γ=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])
</code></pre>

<p><strong>Infinite Arnoldi method</strong></p>
<p>Runs the infinite Arnoldi method which tries to find eigenvalues close to the shift σ.</p>
<p><strong>Example</strong></p>
<pre><code class="julia-repl">julia&gt; using NonlinearEigenproblems: NEPSolver, NEPCore, Gallery
julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; λ,v=iar(nep);
julia&gt; minimum(svdvals(compute_Mder(nep,λ[1]))) % Is it an eigenvalue?

</code></pre>

<p><strong>References</strong></p>
<ul>
<li>Algorithm 2 in Jarlebring, Michiels Meerbergen, A linear eigenvalue algorithm for the nonlinear eigenvalue problem, Numer. Math, 2012</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d46a076d64bc751938f15b32d86af7cfad547388/src/method_iar.jl#L4-L23' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.tiar' href='#NonlinearEigenproblems.NEPSolver.tiar'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.tiar</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>tiar(nep,[maxit=30,][σ=0,][γ=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])
</code></pre>

<p>Runs the tensor infinite Arnoldi method which tries to find eigenvalues close to the shift σ.</p>
<p><strong>Example</strong></p>
<pre><code class="julia-repl">julia&gt; using NonlinearEigenproblems: NEPSolver, NEPCore, Gallery
julia&gt; nep=nep_gallery(&quot;dep0&quot;,100);
julia&gt; v0=ones(size(nep,1));
julia&gt; λ,v=iar(nep,v=v0,tol=1e-5,Neig=3);
julia&gt; λ
3-element Array{Complex{Float64},1}:
 -0.156062-0.122734im
 -0.156062+0.122734im
  0.231692+4.82981e-17im
julia&gt; λ,v=iar(nep,v=v0,tol=1e-5,Neig=3);
julia&gt; λ  % Same eigenvalues are computed
3-element Array{Complex{Float64},1}:
 -0.156062-0.122734im
 -0.156062+0.122734im
  0.231692+4.82981e-17im
</code></pre>

<p><strong>References</strong></p>
<ul>
<li>Algorithm 2 in Jarlebring, Mele, Runborg, The Waveguide Eigenvalue Problem and the Tensor Infinite Arnoldi Method, SIAM J. Scient. computing, 39 (3), A1062-A1088, 2017</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d46a076d64bc751938f15b32d86af7cfad547388/src/method_tiar.jl#L4-L32' class='documenter-source'>source</a><br></p>
<p><a id='NonlinearEigenproblems.NEPSolver.infbilanczos' href='#NonlinearEigenproblems.NEPSolver.infbilanczos'>#</a>
<strong><code>NonlinearEigenproblems.NEPSolver.infbilanczos</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>λv,V,U=infbilanczos([eltype],nep, nept,[linsolvecreator,][linsolvertcreator,][v,][u,][σ,][γ,][tol,][Neig,][errmeasure,][displaylevel,][maxit,][check_error_every])
</code></pre>

<p>Executes the Infinite Bi-Lanczos method on the problem defined by <code>nep::NEP</code> and <code>nept::NEP</code>. <code>nep:NEP</code> is the original nonlinear eigenvalue problem and <code>nept::NEP</code> is its (hermitian) transpose: $M(lambda^*)^H$.  <code>v</code> and <code>u</code> are starting vectors, <code>σ</code> is the shift and <code>γ</code> the scaling.  See <code>newton()</code> for other parameters.</p>
<p><strong>Example:</strong></p>
<pre><code class="julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; A=get_Av(nep); fv=get_fv(nep);
julia&gt; nept=SPMF_NEP([A[1]',A[2]',A[3]'],fv); # Create the transposed NEP
julia&gt; λv,V=infbilanczos(nep,nept,Neig=3)
julia&gt; norm(compute_Mlincomb(nep,λv[1],V[:,1]))
</code></pre>

<p><strong>References:</strong></p>
<ul>
<li>The infinite bi-Lanczos method for nonlinear eigenvalue problems, S. W. Gaaf and E. Jarlebring, arxiv: 1607.03454, to appear in SIAM J. Scientific Computing</li>
</ul>
<p><a target='_blank' href='https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d46a076d64bc751938f15b32d86af7cfad547388/src/method_infbilanczos.jl#L3-L24' class='documenter-source'>source</a><br></p>
<p><a id='Class-specific-methods-1'></a></p>
<h2 id="class-specific-methods">Class specific methods</h2>
<p><a id='Companion-linearizations-1'></a></p>
<h3 id="companion-linearizations">Companion linearizations</h3>
<p><a id='Rational-?-1'></a></p>
<h3 id="rational">Rational ?</h3>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../types/" class="btn btn-neutral float-right" title="NEP Types">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href=".." class="btn btn-neutral" title="Introduction"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>
    
  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/nep-pack/NonlinearEigenproblems.jl" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href=".." style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../types/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script src="../js/theme.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="../assets/mathjaxhelper.js"></script>

</body>
</html>
