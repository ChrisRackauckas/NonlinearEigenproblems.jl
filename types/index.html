<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types &amp; Data structures · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../methods/">NEP-Solvers</a></li><li class="current"><a class="toctext" href>Types &amp; Data structures</a><ul class="internal"><li><a class="toctext" href="#Specific-types-1">Specific types</a></li><li><a class="toctext" href="#General-types-1">General types</a></li><li><a class="toctext" href="#SPMF-1">SPMF</a></li><li><a class="toctext" href="#Helper-types-1">Helper types</a></li></ul></li><li><a class="toctext" href="../compute_functions/">Compute functions</a></li><li><a class="toctext" href="../linsolvers/">Linear solvers</a></li><li><a class="toctext" href="../innersolvers/">Projection</a></li><li><a class="toctext" href="../errmeasure/">Measuring the error</a></li><li><a class="toctext" href="../logger/">Logger</a></li><li><a class="toctext" href="../transformations/">Transformations</a></li><li><a class="toctext" href="../deflation/">Deflation</a></li><li><a class="toctext" href="../gallery/">Gallery</a></li></ul></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="toctext" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="toctext" href="../tutorial_call_python/">Tutorial 5 (Python)</a></li><li><a class="toctext" href="../tutorial_matlab1/">Tutorial 6 (MATLAB)</a></li><li><a class="toctext" href="../tutorial_fortran1/">Tutorial 7 (FORTRAN)</a></li><li><a class="toctext" href="../tutorial_nano1/">Tutorial 8 (gmsh + nanophotonics)</a></li><li><a class="toctext" href="../tutorial_newmethod/">Tutorial 9 (New solver)</a></li><li><a class="toctext" href="../tutorial_linsolve/">Tutorial 10 (Linear solvers)</a></li><li><a class="toctext" href="../hydrotutorial/">Tutorial 11 (Orr–Somerfeld)</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Types &amp; Data structures</a></li></ul><a class="edit-page" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/types.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Types &amp; Data structures</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Types-and-Data-structures-1" href="#Types-and-Data-structures-1">Types &amp; Data structures</a></h1><p>Nonlinear eigenvalue problems in NEP-PACK are represented by objects of the type <a href="#NonlinearEigenproblems.NEPCore.NEP"><code>NEP</code></a>. Each <code>NEP</code>-object needs to provide compute functions as we describe in <a href="../compute_functions/">the manual page on compute functions</a>. Efficient compute functions are already implemented for many common and several general types.</p><p>In the section <a href="#Specific-types-1">specific types</a> below, we list a number of common classes. As a user, first see if your problem fits to one of those classes, as NEP-PACK has very efficient compute functions for these classes. If your NEP does not fit into any of the specific types, we recommend that a user tries to specify the problem as an <a href="#NonlinearEigenproblems.NEPTypes.SPMF_NEP"><code>SPMF_NEP</code></a>, which is described in the section <a href="#General-types-1">general types</a>. If your problem can be phrased as a sum of two specific or general types, it is recommended that you use the <a href="#NonlinearEigenproblems.NEPTypes.SumNEP"><code>SumNEP</code></a>-type. NEP-PACK also supports efficient computation with low-rank NEPs via the <a href="#NonlinearEigenproblems.NEPTypes.LowRankFactorizedNEP"><code>LowRankFactorizedNEP</code></a>.</p><p>If your NEP is not easily expressed as an <a href="#NonlinearEigenproblems.NEPTypes.SPMF_NEP"><code>SPMF_NEP</code></a>, you may want to use the <a href="#Helper-types-1">helper types</a>.</p><p>The types also have a number of associated operations and transformation functions. The following example illustrates how you can resample a NEP (by interpolation with a Chebyshev polynomial basis in Chebyshev points provided by the <a href="#NonlinearEigenproblems.NEPTypes.ChebPEP"><code>ChebPEP</code></a> constructor) and apply a NEP-solver which requires many function evaluations, in this case <a href="../methods/#NonlinearEigenproblems.NEPSolver.contour_beyn"><code>contour_beyn</code></a>. The two-stage solution approach is much more efficient.</p><pre><code class="language-julia-repl">julia&gt; nep_bem=nep_gallery(&quot;bem_fichera&quot;);
julia&gt; cheb_nep=ChebPEP(nep_bem,20,0,10); # resample the NEP with 20 cheb points
 32.651313 seconds (263.16 M allocations: 36.279 GiB, 17.19% gc time)
julia&gt; @time (λ1,v1)=contour_beyn(nep_bem,radius=[5 0.2],σ=5.0, N=100,k=10,);
180.329069 seconds (1.39 G allocations: 183.462 GiB, 13.01% gc time)
julia&gt; @time (λ2,v2)=contour_beyn(cheb_nep,radius=[5 0.2],σ=5.0, N=100,k=10,);
  4.319376 seconds (362.34 k allocations: 8.856 GiB, 12.42% gc time)</code></pre><p>Note that running the contour integral method on the <code>cheb_nep</code> is much faster, even if we take into account that the resampling takes some computational effort. The computed solutions are very similar</p><pre><code class="language-julia-repl">julia&gt; λ1
2-element Array{Complex{Float64},1}:
 6.450968052414575 - 4.819767260258272e-5im
 8.105873440358572 - 0.00012794471501522612im
julia&gt; λ2
2-element Array{Complex{Float64},1}:
 6.450968052984224 - 4.819762104884087e-5im
 8.105873439472735 - 0.0001279450670266529im</code></pre><p>Moreover, if we want a very accurate solution, we can run a locally convergence iterative method on the original problem. It converges in very few iterations:</p><pre><code class="language-julia-repl">julia&gt; (λ2_1,v1_1)=quasinewton(nep_bem,λ=λ2[1], v=v2[:,1],logger=1);
Precomputing linsolver
iter 1 err:3.638530108313503e-12 λ=6.450968052984224 - 4.819762104884087e-5im
iter 2 err:1.2789912958165988e-14 λ=6.450968052419756 - 4.819768321350077e-5im
julia&gt; (λ2_2,v1_2)=quasinewton(nep_bem,λ=λ2[2], v=v2[:,2],logger=1)
Precomputing linsolver
iter 1 err:3.4824421200567996e-12 λ=8.105873439472735 - 0.0001279450670266529im
iter 2 err:2.05407750614131e-14 λ=8.105873440343123 - 0.00012794469925178411im</code></pre><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>The use of of Chebyshev interpolation in combination with the boundary element method (but with a companion linearization approach) was presented in  <a href="https://doi.org/10.1007/s10543-012-0381-5">Effenberger and Kressner. &quot;Chebyshev interpolation for nonlinear eigenvalue problems.&quot; BIT Numerical Mathematics 52.4 (2012): 933-951</a>. See also <a href="../bemtutorial/">the tutorial on boundary element method</a>.</p></div></div><h2><a class="nav-anchor" id="Specific-types-1" href="#Specific-types-1">Specific types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.DEP" href="#NonlinearEigenproblems.NEPTypes.DEP"><code>NonlinearEigenproblems.NEPTypes.DEP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">type DEP &lt;: AbstractSPMF
function DEP(AA::Vector{AbstractMatrix} [,tauv::Vector=[0,1.0]])</code></pre><p>A <code>DEP</code> (Delay Eigenvalue problem) is a problem defined by the sum</p><div>\[M(λ)=-λI + Σ_i A_i exp(-τ_i λ)\]</div><p>where all of the matrices are of size <span>$n×n$</span>. This type of NEP describes the stability of time-delay systems.</p><p>The construction takes the system matrices <span>$A_i$</span>, and <code>tauv</code> is a vector of the values  <span>$τ_i$</span>.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; A0=randn(3,3); A1=randn(3,3);
julia&gt; tauv=[0,0.2] # Vector with delays
julia&gt; dep=DEP([A0,A1],tauv)
julia&gt; λ=3.0;
julia&gt; M1=compute_Mder(dep,λ)
julia&gt; M2=-λ*I+A0+A1*exp(-tauv[2]*λ)
julia&gt; norm(M1-M2)
0.0</code></pre></div></div></section><p>There are two types to represent PEPs natively in NEP-PACK. You can use a monomial basis with <code>PEP</code> or a Chebyshev basis with <code>ChebPEP</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.PEP" href="#NonlinearEigenproblems.NEPTypes.PEP"><code>NonlinearEigenproblems.NEPTypes.PEP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct PEP &lt;: AbstractSPMF
function PEP(AA::Vector{AbstractMatrix})</code></pre><p>The type <code>PEP</code> defines a polynomial eigenvalue  problem via its monomial coefficients. A polynomial eigenvalue problem (PEP) is defined by the sum the</p><div>\[Σ_i A_i λ^i,\]</div><p>where <span>$i = 0,1,2,$</span>, and  all of the matrices are of size <span>$n×n$</span>. The vector <code>AA</code> contains <span>$A_1,...$</span>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A0=[1.0 3; 4 5]; A1=A0.+one(2); A2=ones(2,2);
julia&gt; pep=PEP([A0,A1,A2])
julia&gt; compute_Mder(pep,3)-(A0+A1*3+A2*9)
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0</code></pre><p>See also <a href="../methods/#NonlinearEigenproblems.NEPSolver.polyeig"><code>polyeig</code></a>, <a href="../methods/#NonlinearEigenproblems.NEPSolver.companion"><code>companion</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.ChebPEP"><code>ChebPEP</code></a>, <a href="../transformations/#NonlinearEigenproblems.NEPTypes.interpolate"><code>interpolate</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.ChebPEP" href="#NonlinearEigenproblems.NEPTypes.ChebPEP"><code>NonlinearEigenproblems.NEPTypes.ChebPEP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ChebPEP(orgnep::NEP,k,[a=-1,[b=1]] [,cosine_formula_cutoff=5])</code></pre><p>The type <code>ChebPEP&lt;:AbstractSPMF</code> represents a polynomial function where the function is stored using a Chebyshev basis scaled to the interval <code>[a,b]</code>, i.e.,</p><div>\[M(λ)= B_0T_0(λ)+⋯+B_{k-1}T_{k-1}(λ)\]</div><p>where <span>$T_i$</span> are the scaled and shifted Chebyshev polynomials.</p><p>The constructor <code>ChebPEP</code> takes <code>nep::NEP</code> as an input and interpolates this NEP in <code>k</code> Chebyshev nodes, resulting in a polynomial of degree <code>k-1</code>, represented by its coefficients in the Chebyshev basis. Interpolation in Chebyshev nodes and representation with Chebyshev basis, is known to have attractive approximation properties, as well as robustness with respect to round-off errors.</p><p>The kwarg <code>cosine_formula_cutoff</code> decides how the Chebyshev polynomials should be computed. For larger degrees, it is better to use the cosine formula, whereas for low degrees the explicit monomial expression is more efficient. The explicit monomial expression will be used for degrees lower than <code>cosine_formula_cutoff</code>.</p><p><strong>Example:</strong></p><pre><code class="language-julia">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; chebpep=ChebPEP(nep,9);
julia&gt; using LinearAlgebra;
julia&gt; norm(compute_Mder(nep,0.3)-compute_Mder(chebpep,0.3))
1.2881862971045282e-8
julia&gt; chebpep=ChebPEP(nep,19); # Better interpolation
julia&gt; norm(compute_Mder(nep,0.3)-compute_Mder(chebpep,0.3))
2.0312004517316714e-15</code></pre><p>See also: <a href="../methods/#NonlinearEigenproblems.NEPSolver.polyeig"><code>polyeig</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.PEP"><code>PEP</code></a></p></div></div></section><h3><a class="nav-anchor" id="REP-1" href="#REP-1">REP</a></h3><p>The Rational Eigenvalue Problem is described by:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.REP" href="#NonlinearEigenproblems.NEPTypes.REP"><code>NonlinearEigenproblems.NEPTypes.REP</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function REP(A,roots,poles)</code></pre><p>A <code>REP</code>-call creates a rational eigenvalue problem. The <code>REP</code> is defined by the sum <span>$Σ_i A_i s_i(λ)/q_i(λ)$</span>, where i = 0,1,2,..., all of the matrices are of size <span>$n×n$</span> and <span>$s_i$</span> and <span>$q_i$</span> are polynomials. The constructor takes the roots and poles as input of polynomials with normalized highest coefficient. The NEP is defined as</p><div>\[-λI+A_1+A_1rac{p(λ)}(q(λ)}\]</div><p>where <code>p</code> has the roots <code>roots</code> and <code>q</code> has the roots <code>poles</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A0=[1 2; 3 4]; A1=[3 4; 5 6];
julia&gt; nep=REP([A0,A1],[1,3], [4,5,6]);
julia&gt; compute_Mder(nep,3)
2×2 Array{Float64,2}:
 Inf  Inf
 Inf  Inf
julia&gt; (λ,x)=quasinewton(nep,v=[1;0])
(-0.3689603779201249 + 0.0im, Complex{Float64}[-2.51824+0.0im, 1.71283+0.0im])
julia&gt; -λ*x+A0*x+A1*x*(λ-1)*(λ-3)/((λ-4)*(λ-5)*(λ-6))
2-element Array{Complex{Float64},1}:
 -2.5055998942313806e-13 + 0.0im
   1.318944953254686e-13 + 0.0im</code></pre></div></div></section><h2><a class="nav-anchor" id="General-types-1" href="#General-types-1">General types</a></h2><p>The basic class is the abstract class <code>NEP</code> which represents a NEP. All other defined NEPs should inherit from <code>NEP</code>, or from a more specialized version; see, e.g., <a href="../transformations/#NonlinearEigenproblems.NEPTypes.ProjectableNEP"><code>ProjectableNEP</code></a> or <a href="#NonlinearEigenproblems.NEPTypes.AbstractSPMF"><code>AbstractSPMF</code></a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPCore.NEP" href="#NonlinearEigenproblems.NEPCore.NEP"><code>NonlinearEigenproblems.NEPCore.NEP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract NEP</code></pre><p>A <code>NEP</code> object represents a nonlinear eigenvalue problem. All NEPs should implement</p><pre><code class="language-julia-repl">size(nep::NEP,d)</code></pre><p>and at least one of the following</p><ul><li>M = <a href="../compute_functions/#NonlinearEigenproblems.NEPCore.compute_Mder"><code>compute_Mder(nep::NEP,λ::Number,i::Integer=0)</code></a></li><li>V = <a href="../compute_functions/#NonlinearEigenproblems.NEPCore.compute_Mlincomb"><code>compute_Mlincomb(nep::NEP,λ::Number,V::AbstractVecOrMat,a::Vector)</code></a> (or <code>compute_Mlincomb!</code>)</li><li>MM = <a href="../compute_functions/#NonlinearEigenproblems.NEPCore.compute_MM"><code>compute_MM(nep::NEP,S,V)</code></a></li></ul></div></div></section><p>Below we list the most common types built-in to NEP-PACK, and further down how you can <a href="#accessNEP">access the NEP</a>. However, the structure is made for extendability, and hence it is possible for you to extend with your own class of NEPs.</p><h2><a class="nav-anchor" id="SPMF-1" href="#SPMF-1">SPMF</a></h2><p>One of the most common problem types is the <code>SPMF_NEP</code>. SPMF is short for Sum of Products of Matrices and Functions and the NEP is described by</p><div>\[M(λ) = \sum_{i} A_i f_i(λ).\]</div><p>The constructor of the <code>SPMF_NEP</code>, takes the the matrices and the functions, but also a number of other (optional) parameters which may increase performance or preserve underlying types.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.SPMF_NEP" href="#NonlinearEigenproblems.NEPTypes.SPMF_NEP"><code>NonlinearEigenproblems.NEPTypes.SPMF_NEP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct SPMF_NEP{T&lt;:AbstractMatrix,Ftype}  &lt;: AbstractSPMF{T}
function SPMF_NEP(AA, fii [,check_consistency=true] [,Schur_fact = false]
                  [,align_sparsity_patterns = false] [,Ftype=ComplexF64])</code></pre><p>An <code>SPMF_NEP</code> is a <code>NEP</code> defined by a <em>S</em>um of <em>P</em>roducts of <em>M</em>atrices and <em>F</em>unctions, i.e.,</p><div>\[M(λ)=∑_i A_i f_i(λ).\]</div><p>All of the matrices <span>$A_0,...$</span> are of size <span>$n×n$</span> and <span>$f_i$</span> are a functions. The  functions <span>$f_i$</span> must be defined for matrices in the standard matrix function sense. The constructor creates a <code>SPMF_NEP</code> consisting of matrices <code>AA</code> and functions <code>fii</code>.</p><p><strong>Parameters</strong></p><ul><li><p><code>AA</code> is a <code>Vector</code> of matrices. The matrices have to be of the same type. If you need a NEP with different types you can use <a href="#NonlinearEigenproblems.NEPTypes.SumNEP"><code>SumNEP</code></a> to construct a sum of two <code>SPMF_NEP</code>.</p></li><li><p><code>fii</code> is a <code>Vector</code> of functions. Each function takes one parameter <code>S</code>. The functions must be available both as a scalar valid function and a matrix function. If <code>S</code> is a square matrix, <code>fii[k](S)</code> musst also be a square matrix. If <code>S</code> is a scalar <code>fii[k](S)</code> is a scalar.</p></li><li><p><code>check_consistency</code> (default <code>true</code>) determines if we should initiate by running tests to verify that the <code>fii</code> satisfies the conditions that every function is valid both for matrices and scalars. This is done by using <code>@code_typed</code> and the functions need to be type-stable in that sense.</p></li><li><p><code>align_sparsity_patterns</code> (default <code>false</code>) has effect only for sparse matrices (<code>SparseMatrixCSC</code>). If <code>align_sparsity_patterns=true</code> the <code>SparseMatrixCSC</code> matrices will be replaced by equivalent <code>SparseMatrixCSC</code> matrices where the <code>colptr</code> and <code>rowval</code> are identical. This increases the speed of some functions, e.g., <code>compute_Mder</code>. If <code>align_sparsity_patterns=true</code> the matrices in the NEP should be considered read only. If the sparsity patterns are completely or mostly distinct, it may be more efficient to set this flag to false.</p></li><li><p><code>Ftype</code> (default <code>ComplexF64</code>) determines an underlying type of the functions. The output of any function should be &quot;smaller&quot; than the promoted type of the input and <code>Ftype</code>. More precisely, if <code>F=fii[k]</code>, then the type logic is as follows <code>eltype(F(λ))=promote_type(eltype(λ),Ftype)</code>.</p></li><li><p><code>Schur_fact</code> (default <code>false</code>) determines if the <code>compute_MM</code> function should triangularize the matrix before carrying out the computation. This can be faster for large matrices.</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A0=[1 3; 4 5]; A1=[3 4; 5 6];
julia&gt; id_op=S -&gt; one(S) # Note: We use one(S) to be valid both for matrices and scalars
julia&gt; exp_op=S -&gt; exp(S)
julia&gt; nep=SPMF_NEP([A0,A1],[id_op,exp_op]);
julia&gt; compute_Mder(nep,1)-(A0+A1*exp(1))
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.AbstractSPMF" href="#NonlinearEigenproblems.NEPTypes.AbstractSPMF"><code>NonlinearEigenproblems.NEPTypes.AbstractSPMF</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract  AbstractSPMF &lt;: ProjectableNEP</code></pre><p>An AbstractSPMF is an abstract class representing NEPs which can be represented as a sum of products of matrices and functions <span>$M(λ)=Σ_i A_i f_i(λ)$</span>, where i = 0,1,2,..., all of the matrices are of size <span>$n×n$</span> and <span>$f_i$</span> are functions.</p><p>Any AbstractSPMF has to have implementations of <a href="#NonlinearEigenproblems.NEPTypes.get_Av"><code>get_Av()</code></a> and <a href="#NonlinearEigenproblems.NEPTypes.get_fv"><code>get_fv()</code></a> which return the functions and matrices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.get_Av" href="#NonlinearEigenproblems.NEPTypes.get_Av"><code>NonlinearEigenproblems.NEPTypes.get_Av</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">get_Av(nep::AbstractSPMF)</code></pre><p>Returns an array of matrices <span>$A_i$</span> in the AbstractSPMF: <span>$M(λ)=Σ_i A_i f_i(λ)$</span></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.get_fv" href="#NonlinearEigenproblems.NEPTypes.get_fv"><code>NonlinearEigenproblems.NEPTypes.get_fv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">get_Av(nep::AbstractSPMF)</code></pre><p>Returns an Array of functions (that can be evaluated both as scalar and matrix functions) <span>$f_i$</span> in the AbstractSPMF: <span>$M(λ)=Σ_i A_i f_i(λ)$</span></p></div></div></section><h3><a class="nav-anchor" id="Projectable-NEP-types-1" href="#Projectable-NEP-types-1">Projectable NEP types</a></h3><p>There are also types associated with projection described on  <a href="../innersolvers/">the projection manual page</a>:</p><ul><li><a href="../innersolvers/#NonlinearEigenproblems.NEPTypes.ProjectableNEP"><code>ProjectableNEP</code></a></li><li><a href="../innersolvers/#NonlinearEigenproblems.NEPTypes.Proj_NEP"><code>Proj_NEP</code></a></li></ul><h3><a class="nav-anchor" id="SumNEP-1" href="#SumNEP-1">SumNEP</a></h3><p>It is also possible to consider NEPs that are sums of other NEPs. For such situations there are SumNEPs. Specifically <code>GenericSumNEP</code> and <code>SPMFSumNEP</code>. Both are constructed using the function <code>SumNEP</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.SumNEP" href="#NonlinearEigenproblems.NEPTypes.SumNEP"><code>NonlinearEigenproblems.NEPTypes.SumNEP</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SumNEP{nep1::NEP,nep2::NEP}
SumNEP{nep1::AbstractSPMF,nep2::AbstractSPMF}</code></pre><p><code>SumNEP</code> is a function creating an object that corresponds to a sum of two NEPs, i.e., if nep is created by <code>SumNEP</code> it is defined by</p><div>\[M(λ)=M_1(λ)+M_2(λ)\]</div><p>where <span>$M_1$</span> and <span>$M_2$</span> are defined by <code>nep1</code> and <code>nep2</code>.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; nep1=DEP([ones(3,3),randn(3,3)])
julia&gt; nep2=PEP([ones(3,3),randn(3,3),randn(3,3)])
julia&gt; sumnep=SumNEP(nep1,nep2);
julia&gt; s=3.0;
julia&gt; M=compute_Mder(sumnep,s);
3×3 Array{Float64,2}:
  8.54014     6.71897   7.12007
 -0.943908  -13.0795   -0.621659
  6.03155    -7.26726  -6.42828
julia&gt; M1=compute_Mder(nep1,s);
julia&gt; M2=compute_Mder(nep2,s);
julia&gt; M1+M2  # Same as M
3×3 Array{Float64,2}:
  8.54014     6.71897   7.12007
 -0.943908  -13.0795   -0.621659
  6.03155    -7.26726  -6.42828</code></pre><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.SPMFSumNEP"><code>SPMFSumNEP</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.GenericSumNEP"><code>GenericSumNEP</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.GenericSumNEP" href="#NonlinearEigenproblems.NEPTypes.GenericSumNEP"><code>NonlinearEigenproblems.NEPTypes.GenericSumNEP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct GenericSumNEP{NEP1&lt;:NEP,NEP2&lt;:NEP}  &lt;: NEP</code></pre><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.SumNEP"><code>SumNEP</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.SPMFSumNEP"><code>SPMFSumNEP</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.SPMFSumNEP" href="#NonlinearEigenproblems.NEPTypes.SPMFSumNEP"><code>NonlinearEigenproblems.NEPTypes.SPMFSumNEP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct SPMFSumNEP{NEP1&lt;:AbstractSPMF,NEP2&lt;:AbstractSPMF}  &lt;: AbstractSPMF{AbstractMatrix}</code></pre><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.SumNEP"><code>SumNEP</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.GenericSumNEP"><code>GenericSumNEP</code></a></p></div></div></section><h3><a class="nav-anchor" id="Low-rank-NEPs-1" href="#Low-rank-NEPs-1">Low-rank NEPs</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.LowRankFactorizedNEP" href="#NonlinearEigenproblems.NEPTypes.LowRankFactorizedNEP"><code>NonlinearEigenproblems.NEPTypes.LowRankFactorizedNEP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct LowRankFactorizedNEP &lt;: AbstractSPMF
function LowRankFactorizedNEP(L::Vector,U::Vector,f::Vector)
function LowRankFactorizedNEP(L::Vector,U::Vector,A::Vector, f::Vector)</code></pre><p>Representation of a <code>NEP</code> which has low rank in the sense that it is an <code>SPMF</code> where each of the terms are factorized: <code>A[i]=L[i]*U[i]&#39;</code>. The factorization is provided in the <code>L</code> and <code>U</code> vectors and the full matrix <code>A[i]</code> can be either provided (or is otherwise implicitly computed).</p><p><strong>Example:</strong></p><pre><code class="language-none">julia&gt; L=randn(5,1); U=randn(5,1);
julia&gt; f=S-&gt;exp(S)
julia&gt; nep=LowRankFactorizedNEP([L],[U],[f]);
julia&gt; X=randn(5,2);
julia&gt; norm(compute_Mlincomb(nep,0.0,X)-L*U&#39;*X*ones(2),1)
6.661338147750939e-16</code></pre></div></div></section><h2><a class="nav-anchor" id="Helper-types-1" href="#Helper-types-1">Helper types</a></h2><p>There are also the helper types <a href="../compute_functions/#NonlinearEigenproblems.NEPTypes.Mder_NEP"><code>Mder_NEP</code></a> and <a href="../compute_functions/#NonlinearEigenproblems.NEPTypes.Mder_Mlincomb_NEP"><code>Mder_Mlincomb_NEP</code></a>. These are further described in the section about <a href="../compute_functions/">Compute functions</a></p><footer><hr/><a class="previous" href="../methods/"><span class="direction">Previous</span><span class="title">NEP-Solvers</span></a><a class="next" href="../compute_functions/"><span class="direction">Next</span><span class="title">Compute functions</span></a></footer></article></body></html>
