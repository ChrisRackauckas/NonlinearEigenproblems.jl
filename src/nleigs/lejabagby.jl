#LEJABAGBY generate Leja-Bagby points (a,b) on (A,B), with
#  scaling factors beta such that the uniform norm on the control set C is
#  1. Greedy search for a minimum is performed on B. If keepA is true then
#  the points in the output a will be exactly those of A, otherwise the
#  points in a are also chosen via greedy search on A. If forceInf is a
#  positive integeger, the the first forceInf poles in b will be infinity.
function lejabagby(A, B, C, m, keepA=false, forceInf=0)
    if minimum(abs.(B)) < 1e-9
        warn("There is at least one pole candidate in B being nearby zero. Consider shifting your problem for stability.")
    end

    REF=[100000,
11703.150981165747,
2591.32188237217042,
192989.154732288298,
1177.1659489857941,
37671.2416148045231,
2123.23244907087383,
76966.3850795530889,
4826.67591280588113,
36173.908419116844,
548.251191688448671,
90993.5282558028703,
2127.13296838622591,
8049.03010845461995,
15316.3062595633965,
47775.190588716112,
7909.22677739737719,
52341.3880357522648,
71.1418388002778812,
12452.5085924270152,
10530.0837236391726,
7015.90826520488463,
33317.2678968372275,
15949.1548703117624,
5288.57134451860566,
8088.12858969804256,
57720.1135757679804,
8053.71444245323346,
98606.7382010662404,
5412.61619027600136,
6676.12952811327159,
2240.12185693048241,
23233.6722073404671,
39369.4494082683086,
396.925061346459131,
8186.96021512379957,
18143.1462641231483,
3112.69912220518017,
159659.638064667524,
3746.43321095771444,
87800.8030546951486,
3074.60660014419182,
5819.87193260262302,
729.171504881956366,
27372.0746415867907,
37745.9173623448878,
1195.22547732140038,
8407.40183781455562,
36758.6071399534339,
41099.9041205083049,
1560.37650993044826,
27844.0899725301169,
6620.1391741888101,
8136.77808517109133,
19822.4360846306881,
4561.58035713144181,
9331.78092198004379,
15003.8854158619597,
9997.68811756417563,
34256.4863050293789,
10202.421877662091,
9919.55317957280022,
80284.8718799804628,
149.530645917424692,
5712.4228253027768,
58495.3017088484921,
2550.38589683488954,
120564.808960816328,
3333.53244526542358,
29387.7686671991141,
1684.81599741961531,
21031.7387047856973,
15044.6764756827124,
112997.325946258221,
2688.03687714769285,
7683.38834728496749,
1101.33217446241542,
14135.1762622481656,
33067.4694519346522,
12248.3972059773278,
10872.7704014667088,
1565.17067368843323,
7847.00495740173028,
11802.7940214914233,
68038.9397510257695,
6964.79780565070087,
24874.1478154492543,
6667.34309011140158,
64665.7712261593842,
1382.25584668178703,
40935.4584806169732,
99.0982354490504633,
48476.7054493500546,
26978.672242781704,
2244.58509000996628,
22497.0046674381629,
11709.1660623859661,
3422.83055556994668,
105398.017991547647,
1285.66036294095375,
120771.890674387541]

REF=[
99999.4045792545803,
5491.88643954805229,
1557.86315934633376,
130176.56827594155,
340.600507005236182,
37671.2416148045231,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0]

    a = [A[1]]
    b = [forceInf > 0 ? Inf : B[1]]
    beta = [1.]

    sA = ones(A)
    sB = ones(eltype(A), size(B))
    sC = ones(eltype(A), size(C))

#    @printf("init A diff 6098: %s\n", A[6098])
    for j = 1:m-1
        sA .*= ((A-a[j]) ./ (1 - A/b[j]));
        sB .*= ((B-a[j]) ./ (1 - B/b[j]));
        sC .*= ((C-a[j]) ./ (1 - C/b[j]));

#        rr=maximum(abs.(sA))
#        idx=indmax(abs.(sA))
#        @printf("%d rel diff: %s (idx %d)\n", j, (rr-REF[j])/rr, idx) # between it 5 and 6, precision drops by a factor x1000
#        @printf("A %d diff 6098: %s\n", j, sA[6098])
#        @printf("%d diff 6098: %s\n", j, (abs(sA[6098])-REF[j])/abs(sA[6098]))
#        @printf("%d A: %s\n", j, norm(sA))
#        @printf("%d B: %s\n", j, norm(sB))
        push!(a, A[keepA ? j+1 : indmax(abs.(sA))])
        push!(b, forceInf > j ? Inf : B[indmin(abs.(sB))])
        push!(beta, maximum(abs.(sC)))

        # treat single point case
        if beta[j+1] < eps()
            beta[j+1] = 1
        end

        sA /= beta[j+1]
#        @printf("B %d diff 6098: %s\n", j, sA[6098]) # between it 5 and 6, precision drops by a factor x1000
        sB /= beta[j+1]
        sC /= beta[j+1]
    end

    return a, b, beta
end
