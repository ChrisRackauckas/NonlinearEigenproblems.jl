<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 10 (Linear solvers) · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../methods/">NEP-Solvers</a></li><li><a class="toctext" href="../types/">NEP Types</a></li><li><a class="toctext" href="../compute_functions/">Compute functions</a></li><li><a class="toctext" href="../linsolvers/">LinSolvers</a></li><li><a class="toctext" href="../innersolvers/">Projection</a></li><li><a class="toctext" href="../errmeasure/">Measuring the error</a></li><li><a class="toctext" href="../logger/">Logger</a></li><li><a class="toctext" href="../transformations/">Transformations.</a></li><li><a class="toctext" href="../deflation/">Deflation</a></li><li><a class="toctext" href="../gallery/">Gallery</a></li></ul></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="toctext" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="toctext" href="../tutorial_call_python/">Tutorial 5 (Python)</a></li><li><a class="toctext" href="../tutorial_matlab1/">Tutorial 6 (MATLAB)</a></li><li><a class="toctext" href="../tutorial_fortran1/">Tutorial 7 (FORTRAN)</a></li><li><a class="toctext" href="../tutorial_nano1/">Tutorial 8 (gmsh + nanophotonics)</a></li><li><a class="toctext" href="../tutorial_newmethod/">Tutorial 9 (New solver)</a></li><li class="current"><a class="toctext" href>Tutorial 10 (Linear solvers)</a><ul class="internal"><li><a class="toctext" href="#Built-in-linear-solvers-1">Built-in linear solvers</a></li><li><a class="toctext" href="#Your-own-linear-solver-1">Your own linear solver</a></li></ul></li><li><a class="toctext" href="../hydrotutorial/">Tutorial 11 (Orr-Somerfeld)</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href>Tutorial 10 (Linear solvers)</a></li></ul><a class="edit-page" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/tutorial_linsolve.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial 10 (Linear solvers)</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial:-Your-own-linear-solver-1" href="#Tutorial:-Your-own-linear-solver-1">Tutorial: Your own linear solver</a></h1><p>Many of the NEP-solvers are based on solving linear systems of the type</p><div>\[M(λ)x=b.\]</div><p>In some methods the linear system matrices are the same, i.e., <span>$λ$</span> does not change. You can specify which numerical methods should be used to solve the linear system when you call a NEP-solver. This tutorial illustrates this functionality, and finally shows how you can specify your own method for linear systems.</p><h2><a class="nav-anchor" id="Built-in-linear-solvers-1" href="#Built-in-linear-solvers-1">Built-in linear solvers</a></h2><p>The linear solver is specified with the <code>linsolvercreator</code> keyword argument in most NEP-solvers. Let us contruct an example which we will solve with several methods. The matrix <span>$M(λ)$</span> is sparse, and the nonlinearity is an exponential term:</p><pre><code class="language-julia">using NonlinearEigenproblems, SparseArrays, LinearAlgebra;
n=100;
α=0.01;
A=spdiagm(0=&gt;ones(n),1=&gt;α*ones(n-1),-3=&gt;α*ones(n-3));
B=spdiagm(0=&gt;ones(n));
C=spdiagm(0=&gt;(1:n)/n);
nep= SPMF_NEP([A,B,C],[s-&gt;one(s),s-&gt;s,s-&gt;exp(s)],align_sparsity_patterns=true);
λ0=-1.2; # Starting guess</code></pre><p>Let us first solve it with the  <a href="../methods/#NonlinearEigenproblems.NEPSolver.resinv"><code>resinv</code></a> method, using the default solver for the linear system:</p><pre><code class="language-julia-repl">julia&gt; (λ,x)=resinv(nep,λ=λ0,v=ones(n),logger=1,tol=1e-16);
Precomputing linsolver
iter 1 err:0.003863455199119409 λ=-1.2 + 0.0im
iter 2 err:0.0012874946992780317 λ=-1.175478914232863 + 0.0im
iter 3 err:0.016919177734890205 λ=-0.9045032212171923 + 0.0im
iter 4 err:7.884718326366283e-5 λ=-1.1998094425367551 + 0.0im
iter 5 err:9.586775788595438e-5 λ=-1.1974656536889654 + 0.0im
iter 6 err:3.7870317997772634e-5 λ=-1.1994205846695276 + 0.0im
iter 7 err:3.0752556063829646e-5 λ=-1.1985663733901704 + 0.0im
...
iter 69 err:5.647660764089489e-16 λ=-1.1989892137958458 + 0.0im
iter 70 err:5.055053391642266e-16 λ=-1.1989892137958578 + 0.0im
iter 71 err:1.781530900695102e-17 λ=-1.1989892137958473 + 0.0im</code></pre><p>We will carry out some timing experiments, so let&#39;s use the <code>BenchmarkTools</code>-package and swith off printouts in the NEP-solver:</p><pre><code class="language-julia-repl">julia&gt; using BenchmarkTools
julia&gt; @btime (λ,x)=resinv(nep,λ=λ0,v=ones(n),tol=1e-16);
  8.373 ms (33714 allocations: 11.37 MiB)</code></pre><p>The linear system that has to be solved in every iteration in <code>resinv</code> has a constant system matrix, and therefore a prefactorization (typically an LU-factorization) is useful. This is done with the <code>FactorizeLinSolveCreator</code>, which is actually the default behaviour, so we get no substantial difference when we specify a creator if the type <code>FactorizeLinSolverCreator</code>.</p><pre><code class="language-julia-repl">julia&gt; creator=FactorizeLinSolverCreator();
julia&gt; @btime (λ,x)=resinv(nep,λ=λ0,v=ones(n),maxit=100,linsolvercreator=creator,tol=1e-16);
  8.332 ms (33704 allocations: 11.37 MiB)</code></pre><p>If we do not want to use a prefactorization, you can specify <code>BackslashLinSolverCreator</code> as your creator object.</p><pre><code class="language-julia-repl">julia&gt; creator=BackslashLinSolverCreator();
julia&gt; @btime (λ,x)=resinv(nep,λ=λ0,v=ones(n),maxit=100,linsolvercreator=creator,tol=1e-16);
  20.640 ms (38251 allocations: 22.87 MiB)</code></pre><p>This does not use a prefactorization and is therefore slower.</p><p>The above approach corresponded to direct methods for linear systems. You can also use iterative methods, e.g., the GMRES-method. The GMRES-method is available in the <code>GMRESLinSolverCreator</code> function. Iterative methods in general need preconditioners. We continue the example and use a diagonal preconditioner:</p><pre><code class="language-julia-repl">julia&gt; D0=(Diagonal(compute_Mder(nep,λ0))); # Preconditioner
julia&gt; creator=GMRESLinSolverCreator(Pl=D0, tol=1e-10);</code></pre><p>All the keyword arguments in the call <code>GMRESLinSolverCreator</code> are passed to <a href="https://juliamath.github.io/IterativeSolvers.jl/stable/linear_systems/gmres/"><code>gmres!</code></a>. Hence, the <code>tol</code> here  specifies a termination criteria for the GMRES-method, and <code>Pl</code> specifies the left preconditioner, in this case just a diagonal matrix.</p><pre><code class="language-julia-repl">julia&gt; (λ,x)=resinv(nep,λ=λ0,v=ones(n),maxit=100,linsolvercreator=creator,logger=1,tol=1e-16);
Precomputing linsolver
iter 1 err:0.003863455199119409 λ=-1.2 + 0.0im
iter 2 err:0.0012874946993129863 λ=-1.175478914232863 + 0.0im
iter 3 err:0.01691917773640539 λ=-0.9045032211965017 + 0.0im
iter 4 err:7.884718724884878e-5 λ=-1.1998094425350523 + 0.0im
iter 5 err:9.586776747525804e-5 λ=-1.1974656535293027 + 0.0im
...
iter 69 err:7.114086177493848e-16 λ=-1.1989892137958427 + 0.0im
iter 70 err:3.434521011774537e-16 λ=-1.1989892137958578 + 0.0im
iter 71 err:1.1060298018746236e-16 λ=-1.1989892137958504 + 0.0im
iter 72 err:1.1903842077731908e-16 λ=-1.1989892137958529 + 0.0im
iter 73 err:3.82409101411086e-16 λ=-1.1989892137958553 + 0.0im
iter 74 err:2.8385047264009487e-16 λ=-1.1989892137958476 + 0.0im
iter 75 err:2.578560246193603e-16 λ=-1.1989892137958535 + 0.0im
iter 76 err:3.8680157882039993e-16 λ=-1.198989213795848 + 0.0im
iter 77 err:1.4633231742581634e-16 λ=-1.1989892137958562 + 0.0im
iter 78 err:2.324747046412835e-16 λ=-1.198989213795853 + 0.0im
iter 79 err:1.7053137640282208e-16 λ=-1.1989892137958487 + 0.0im
iter 80 err:5.364097787291277e-17 λ=-1.1989892137958522 + 0.0im</code></pre><p>The printout reveals that we need more iterations, than with a direct method. In terms of computation time, this approach can however still be competitive:</p><pre><code class="language-julia-repl">julia&gt; creator=GMRESLinSolverCreator(Pl=D0, tol=1e-2);
julia&gt; @btime (λ,x)=resinv(nep,λ=λ0,v=ones(n),maxit=100,linsolvercreator=creator,tol=1e-16);
  12.734 ms (59414 allocations: 21.14 MiB)</code></pre><h2><a class="nav-anchor" id="Your-own-linear-solver-1" href="#Your-own-linear-solver-1">Your own linear solver</a></h2><p>There are many ways to solve linear systems in Julia, e.g., by using package such as <a href="https://github.com/Jutho/KrylovKit.jl">KrylovKit.jl</a>, <a href="https://github.com/JuliaSparse/Pardiso.jl">Pardiso.jl</a> or <a href="https://github.com/JuliaInv/KrylovMethods.jl">KrylovMethods.jl</a>. These are not natively supported by NEP-PACK, but due to the extendability of the <code>LinSolverCreator</code>-objects specified above, you can still use them. We illustrate the extendability by creating a linear solver based on solving a <a href="https://en.wikipedia.org/wiki/Schur_complement">Schur complement</a>. The following helper-function for the Schur complement solve will be used later.</p><pre><code class="language-julia">function schur_complement_lin_solve(AA,b,n0)
  A=AA[1:n0,1:n0];
  B=AA[1:n0,(n0+1):end];
  C=AA[(n0+1):end,1:n0];
  D=AA[(n0+1):end,(n0+1):end];
  S=D-C*(A\B); # Schur complement
  b1=b[1:n0]; b2=b[(n0+1):end];
  Ainvb1=A\b1; Sinvb2=S\b2;
  # Formula for the linear solve:
  x1=A\(b1+(B*(S\(C*(Ainvb1)))))-A\(B*(Sinvb2))
  x2=-S\(C*(Ainvb1))+Sinvb2;
  return [x1;x2];
end</code></pre><p>Julia&#39;s efficiency stems partially from the extensive use of types. We need to defined new types to define our own linear solver and integrate it with NEP-PACK.</p><pre><code class="language-julia">struct MyLinSolverCreator &lt;: LinSolverCreator; end
struct MyLinSolver &lt;: LinSolver;
  mynep
  myλ
end</code></pre><p>NEP-solvers call the function <code>create_linsolver(creator,nep,λ)</code>, which should return a linear solver. We need to overload this function for our own creator-type. In general, this is to allow precomputation. However, in this example we do not have any precomputations and thus just return an instance of <code>MyLinSolver</code>.</p><pre><code class="language-julia">import NonlinearEigenproblems.create_linsolver # Needed since we want overload it
function create_linsolver(::MyLinSolverCreator,nep,λ)
   return MyLinSolver(nep,λ);
end</code></pre><p>The rest of the implementation of the solver goes in the function <code>lin_solve</code>, where we utilize our function <code>schur_complement_lin_solve</code> from above.</p><pre><code class="language-julia">import NonlinearEigenproblems.LinSolvers.lin_solve # Needed since we want overload it
function lin_solve(solver::MyLinSolver,b::Vector;tol=eps())
   n0=10;
   return schur_complement_lin_solve(compute_Mder(solver.mynep,solver.myλ),b,n0)
end</code></pre><p>You can now solve the problem by passing a creator object of type <code>MyLinSolverCreator()</code> to a NEP-solver, e.g., <code>augnewton</code>:</p><pre><code class="language-julia-repl">julia&gt; dep=nep_gallery(&quot;dep0&quot;,50);
julia&gt; creator=MyLinSolverCreator();
julia&gt; augnewton(dep,v=ones(size(dep,1)),logger=1,linsolvercreator=creator);
iter 1 err:0.09618148118463332 λ=0.0 + 0.0im
iter 2 err:0.0413217667237937 λ=0.898990887813898 + 0.0im
iter 3 err:0.02631955794084684 λ=1.4448248571934017 + 0.0im
iter 4 err:0.00449344510220487 λ=0.9306146373776565 + 0.0im
iter 5 err:9.030138969728166e-5 λ=0.9176939995973337 + 0.0im
iter 6 err:9.801547301302623e-7 λ=0.9205599293430545 + 0.0im
iter 7 err:1.2125237229048776e-10 λ=0.9205883567517953 + 0.0im
iter 8 err:4.3151896277593487e-16 λ=0.9205883602865768 + 0.0im</code></pre><footer><hr/><a class="previous" href="../tutorial_newmethod/"><span class="direction">Previous</span><span class="title">Tutorial 9 (New solver)</span></a><a class="next" href="../hydrotutorial/"><span class="direction">Next</span><span class="title">Tutorial 11 (Orr-Somerfeld)</span></a></footer></article></body></html>
