<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 6 (MATLAB 1) · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../methods/">NEP Methods</a></li><li><a class="toctext" href="../types/">NEP Types</a></li><li><a class="toctext" href="../linsolvers/">LinSolver</a></li><li><a class="toctext" href="../errmeasure/">Error measure</a></li><li><a class="toctext" href="../logger/">Logger</a></li><li><a class="toctext" href="../transformations/">NEP Transformations</a></li><li><a class="toctext" href="../gallery/">NEP Gallery</a></li><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="toctext" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="toctext" href="../tutorial_call_python/">Tutorial 5 (Python NEP)</a></li><li class="current"><a class="toctext" href>Tutorial 6 (MATLAB 1)</a><ul class="internal"><li><a class="toctext" href="#A-problem-defined-in-MATLAB-1">A problem defined in MATLAB</a></li><li><a class="toctext" href="#Approach-1:-Implementation-in-NEP-PACK-(using-Mder_NEP)-1">Approach 1: Implementation in NEP-PACK (using <code>Mder_NEP</code>)</a></li><li><a class="toctext" href="#Approach-2:-Implementation-in-NEP-PACK-(using-new-type)-1">Approach 2: Implementation in NEP-PACK (using new type)</a></li></ul></li><li><a class="toctext" href="../tutorial_fortran1/">Tutorial 7 (FORTRAN 1)</a></li><li><a class="toctext" href="../tutorial_nano1/">Tutorial 8 (gmsh + nanophotonics)</a></li><li><a class="toctext" href="../tutorial_newmethod/">Tutorial 9 (New solver)</a></li><li><a class="toctext" href="../hydrotutorial/">Tutorial 10 (Orr-Somerfeld)</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Tutorial 6 (MATLAB 1)</a></li></ul><a class="edit-page" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/tutorial_matlab1.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial 6 (MATLAB 1)</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial:-Solving-NEP-defined-in-MATLAB-1" href="#Tutorial:-Solving-NEP-defined-in-MATLAB-1">Tutorial: Solving NEP defined in MATLAB</a></h1><h2><a class="nav-anchor" id="A-problem-defined-in-MATLAB-1" href="#A-problem-defined-in-MATLAB-1">A problem defined in MATLAB</a></h2><p>MATLAB is the de-facto standard language for many tasks in scientific computing. If you have a NEP defined in MATLAB, you can quite easily use the NEP-solvers of this package. Below is a description of two ways to solve nonlinear eigenvalue problems defined in MATLAB. There is a cost in terms of efficiency to define your problem in MATLAB, due to overhead associated with communication between the MATLAB and Julia processes. Very large scale problems are recommended to be defined directly in Julia.</p><p>Suppose you have the following NEP in MATLAB</p><div>\[M(\lambda)=A_0+\lambda A_1+\exp(\lambda A_2).\]</div><p>where (A<em>1,A</em>2,A<em>3) are martices and (\exp), the matrix exponential. The problem can be defined in MATLAB as follows. This is the contents of the file `compute</em>derivative_k.m<code>which computes derivative</code>k<code>evaluted in the point</code>s`</p><pre><code class="language-matlab">function Z=compute_derivative_k(s,k)
     randn(&#39;seed&#39;,0);
     n=10;
     A0=randn(n,n); A1=randn(n,n);
     Z=zeros(n,n);
     if (k==0)
         Z=A0+s*A1;
     end
     if (k==1)
         Z=A1;
     end
     Z=Z+(A1^k)*expm(s*A1);
end</code></pre><p>We assume in the following that the file <code>compute_derivative_k.m</code> is located in the current directory.</p><h2><a class="nav-anchor" id="Approach-1:-Implementation-in-NEP-PACK-(using-Mder_NEP)-1" href="#Approach-1:-Implementation-in-NEP-PACK-(using-Mder_NEP)-1">Approach 1: Implementation in NEP-PACK (using <code>Mder_NEP</code>)</a></h2><p>The easiest way to create a NEP which is only defined by its derivative computation is by the helper type <code>Mder_NEP</code>. It can be done with one line of code after loading the <a href="https://github.com/JuliaInterop/MATLAB.jl">MATLAB interoperability package</a>. </p><pre><code class="language-julia">julia&gt; using MATLAB
julia&gt; nep=Mder_NEP(10,(s,der) -&gt; mat&quot;compute_derivative_k($s,double($der))&quot;);</code></pre><p>The NEP can now be approached with many of the methods in the package, e.g., with a contour integral method</p><pre><code class="language-none">julia&gt; (λ,V)=contour_beyn(nep, radius=0.6, k=8);
julia&gt; λ
2-element Array{Complex{Float64},1}:
 0.17119547967719032 - 5.884238334653372e-15im
  0.1547216302712363 - 0.1663122058308301im   </code></pre><p>The first argument of the <code>Mder_NEP</code> instantiation is the size of the NEP. The instantiation of the <code>Mder_NEP</code> creates a NEP-object only defined by its matrix derivative functions, given in the call-back function specified by the second argument. In this case, the the function calls a  MATLAB process (running in the background completely hidden from the Julia user) and requests a execution of  <code>compute_derivate_k</code> with the given arguments. After executing the MATLAB-call, the MATLAB-process sends the matrix back to Julia. In other words, we have coupled the derivative computation of the NEP with a call to MATLAB. More precisely, every call to the <code>compute_Mder</code> function leads to a call to the created MATLAB function, and </p><pre><code class="language-julia">julia&gt; compute_Mder(nep,0.1+0.2im)
10×10 Array{Complex{Float64},2}:
   2.15543-0.101289im   ...   0.371533+0.544535im
  0.751339+0.213974im         -2.65352-0.308557im
 -0.177809-0.383021im         0.979515-0.603281im
  0.204312-0.300014im        -0.803364+0.652243im
 -0.378807+0.511258im          1.30005+0.562022im
   1.58041-0.266624im   ...  -0.691359+0.340299im
  0.105255+0.0940046im        0.445814-0.648929im
   1.47467-0.646341im          1.14153+0.576545im
  0.182295-0.143594im        -0.322912-0.219094im
  0.658504-0.190844im          1.25092-0.418521im</code></pre><p>is in background be the same as this MATLAB-call:</p><pre><code class="language-matlab">&gt;&gt; M=compute_derivative_k(0.1+0.2i,0);
&gt;&gt; M(1:3,1:3) % I don&#39;t want to see the whole matrix
ans =
   2.1554 - 0.1013i  -1.4933 - 0.0817i   0.1131 + 0.0836i
   0.7513 + 0.2140i   0.5326 + 0.3593i  -1.0211 - 0.5134i
  -0.1778 - 0.3830i   1.4694 + 0.3750i   0.2180 + 0.1720i</code></pre><p>You can verify that the output of the call to the <code>contour_beyn</code>-method is a solution directly in MATLAB:</p><pre><code class="language-matlab">&gt;&gt; s= 0.1547216302712363 - 0.1663122058308301i; % copied from the output above (remember: 1im -&gt; 1i) 
&gt;&gt; M=compute_derivative_k(s,0);
&gt;&gt; min(svd(M)) % Matrix is singular if s is a solution 
ans =
   1.7232e-15</code></pre><p>NEP-objects in NEP-PACK are defined from compute-functions (as we describe in <a href="../types/">NEPTypes</a>) and in this case we only defined the derivative computation function <code>compute_Mder</code>. Note that  the <code>Mder_NEP</code>-type provides default implementations of  <code>compute_Mlincomb</code> as well as <code>compute_MM</code> (by wrapping calls to <code>compute_Mder</code>) in a way that is hidden from the user, such that we can still use algorithms based on those compute functions.  More efficiency can be obtained if these compute functions are also implemented, e.g., by a different MATLAB-function. </p><h2><a class="nav-anchor" id="Approach-2:-Implementation-in-NEP-PACK-(using-new-type)-1" href="#Approach-2:-Implementation-in-NEP-PACK-(using-new-type)-1">Approach 2: Implementation in NEP-PACK (using new type)</a></h2><p>We illustrate the extendability of the package by defining our own type, which again uses the MATLAB-package in the background.</p><p>The size is hardcoded in this example, so we can define a new type of the specific size:</p><pre><code class="language-julia">struct MATLABNEP &lt;: NEP
end
Base.size(nep::MATLABNEP) = (10,10)
Base.size(nep::MATLABNEP,::Int) = 10</code></pre><p>Initiate the MATLAB package and prepare to integrate with NEP-PACK:</p><pre><code class="language-julia">julia&gt; using MATLAB; # requires MATLAB to be installed
julia&gt; mat&quot;addpath(&#39;.&#39;)&quot; # Add path to your m-file
julia&gt; import NonlinearEigenproblems.compute_Mder;
julia&gt; import NonlinearEigenproblems.compute_Mlincomb;
julia&gt; import NonlinearEigenproblems.compute_Mlincomb_from_Mder;</code></pre><p>In this example, the problem is only provided by a function to compute derivatives of <code>M</code>, which we specify by defining a  <code>compute_Mder</code> function. We also specify that linear combinations of derivatives should be computed by calling <code>compute_Mder</code> in the naive way:</p><pre><code class="language-julia">function compute_Mder(::MATLABNEP,s::Number,der::Integer=0)
    return mat&quot;compute_derivative_k(double($s),double($der))&quot;
end
compute_Mlincomb(nep::MATLABNEP,λ::Number,V::AbstractVecOrMat, a::Vector) = compute_Mlincomb_from_Mder(nep,λ,V,a)
compute_Mlincomb(nep::MATLABNEP,λ::Number,V::AbstractVecOrMat) = compute_Mlincomb(nep,λ,V, ones(eltype(V),size(V,2)))</code></pre><p>Now you can instantiate the NEP and use your favorite NEP-solver, in this case we use <a href="../methods/#NonlinearEigenproblems.NEPSolver.newtonqr"><code>newtonqr</code></a>.</p><pre><code class="language-julia">julia&gt; nep=MATLABNEP();
julia&gt; (λ,v)=newtonqr(nep,λ=-3,logger=1,maxit=30,v=ones(10))
iter 1 err:1.033593309412195 λ=-3.0 + 0.0im
iter 2 err:0.3059246224011592 λ=0.83641207310996 + 0.0im
iter 3 err:0.6000405834026614 λ=-1.7728647881500432 + 0.0im
iter 4 err:0.07375061614602237 λ=-0.7800560594951582 + 0.0im
iter 5 err:0.0093516562758152 λ=-0.8707521093182906 + 0.0im
iter 6 err:8.954564848847882e-5 λ=-0.8840785307305598 + 0.0im
iter 7 err:7.446596609664408e-9 λ=-0.88420751056806 + 0.0im
iter 8 err:1.0942739518352825e-15 λ=-0.884207521294992 + 0.0im
(-0.884207521294992 + 0.0im, Complex{Float64}[0.544936+0.0im, 0.641218+0.0im, 0.089366+0.0im, -0.0975048+0.0im, 0.133397+0.0im, 1.0+0.0im, -0.836009+0.0im, -0.00753176+0.0im, 0.270149+0.0im, -0.664448+0.0im], [0.354722, -0.0659026, -0.465767, 0.079273, -0.524316, -0.372411, -0.0129146, -0.386585, -0.140157, 0.252488])</code></pre><p>The residual is small and we have a solution</p><pre><code class="language-julia">julia&gt; using LinearAlgebra
julia&gt; norm(compute_Mlincomb(nep,λ,v))/norm(v)
1.0942739518352825e-15</code></pre><p><img src="http://jarlebring.se/onepixel.png?NEPPACKDOC_MATLAB1" alt="To the top"/></p><footer><hr/><a class="previous" href="../tutorial_call_python/"><span class="direction">Previous</span><span class="title">Tutorial 5 (Python NEP)</span></a><a class="next" href="../tutorial_fortran1/"><span class="direction">Next</span><span class="title">Tutorial 7 (FORTRAN 1)</span></a></footer></article></body></html>
