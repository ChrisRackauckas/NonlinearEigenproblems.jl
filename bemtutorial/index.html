<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 3 (BEM) · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../methods/">NEP-Solvers</a></li><li><a class="toctext" href="../types/">NEP Types</a></li><li><a class="toctext" href="../compute_functions/">Compute functions</a></li><li><a class="toctext" href="../linsolvers/">LinSolvers</a></li><li><a class="toctext" href="../innersolvers/">Projection</a></li><li><a class="toctext" href="../errmeasure/">Measuring the error</a></li><li><a class="toctext" href="../logger/">Logger</a></li><li><a class="toctext" href="../transformations/">Transformations.</a></li><li><a class="toctext" href="../deflation/">Deflation</a></li><li><a class="toctext" href="../gallery/">Gallery</a></li></ul></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li class="current"><a class="toctext" href>Tutorial 3 (BEM)</a><ul class="internal"><li><a class="toctext" href="#Boundary-element-method-1">Boundary element method</a></li><li><a class="toctext" href="#Manual-implementation-in-NEP-PACK-1">Manual implementation in NEP-PACK</a></li><li><a class="toctext" href="#Solving-the-NEP-1">Solving the NEP</a></li><li><a class="toctext" href="#Implementation-in-NEP-PACK-using-the-Mder_NEP-type-1">Implementation in NEP-PACK using the <code>Mder_NEP</code> type</a></li></ul></li><li><a class="toctext" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="toctext" href="../tutorial_call_python/">Tutorial 5 (Python)</a></li><li><a class="toctext" href="../tutorial_matlab1/">Tutorial 6 (MATLAB)</a></li><li><a class="toctext" href="../tutorial_fortran1/">Tutorial 7 (FORTRAN)</a></li><li><a class="toctext" href="../tutorial_nano1/">Tutorial 8 (gmsh + nanophotonics)</a></li><li><a class="toctext" href="../tutorial_newmethod/">Tutorial 9 (New solver)</a></li><li><a class="toctext" href="../tutorial_linsolve/">Tutorial 10 (Linear solvers)</a></li><li><a class="toctext" href="../hydrotutorial/">Tutorial 11 (Orr-Somerfeld)</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href>Tutorial 3 (BEM)</a></li></ul><a class="edit-page" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/bemtutorial.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial 3 (BEM)</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial:-User-defined-matrices-boundary-element-method-1" href="#Tutorial:-User-defined-matrices-boundary-element-method-1">Tutorial: User-defined matrices - boundary element method</a></h1><p>Suppose you have a new type of NEP, which does not naturally fit into the standard types in NEP-PACK. This tutorial shows how you can define a NEP where the only way to access the NEP is a function to compute <span>$M^{(k)}(λ)$</span>. We first show the manual way to do it, as it illustrates some of the workings of NEP-PACK. However, the use case is common enough to have native support in NEP-PACK. Hence, we also show how to use a special NEP-type called <code>Mder_NEP</code>.</p><p>For this example we use a <a href="https://en.wikipedia.org/wiki/Boundary_element_method">boundary element method</a> approach for computation of resonances. The complete code is available in <code>gallery_extra/bem_hardcoded</code>. The example is also available as a gallery problem: <code>nep=nep_gallery(&quot;bem_fichera&quot;)</code>.</p><h2><a class="nav-anchor" id="Boundary-element-method-1" href="#Boundary-element-method-1">Boundary element method</a></h2><p>The boundary element method applied to Helmholtz eigenvalue problem can be described by the matrix consisting of elements</p><div>\[[M(λ)]_{ij}=\frac{1}{4\pi}\int_{\Delta_i}\int_{\Delta_j}\frac{e^{\iota\lambda\|\xi-\eta\|}}{\|\xi-\eta\|}dS(\eta)dS(\xi)\]</div><p>where <span>$\Delta_i$</span>, <span>$i=1,\ldots,n$</span> are boundary elements. The boundary element approach is available through three functions: <code>gen_ficheramesh</code> to compute the mesh, <code>precompute_quad!</code> to precompute the quadrature coeeficients, and <code>assemble_BEM</code> to compute the matrix consisting of all the integrals corresponding to <code>λ</code>. These functions are based on the model (and inspired by some of the code) in <a href="http://sma.epfl.ch/~anchpcommon/students/steinlechner.pdf">&quot;A boundary element method for solving PDE eigenvalue problems&quot;, Steinlechner, bachelor thesis, ETH Zürich, 2010</a> and also used in the simulations in <a href="https://link.springer.com/article/10.1007/s10543-012-0381-5">&quot;Chebyshev interpolation for nonlinear eigenvalue problems&quot;, Effenberger, Kressner, BIT Numerical Mathematics, 2012, Volume 52, Issue 4, pp 933–951</a>.</p><p>To get access to the helper functions you need either to work in the <code>gallery_extra/bem_hardcoded</code>-directory, or copy the files in there to your current working directory. The code can also be found <a href="https://github.com/nep-pack/NonlinearEigenproblems.jl/tree/master/src/gallery_extra/bem_hardcoded">directly on github</a>. We start by loading the necessary code:</p><pre><code class="language-julia-repl">julia&gt; using NonlinearEigenproblems;
julia&gt; include(&quot;triangle.jl&quot;);
julia&gt; include(&quot;genmesh.jl&quot;);
julia&gt; include(&quot;assemble_BEM.jl&quot;);</code></pre><h2><a class="nav-anchor" id="Manual-implementation-in-NEP-PACK-1" href="#Manual-implementation-in-NEP-PACK-1">Manual implementation in NEP-PACK</a></h2><p>In order to define your new NEP you need to define a new NEP-type</p><pre><code class="language-julia-repl">julia&gt; struct BEM_NEP &lt;: NEP
    mesh::Vector{Triangle}
    n::Int
    gauss_order::Int
    function BEM_NEP(mesh,gauss_order)
        return new(mesh,length(mesh),gauss_order)
    end
end</code></pre><p>The <code>mesh</code> variable is a vector of triangle objects defining the domain, <code>n</code> is the size of the mesh and <code>gauss_order</code> the quadrature order. All NEPs have to define <code>size()</code> functions</p><pre><code class="language-julia-repl">julia&gt; import Base.size; # Import from Base explicitly since we overload

julia&gt; function size(nep::BEM_NEP)
    return (nep.n,nep.n);
end
size (generic function with 142 methods)
julia&gt; function size(nep::BEM_NEP,dim)
    return nep.n;
end
size (generic function with 143 methods)</code></pre><p>The function <code>assemble_BEM</code> computes the matrix defined by the integrals. Hence, we need to call this function for every call to <code>compute_Mder</code>:</p><pre><code class="language-julia-repl">julia&gt; import NonlinearEigenproblems.NEPCore.compute_Mder # We overload the function
julia&gt; function compute_Mder(nep::BEM_NEP,λ::Number,der::Int=0)
    return assemble_BEM(λ, nep.mesh, nep.gauss_order, der)[:,:,1];
end
compute_Mder (generic function with 42 methods)</code></pre><p>In order to make other compute functions available to the methods, we can use the conversion functions. In particular, the <code>compute_Mlincomb</code> function can be implemented by making several calls in <code>compute_Mder</code>. This is done in the NEP-PACK-provided helper function <code>compute_Mlincomb_from_Mder</code>. We make this the default behaviour for this NEP:</p><pre><code class="language-julia-repl">julia&gt; import NonlinearEigenproblems.NEPCore.compute_Mlincomb # Since we overload
# Delegate the compute Mlincomb functions. This can be quite inefficient.
julia&gt; compute_Mlincomb(nep::BEM_NEP,λ::Number,V::AbstractVecOrMat, a::Vector) =
      compute_Mlincomb_from_Mder(nep,λ,V,a)
compute_Mlincomb (generic function with 36 methods)
julia&gt; compute_Mlincomb(nep::BEM_NEP,λ::Number,V::AbstractVecOrMat) =
      compute_Mlincomb(nep,λ,V, ones(eltype(V),size(V,2)))
compute_Mlincomb (generic function with 37 methods)</code></pre><p>We can now create a <code>BEM_NEP</code> as follows:</p><pre><code class="language-julia-repl">julia&gt; gauss_order=3; N=5;
julia&gt; mymesh=gen_ficheramesh(N);
julia&gt; precompute_quad!(mymesh,gauss_order);
julia&gt; nep=BEM_NEP(mymesh,gauss_order);</code></pre><h2><a class="nav-anchor" id="Solving-the-NEP-1" href="#Solving-the-NEP-1">Solving the NEP</a></h2><p>After creating the NEP, you can try to solve the problem with methods in the package, e.g., <a href="../methods/#NonlinearEigenproblems.NEPSolver.mslp"><code>MSLP</code></a> works quite well for this problem:</p><pre><code class="language-julia-repl">julia&gt; (λ,v)=mslp(nep,λ=8,logger=1);
iter 1 err:4.122635537095191e-6 λ=8.128272919317748 + 0.007584851218213724im
iter 2 err:1.787963303966838e-8 λ=8.132181234599429 - 1.952792817333862e-5im
iter 3 err:3.2884911876526185e-13 λ=8.132145310156645 - 1.2648247030082216e-5im
iter 4 err:4.417989064002117e-18 λ=8.132145310195458 - 1.264891803723658e-5im</code></pre><p>This is the computed solution:</p><br>
<img src="https://user-images.githubusercontent.com/11163595/49595409-324b7d80-f978-11e8-818d-eeeaf9441505.png" height=450><p>The plotting was done with the following code (by using internals of the BEM-implementation):</p><pre><code class="language-julia-repl">julia&gt; using PyPlot
julia&gt; v=v./maximum(abs.(v));
julia&gt; for k=1:size(nep.mesh,1);
    tri=nep.mesh[k];
    col=[1-abs.(v)[k];0;0]; # plot abslolute value
    X=[tri.P1[1] tri.P2[1]; tri.P3[1] tri.P3[1]];
    Y=[tri.P1[2] tri.P2[2]; tri.P3[2] tri.P3[2]];
    Z=[tri.P1[3] tri.P2[3]; tri.P3[3] tri.P3[3]];
    plot_surface(X,Y,Z,color=col,alpha=0.8);
    plot_wireframe(X,Y,Z,color=[0;0;0],linewidth=1,alpha=0.5,);
end</code></pre><h2><a class="nav-anchor" id="Implementation-in-NEP-PACK-using-the-Mder_NEP-type-1" href="#Implementation-in-NEP-PACK-using-the-Mder_NEP-type-1">Implementation in NEP-PACK using the <code>Mder_NEP</code> type</a></h2><p>Some of the manual implementation can be avoided by using the <code>Mder_NEP</code> type. We only need to pass the size of the NEP and a function to compute <span>$M^{(k)}(λ)$</span>, i.e., <code>(λf,derf) -&gt; assemble_BEM(λf, mymesh, gauss_order, derf)[:,:,1]</code>, to the <code>Mder_NEP</code>.</p><pre><code class="language-julia-repl">julia&gt; n = length(mymesh);
julia&gt; mdernep = Mder_NEP(n, (λf,derf) -&gt; assemble_BEM(λf, mymesh, gauss_order, derf)[:,:,1]);
julia&gt; (mderλ,mderv)=mslp(mdernep,λ=8,logger=1);
iter 1 err:4.122635537095191e-6 λ=8.128272919317748 + 0.007584851218213724im
iter 2 err:1.787963303966838e-8 λ=8.132181234599429 - 1.952792817333862e-5im
iter 3 err:3.2884911876526185e-13 λ=8.132145310156645 - 1.2648247030082216e-5im
iter 4 err:4.417989064002117e-18 λ=8.132145310195458 - 1.264891803723658e-5im
julia&gt; λ-mderλ
0.0 + 0.0im</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The above code executes under the assumption that the following code had been run:</p><pre><code class="language-julia">precompute_quad!(mymesh,gauss_order);</code></pre></div></div><p><img src="http://jarlebring.se/onepixel.png?NEPPACKDOC_BEMTUTORIAL" alt="To the top"/></p><footer><hr/><a class="previous" href="../tutorial_contour/"><span class="direction">Previous</span><span class="title">Tutorial 2 (Contour)</span></a><a class="next" href="../deflate_tutorial/"><span class="direction">Next</span><span class="title">Tutorial 4 (Deflation)</span></a></footer></article></body></html>
