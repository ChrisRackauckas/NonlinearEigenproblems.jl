<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Inner solvers · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../methods/">NEP Methods</a></li><li><a class="toctext" href="../types/">NEPTypes</a></li><li><a class="toctext" href="../linsolvers/">LinSolvers</a></li><li class="current"><a class="toctext" href>Inner solvers</a><ul class="internal"><li><a class="toctext" href="#Inner-solvers-2">Inner solvers</a></li><li><a class="toctext" href="#Advanced-usage-1">Advanced usage</a></li></ul></li><li><a class="toctext" href="../errmeasure/">Measuring the error</a></li><li><a class="toctext" href="../logger/">Logger</a></li><li><a class="toctext" href="../transformations/">Transforming NEPs</a></li><li><a class="toctext" href="../gallery/">The Gallery function</a></li></ul></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="toctext" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="toctext" href="../tutorial_call_python/">Tutorial 5 (Python NEP)</a></li><li><a class="toctext" href="../tutorial_matlab1/">Tutorial 6 (MATLAB 1)</a></li><li><a class="toctext" href="../tutorial_fortran1/">Tutorial 7 (FORTRAN 1)</a></li><li><a class="toctext" href="../tutorial_nano1/">Tutorial 8 (gmsh + nanophotonics)</a></li><li><a class="toctext" href="../tutorial_newmethod/">Tutorial 9 (New solver)</a></li><li><a class="toctext" href="../tutorial_linsolve/">Tutorial 10 (Linear solvers)</a></li><li><a class="toctext" href="../hydrotutorial/">Tutorial 11 (Orr-Somerfeld)</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Inner solvers</a></li></ul><a class="edit-page" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/innersolvers.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Inner solvers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Inner-solvers-1" href="#Inner-solvers-1">Inner solvers</a></h1><p>Many NEP-solvers are based on a computation of a  projected problem, i.e., if <span>$V,W\in\mathbb{R}^{n\times p}$</span> we need to solve the (smaller) NEP</p><div>\[W^HM(λ)Vz=0\]</div><p>This is sometimes called a nonlinear Rayleigh-Ritz procedure, or a direct projection.</p><p>NEP-PACK provides a framework to handle projected problems. You can in principle use any of the NEP-solvers to solve a projected problem. As a user, this is specified in the <code>inner_solver_method</code> keyword argument.</p><p>If you wish to use the infinite Arnoldi method to handle the project solves in the nonlinear Arnoldi method, you can do the following:</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0_tridiag&quot;);
julia&gt; λ,v=nlar(nep,neigs=1,inner_solver_method=IARInnerSolver(),logger=1);
Using inner solver IARInnerSolver(1.0e-13, 80, :ones, false, NonlinearEigenproblems.NEPSolver.iar)
iter 1 err:0.05095382004494062 λ=0.7579134426195271 - 0.03707164055891316im
iter 2 err:0.00031997693290503965 λ=-0.00010049358638757657 + 0.0001763732030940319im
iter 3 err:6.563177508431498e-6 λ=-0.0005335154073888051 - 4.498082881742902e-6im
iter 4 err:8.037612383023366e-9 λ=-0.0005259618179586685 + 2.806438064753968e-9im
iter 5 err:3.386041718599221e-11 λ=-0.0005259683064505526 + 1.3119844096548209e-11im
iter 6 err:3.4499779767886924e-13 λ=-0.0005259682927702825 - 1.0404412824030558e-13im
iter 7 err:5.365662696809372e-15 λ=-0.0005259682929434785 - 2.0247938561528697e-17im
****** 1 converged to eigenvalue: -0.0005259682929434785 - 2.0247938561528697e-17im errmeasure:5.365662696809372e-15</code></pre><p>The logging of the inner solver is controlled by the kwarg <code>inner_logger</code>. This produces very verbose output illustrating also the convergence of the inner solve:</p><pre><code class="language-julia-repl">julia&gt; λ,v=nlar(nep,neigs=1,inner_solver_method=IARInnerSolver(),logger=1,inner_logger=1);
Using inner solver IARInnerSolver(1.0e-13, 80, :ones, false, NonlinearEigenproblems.NEPSolver.iar)
-
--
---
----
-----
------
-------
--------
---------
----------
-----------
------------
=------------
+-------------
iter 1 err:0.04860520921206162 λ=0.8437634284420165 + 0.005742468974957178im
-
--
---
+---
iter 2 err:0.0008771218464072076 λ=-0.00065275394814732 - 0.0008601482370586537im
-
--
---
...</code></pre><h2><a class="nav-anchor" id="Inner-solvers-2" href="#Inner-solvers-2">Inner solvers</a></h2><p>The inner solvers inherit from <code>InnerSolver</code>. The following inner solvers are available by default.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.NewtonInnerSolver" href="#NonlinearEigenproblems.NEPSolver.NewtonInnerSolver"><code>NonlinearEigenproblems.NEPSolver.NewtonInnerSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct NewtonInnerSolver
function NewtonInnerSolver(;tol=1e-13,maxit=80,starting_vector=:Vk,
                           newton_function=augnewton)</code></pre><p>Uses a Newton-like method to solve the inner problem, with tolerance, and maximum number of iterations given by <code>tol</code> and <code>maxit</code>. The starting vector can be <code>:ones</code>, <code>:randn</code>, or <code>:Vk</code>. The value <code>:Vk</code> specifies the use of the super NEP-solver keyword argument (<code>Vk</code>). This is typically the previous iterate in the outer method.</p><p>The kwarg <code>newton_function</code>, specifies a <code>Function</code> which is called. We support <code>augnewton</code>, <code>newton</code>, <code>resinv</code> <code>quasinewton</code>, <code>newtonqr</code>. In principle it can be any method which takes the same keyword arguments as these methods.</p><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.IARInnerSolver" href="#NonlinearEigenproblems.NEPSolver.IARInnerSolver"><code>NonlinearEigenproblems.NEPSolver.IARInnerSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct IARInnerSolver
IARInnerSolver(;tol=1e-13,maxit=80,starting_vector=:ones,normalize_DEPs=:auto)</code></pre><p>Uses <a href="../methods/#NonlinearEigenproblems.NEPSolver.iar"><code>iar</code></a> to solve the inner problem, with tolerance, and maximum number of iterations given by <code>tol</code> and <code>maxit</code>. The starting vector can be <code>:ones</code> or <code>:randn</code>. <code>normalize_DEPs</code> determines if the we should carry out precomputation of DEPs (can speed up performance). It can take the value <code>true</code>, <code>false</code> or <code>:auto</code>. <code>:auto</code> sets it to true if we use the <code>iar_chebyshev</code> solver.</p><p>The kwarg <code>iar_function</code>, specifies a <code>Function</code> which is called. Examples of functions are <code>iar</code> and <code>iar_chebyshev</code>. It can be any NEP-solver which takes the same keyword arguments as these methods.</p><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a></p></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>IARChebshevInnerSolver</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.ContourBeynInnerSolver" href="#NonlinearEigenproblems.NEPSolver.ContourBeynInnerSolver"><code>NonlinearEigenproblems.NEPSolver.ContourBeynInnerSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct ContourBeynInnerSolver &lt;: InnerSolver</code></pre><p>Uses <a href="../methods/#NonlinearEigenproblems.NEPSolver.contour_beyn"><code>contour_beyn</code></a> to solve the inner problem, with radius and number of quadrature nodes, given by <code>radius</code> and <code>n</code>. If the variable <code>radius</code> is set to <code>:auto</code>, the integration radius will be automatically by using the eigenvalues approximations.</p><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.PolyeigInnerSolver" href="#NonlinearEigenproblems.NEPSolver.PolyeigInnerSolver"><code>NonlinearEigenproblems.NEPSolver.PolyeigInnerSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct PolyeigInnerSolver &lt;: InnerSolver</code></pre><p>For polynomial eigenvalue problems. Uses <a href="../methods/#NonlinearEigenproblems.NEPSolver.polyeig"><code>polyeig</code></a> to solve the inner problem.</p><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.SGIterInnerSolver" href="#NonlinearEigenproblems.NEPSolver.SGIterInnerSolver"><code>NonlinearEigenproblems.NEPSolver.SGIterInnerSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct SGIterInnerSolver &lt;: InnerSolver</code></pre><p>Uses <a href="../methods/#NonlinearEigenproblems.NEPSolver.sgiter"><code>sgiter</code></a> to solve the inner problem.</p><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a></p></div></div></section><h2><a class="nav-anchor" id="Advanced-usage-1" href="#Advanced-usage-1">Advanced usage</a></h2><p>You can define your own inner solver by inheriting from <code>InnerSolver</code> and implementing the function <code>inner_solve</code>. Since the <code>inner_solve</code> obtains information from the solver via keyword arguments, you need to end your method signature with <code>kwargs...)</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.InnerSolver" href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>NonlinearEigenproblems.NEPSolver.InnerSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type InnerSolver</code></pre><p>Structs inheriting from this type are used to solve inner problems in an inner-outer iteration.</p><p>The <code>InnerSolver</code> objects are passed to the NEP-algorithms, which uses it to dispatch the correct version of the function <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a>. Utilizes existing implementations of NEP-solvers and <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a> acts as a wrapper to these.</p><p><strong>Example</strong></p><p>There is a <a href="@ref"><code>DefaultInnerSolver</code></a> that dispatches an inner solver based on the provided NEP. However, this example shows how you can force <a href="../methods/#NonlinearEigenproblems.NEPSolver.nlar"><code>nlar</code></a> to use the <a href="#NonlinearEigenproblems.NEPSolver.IARInnerSolver"><code>IARInnerSolver</code></a> for a PEP.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;pep0&quot;, 100);
julia&gt; λ,v = nlar(nep, inner_solver_method=NEPSolver.IARInnerSolver(), neigs=1, num_restart_ritz_vecs=1, maxit=70, tol=1e-8);
julia&gt; norm(compute_Mlincomb(nep,λ[1],vec(v)))
8.68118417430353e-9</code></pre><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a>, <a href="@ref"><code>DefaultInnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.NewtonInnerSolver"><code>NewtonInnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.PolyeigInnerSolver"><code>PolyeigInnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.IARInnerSolver"><code>IARInnerSolver</code></a>, <a href="@ref"><code>IARChebInnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.SGIterInnerSolver"><code>SGIterInnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.ContourBeynInnerSolver"><code>ContourBeynInnerSolver</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.inner_solve" href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>NonlinearEigenproblems.NEPSolver.inner_solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">inner_solve(is::InnerSolver,T_arit,nep;kwargs...)</code></pre><p>Solves the projected linear problem with solver specied with <code>is</code>. This is to be used as an inner solver in an inner-outer iteration. T specifies which method to use. The most common choice is <a href="@ref"><code>DefaultInnersolver</code></a>. The function returns <code>(λv,V)</code> where <code>λv</code> is an array of eigenvalues and <code>V</code> a matrix with corresponding vectors. The struct <code>T_arit</code> defines the arithmetics used in the outer iteration and should prefereably also be used in the inner iteration.</p><p>Different inner_solve methods take different kwargs. These are standardized kwargs:</p><ul><li><code>neigs</code>: Number of wanted eigenvalues (but less or more may be returned)</li><li><code>σ</code>: target specifying where eigenvalues</li><li><code>λv</code>, <code>V</code>: Vector/matrix of guesses to be used as starting values</li><li><code>j</code>: the jth eigenvalue in a min-max characterization</li><li><code>tol</code>: Termination tolarance for inner solver</li><li><code>inner_logger</code>: Determines how the inner solves are logged. See <a href="../logger/#NonlinearEigenproblems.NEPSolver.Logger"><code>Logger</code></a> for further references</li></ul></div></div></section><footer><hr/><a class="previous" href="../linsolvers/"><span class="direction">Previous</span><span class="title">LinSolvers</span></a><a class="next" href="../errmeasure/"><span class="direction">Next</span><span class="title">Measuring the error</span></a></footer></article></body></html>
