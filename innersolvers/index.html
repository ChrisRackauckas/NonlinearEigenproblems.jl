<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Projection · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../methods/">NEP-Solvers</a></li><li><a class="toctext" href="../types/">NEP Types</a></li><li><a class="toctext" href="../compute_functions/">Compute functions</a></li><li><a class="toctext" href="../linsolvers/">LinSolvers</a></li><li class="current"><a class="toctext" href>Projection</a><ul class="internal"><li><a class="toctext" href="#Inner-solvers-1">Inner solvers</a></li><li><a class="toctext" href="#Advanced-usage-1">Advanced usage</a></li><li><a class="toctext" href="#Rayleigh-functional-computation-1">Rayleigh functional computation</a></li><li><a class="toctext" href="#Projection-types-1">Projection types</a></li><li><a class="toctext" href="#Types-1">Types</a></li><li><a class="toctext" href="#Associated-functions-1">Associated functions</a></li></ul></li><li><a class="toctext" href="../errmeasure/">Measuring the error</a></li><li><a class="toctext" href="../logger/">Logger</a></li><li><a class="toctext" href="../transformations/">Transformations.</a></li><li><a class="toctext" href="../deflation/">Deflation</a></li><li><a class="toctext" href="../gallery/">Gallery</a></li></ul></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="toctext" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="toctext" href="../tutorial_call_python/">Tutorial 5 (Python)</a></li><li><a class="toctext" href="../tutorial_matlab1/">Tutorial 6 (MATLAB)</a></li><li><a class="toctext" href="../tutorial_fortran1/">Tutorial 7 (FORTRAN)</a></li><li><a class="toctext" href="../tutorial_nano1/">Tutorial 8 (gmsh + nanophotonics)</a></li><li><a class="toctext" href="../tutorial_newmethod/">Tutorial 9 (New solver)</a></li><li><a class="toctext" href="../tutorial_linsolve/">Tutorial 10 (Linear solvers)</a></li><li><a class="toctext" href="../hydrotutorial/">Tutorial 11 (Orr-Somerfeld)</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Projection</a></li></ul><a class="edit-page" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/innersolvers.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Projection</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Projection-1" href="#Projection-1">Projection</a></h1><p>Many NEP-solvers are based on a computation of a  projected problem, i.e., if <span>$V,W\in\mathbb{R}^{n\times p}$</span> we need to solve the (smaller) NEP</p><div>\[W^HM(λ)Vz=0\]</div><p>This is sometimes called a nonlinear Rayleigh-Ritz procedure, or a direct projection. These are <em>inner solvers</em> for many problems.</p><p>NEP-PACK provides a framework to handle projected problems and inner solves. You can in principle use any of the NEP-solvers to solve a projected problem. As a user, this is specified in the <code>inner_solver_method</code> keyword argument in those NEP-solvers that use a direct projection. By default <a href="#NonlinearEigenproblems.NEPSolver.DefaultInnerSolver"><code>DefaultInnerSolver</code></a> is used.</p><p>If you wish to use the infinite Arnoldi method to handle the project solves in the nonlinear Arnoldi method, you can do the following:</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0_tridiag&quot;);
julia&gt; λ,v=nlar(nep,neigs=1,inner_solver_method=IARInnerSolver(),logger=1);
Using inner solver IARInnerSolver(1.0e-13, 80, :ones, false, NonlinearEigenproblems.NEPSolver.iar)
iter 1 err:0.05095382004494062 λ=0.7579134426195271 - 0.03707164055891316im
iter 2 err:0.00031997693290503965 λ=-0.00010049358638757657 + 0.0001763732030940319im
iter 3 err:6.563177508431498e-6 λ=-0.0005335154073888051 - 4.498082881742902e-6im
iter 4 err:8.037612383023366e-9 λ=-0.0005259618179586685 + 2.806438064753968e-9im
iter 5 err:3.386041718599221e-11 λ=-0.0005259683064505526 + 1.3119844096548209e-11im
iter 6 err:3.4499779767886924e-13 λ=-0.0005259682927702825 - 1.0404412824030558e-13im
iter 7 err:5.365662696809372e-15 λ=-0.0005259682929434785 - 2.0247938561528697e-17im
****** 1 converged to eigenvalue: -0.0005259682929434785 - 2.0247938561528697e-17im errmeasure:5.365662696809372e-15</code></pre><p>The logging of the inner solver is controlled by the kwarg <code>inner_logger</code>. This produces very verbose output illustrating also the convergence of the inner solve:</p><pre><code class="language-julia-repl">julia&gt; λ,v=nlar(nep,neigs=1,inner_solver_method=IARInnerSolver(),logger=1,inner_logger=1);
Using inner solver IARInnerSolver(1.0e-13, 80, :ones, false, NonlinearEigenproblems.NEPSolver.iar)
-
--
---
----
-----
------
-------
--------
---------
----------
-----------
------------
=------------
+-------------
iter 1 err:0.04860520921206162 λ=0.8437634284420165 + 0.005742468974957178im
-
--
---
+---
iter 2 err:0.0008771218464072076 λ=-0.00065275394814732 - 0.0008601482370586537im
-
--
---
...</code></pre><h2><a class="nav-anchor" id="Inner-solvers-1" href="#Inner-solvers-1">Inner solvers</a></h2><p>The inner solvers inherit from <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>. The following inner solvers are available by default.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.NewtonInnerSolver" href="#NonlinearEigenproblems.NEPSolver.NewtonInnerSolver"><code>NonlinearEigenproblems.NEPSolver.NewtonInnerSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct NewtonInnerSolver
function NewtonInnerSolver(;tol=1e-13,maxit=80,starting_vector=:Vk,
                           newton_function=augnewton)</code></pre><p>Uses a Newton-like method to solve the inner problem, with tolerance, and maximum number of iterations given by <code>tol</code> and <code>maxit</code>. The starting vector can be <code>:ones</code>, <code>:randn</code>, or <code>:Vk</code>. The value <code>:Vk</code> specifies the use of the outer NEP-solver keyword argument (<code>Vk</code>). This is typically the previous iterate in the outer method.</p><p>The kwarg <code>newton_function</code>, specifies a <code>Function</code> which is called. The type supports <a href="../methods/#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a>, <a href="../methods/#NonlinearEigenproblems.NEPSolver.newton"><code>newton</code></a>, <a href="../methods/#NonlinearEigenproblems.NEPSolver.resinv"><code>resinv</code></a> <a href="../methods/#NonlinearEigenproblems.NEPSolver.quasinewton"><code>quasinewton</code></a>, <a href="../methods/#NonlinearEigenproblems.NEPSolver.newtonqr"><code>newtonqr</code></a>. In principle it can be any method which takes the same keyword arguments as these methods.</p><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.IARInnerSolver" href="#NonlinearEigenproblems.NEPSolver.IARInnerSolver"><code>NonlinearEigenproblems.NEPSolver.IARInnerSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct IARInnerSolver
function IARInnerSolver(;tol=1e-13,maxit=80,
           starting_vector=:ones,normalize_DEPs=:auto,
           iar_function=iar)</code></pre><p>Uses <a href="../methods/#NonlinearEigenproblems.NEPSolver.iar"><code>iar</code></a>, <a href="../methods/#NonlinearEigenproblems.NEPSolver.tiar"><code>tiar</code></a> or <a href="../methods/#NonlinearEigenproblems.NEPSolver.iar_chebyshev"><code>iar_chebyshev</code></a> to solve the inner problem, with tolerance, and maximum number of iterations given by <code>tol</code> and <code>maxit</code>. The starting vector can be <code>:ones</code> or <code>:randn</code>. The <code>iar_function</code> can be <code>iar</code>, <code>tiar</code> or <code>iar_chebyshev</code> (or any function taking the same parameters as input). <code>normalize_DEPs</code> determines if the we should carry out precomputation and make sure the projection of a <a href="../types/#NonlinearEigenproblems.NEPTypes.DEP"><code>DEP</code></a>  is again a <code>DEP</code> (which can speed up performance). It can take the value <code>true</code>, <code>false</code> or <code>:auto</code>. <code>:auto</code> sets it to true if we use the <code>iar_chebyshev</code> solver.</p><p>The kwarg <code>iar_function</code>, specifies a <code>Function</code> which is called. Examples of functions are <code>iar</code> and <code>iar_chebyshev</code>. It can be any NEP-solver which takes the same keyword arguments as these methods.</p><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.IARChebInnerSolver" href="#NonlinearEigenproblems.NEPSolver.IARChebInnerSolver"><code>NonlinearEigenproblems.NEPSolver.IARChebInnerSolver</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function IARChebInnerSolver(;tol=1e-13,maxit=80,starting_vector=:ones,
                            normalize_DEPs=true)</code></pre><p>Uses <a href="../methods/#NonlinearEigenproblems.NEPSolver.iar_chebyshev"><code>iar_chebyshev</code></a> to solve the inner problem. See <a href="#NonlinearEigenproblems.NEPSolver.IARInnerSolver"><code>IARInnerSolver</code></a> for keyword argument documentation.</p><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.IARInnerSolver"><code>IARInnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.ContourBeynInnerSolver" href="#NonlinearEigenproblems.NEPSolver.ContourBeynInnerSolver"><code>NonlinearEigenproblems.NEPSolver.ContourBeynInnerSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct ContourBeynInnerSolver &lt;: InnerSolver
function ContourBeynInnerSolver(;tol=sqrt(eps(real(Float64))),
                                radius=:auto,N=1000)</code></pre><p>Uses <a href="../methods/#NonlinearEigenproblems.NEPSolver.contour_beyn"><code>contour_beyn</code></a> to solve the inner problem, with radius and number of quadrature nodes, given by <code>radius</code> and <code>n</code>. If the variable <code>radius</code> is set to <code>:auto</code>, the integration radius will be automatically by using the eigenvalue approximations specified by the outer solver.</p><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.PolyeigInnerSolver" href="#NonlinearEigenproblems.NEPSolver.PolyeigInnerSolver"><code>NonlinearEigenproblems.NEPSolver.PolyeigInnerSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct PolyeigInnerSolver &lt;: InnerSolver
function PolyeigInnerSolver()</code></pre><p>Specifies the use of <a href="../methods/#NonlinearEigenproblems.NEPSolver.polyeig"><code>polyeig</code></a> to solve the inner problem. This is intended for NEPs of the type <a href="../types/#NonlinearEigenproblems.NEPTypes.PEP-Tuple{Array}"><code>PEP</code></a>.</p><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.SGIterInnerSolver" href="#NonlinearEigenproblems.NEPSolver.SGIterInnerSolver"><code>NonlinearEigenproblems.NEPSolver.SGIterInnerSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct SGIterInnerSolver &lt;: InnerSolver</code></pre><p>Uses <a href="../methods/#NonlinearEigenproblems.NEPSolver.sgiter"><code>sgiter</code></a> to solve the inner problem.</p><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.NleigsInnerSolver" href="#NonlinearEigenproblems.NEPSolver.NleigsInnerSolver"><code>NonlinearEigenproblems.NEPSolver.NleigsInnerSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct NleigsInnerSolver &lt;: InnerSolver
function NleigsInnerSolver(;Σ= :auto,nodes =:auto, tol=1e-6 )</code></pre><p>Uses <a href="../methods/#NonlinearEigenproblems.NEPSolver.nleigs"><code>nleigs</code></a> to solve the inner problem, in the region <code>Σ</code> with shifts <code>nodes</code> and with tolerance <code>tol</code>. If the variable <code>Σ</code> is set to <code>:auto</code>, the region <code>Σ</code> will be set by using the eigenvalues approximations. See <a href="../methods/#NonlinearEigenproblems.NEPSolver.nleigs"><code>nleigs</code></a> for description of parameters.</p><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.DefaultInnerSolver" href="#NonlinearEigenproblems.NEPSolver.DefaultInnerSolver"><code>NonlinearEigenproblems.NEPSolver.DefaultInnerSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct DefaultInnerSolver &lt;: InnerSolver</code></pre><p>Dispatches a version of <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a> based on the type of the NEP provided.</p><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a></p></div></div></section><h2><a class="nav-anchor" id="Advanced-usage-1" href="#Advanced-usage-1">Advanced usage</a></h2><p>You can define your own inner solver by inheriting from <code>InnerSolver</code> and implementing the function <code>inner_solve</code>. Since the <code>inner_solve</code> obtains information from the solver via keyword arguments, you need to end your method signature with <code>kwargs...)</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.InnerSolver" href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>NonlinearEigenproblems.NEPSolver.InnerSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type InnerSolver</code></pre><p>Structs inheriting from this type are used to solve inner problems in an inner-outer iteration.</p><p>The <code>InnerSolver</code> objects are passed to the NEP-algorithms, which uses it to dispatch the correct version of the function <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a>. Utilizes existing implementations of NEP-solvers and <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a> acts as a wrapper to these.</p><p><strong>Example</strong></p><p>There is a <a href="#NonlinearEigenproblems.NEPSolver.DefaultInnerSolver"><code>DefaultInnerSolver</code></a> that dispatches an inner solver based on the provided NEP. However, this example shows how you can force <a href="../methods/#NonlinearEigenproblems.NEPSolver.nlar"><code>nlar</code></a> to use the <a href="#NonlinearEigenproblems.NEPSolver.IARInnerSolver"><code>IARInnerSolver</code></a> for a PEP.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;pep0&quot;, 100);
julia&gt; λ,v = nlar(nep, inner_solver_method=NEPSolver.IARInnerSolver(), neigs=1, num_restart_ritz_vecs=1, maxit=70, tol=1e-8);
julia&gt; norm(compute_Mlincomb(nep,λ[1],vec(v)))
8.68118417430353e-9</code></pre><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.DefaultInnerSolver"><code>DefaultInnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.NewtonInnerSolver"><code>NewtonInnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.PolyeigInnerSolver"><code>PolyeigInnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.IARInnerSolver"><code>IARInnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.IARChebInnerSolver"><code>IARChebInnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.SGIterInnerSolver"><code>SGIterInnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.ContourBeynInnerSolver"><code>ContourBeynInnerSolver</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.inner_solve" href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>NonlinearEigenproblems.NEPSolver.inner_solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">inner_solve(is::InnerSolver,T_arit,nep;kwargs...)</code></pre><p>Solves the projected linear problem with solver specied with <code>is</code>. This is to be used as an inner solver in an inner-outer iteration. T specifies which method to use. The most common choice is <a href="@ref"><code>DefaultInnersolver</code></a>. The function returns <code>(λv,V)</code> where <code>λv</code> is an array of eigenvalues and <code>V</code> a matrix with corresponding vectors. The struct <code>T_arit</code> defines the arithmetics used in the outer iteration and should prefereably also be used in the inner iteration.</p><p>Different inner_solve methods take different kwargs. These are standardized kwargs:</p><ul><li><code>neigs</code>: Number of wanted eigenvalues (but less or more may be returned)</li><li><code>σ</code>: target specifying where eigenvalues</li><li><code>λv</code>, <code>V</code>: Vector/matrix of guesses to be used as starting values</li><li><code>j</code>: the jth eigenvalue in a min-max characterization</li><li><code>tol</code>: Termination tolarance for inner solver</li><li><code>inner_logger</code>: Determines how the inner solves are logged. See <a href="../logger/#NonlinearEigenproblems.NEPSolver.Logger"><code>Logger</code></a> for further references</li></ul></div></div></section><h2><a class="nav-anchor" id="Rayleigh-functional-computation-1" href="#Rayleigh-functional-computation-1">Rayleigh functional computation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.compute_rf" href="#NonlinearEigenproblems.NEPSolver.compute_rf"><code>NonlinearEigenproblems.NEPSolver.compute_rf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">compute_rf(eltype::Type,nep::NEP,x,inner_solver::InnerSolver;
           y=x, target=zero(T), λ0=target,TOL=eps(real(T))*1e3,max_iter=10)</code></pre><p>Computes the Rayleigh functional of the <code>nep</code>, i.e., computes a vector <span>$Λ$</span> of values <span>$λ$</span> such that <span>$y^TM(λ)x=0$</span>, using the procedure specified in <code>inner_solver</code>. The default behaviour consists of a scalar valued Newton-iteration, and the returned vector has only one element.</p><p>The given eltype&lt;:Number is the type of the returned vector.</p><p><strong>Example</strong></p><p>This uses <code>iar</code> to solve the (scalar) nonlinear problem.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; x=ones(size(nep,1));
julia&gt; s=compute_rf(ComplexF64,nep,x,IARInnerSolver())[1]; # Take just first element
0.6812131933795565 + 0.0im
julia&gt; x&#39;*compute_Mlincomb(nep,s,x)
1.7763568394002505e-15 + 0.0im</code></pre></div></div></section><h2><a class="nav-anchor" id="Projection-types-1" href="#Projection-types-1">Projection types</a></h2><p>Several methods for NEPs are based on forming a smaller NEP, which we will refer to as a projection:</p><div>\[N(λ)=W^HM(λ)V,\]</div><p>where <span>$V,W\in\mathbb{C}^{n\times p}$</span> and the corresponding projected problem</p><div>\[N(λ)u=0.\]</div><h2><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h2><p>NEPs for which this projection can be computed inherit from <code>ProjectableNEP</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.ProjectableNEP" href="#NonlinearEigenproblems.NEPTypes.ProjectableNEP"><code>NonlinearEigenproblems.NEPTypes.ProjectableNEP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract ProjectableNEP &lt;: NEP</code></pre><p>A ProjectableNEP is a NEP which can be projected, i.e., one can construct the problem <span>$W&#39;*M(λ)Vw=0$</span> with the <a href="#NonlinearEigenproblems.NEPTypes.Proj_NEP"><code>Proj_NEP</code></a>. A NEP which is of this must have the function <a href="#NonlinearEigenproblems.NEPTypes.create_proj_NEP"><code>create_proj_NEP(orgnep::ProjectableNEP)</code></a> implemented. This function must return a <code>Proj_NEP</code>.</p><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.set_projectmatrices!"><code>set_projectmatrices!</code></a>.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; typeof(nep)
DEP{Float64,Array{Float64,2}}
julia&gt; isa(nep,ProjectableNEP)
true
julia&gt; projnep=create_proj_NEP(nep);
julia&gt; e1 = Matrix(1.0*I,size(nep,1),1);
julia&gt; set_projectmatrices!(projnep,e1,e1);
julia&gt; compute_Mder(nep,3.0)[1,1]
-2.315345215259418
julia&gt; compute_Mder(projnep,3.0)
1×1 Array{Float64,2}:
 -2.315345215259418</code></pre></div></div></section><p>The result of the projection is represented in a <code>Proj_NEP</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.Proj_NEP" href="#NonlinearEigenproblems.NEPTypes.Proj_NEP"><code>NonlinearEigenproblems.NEPTypes.Proj_NEP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type Proj_NEP &lt;: NEP</code></pre><p><code>Proj_NEP</code> represents a projected NEP. The projection is defined as the NEP</p><div>\[N(λ)=W^HM(λ)V\]</div><p>where <span>$M(λ)$</span> is a base NEP and <code>W</code> and <code>V</code> rectangular matrices representing a basis of the projection spaces. Instances are created with <code>create_proj_NEP</code>. See <a href="#NonlinearEigenproblems.NEPTypes.create_proj_NEP"><code>create_proj_NEP</code></a> for examples.</p><p>Any <code>Proj_NEP</code> needs to implement two functions to manipulate the projection:</p><ul><li><a href="#NonlinearEigenproblems.NEPTypes.set_projectmatrices!"><code>set_projectmatrices!</code></a>: Set matrices <code>W</code> and <code>V</code></li><li><a href="#NonlinearEigenproblems.NEPTypes.expand_projectmatrices!"><code>expand_projectmatrices!</code></a>: Effectively expand the matrices <code>W</code> and <code>V</code> with one column.</li></ul></div></div></section><p>One explicit instance is the <code>Proj_SPMF_NEP</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.Proj_SPMF_NEP" href="#NonlinearEigenproblems.NEPTypes.Proj_SPMF_NEP"><code>NonlinearEigenproblems.NEPTypes.Proj_SPMF_NEP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Proj_SPMF_NEP &lt;: Proj_NEP</code></pre><p>This type represents the (generic) way to project NEPs which are <code>AbstractSPMF</code>. See examples in <a href="#NonlinearEigenproblems.NEPTypes.create_proj_NEP"><code>create_proj_NEP</code></a>.</p></div></div></section><h2><a class="nav-anchor" id="Associated-functions-1" href="#Associated-functions-1">Associated functions</a></h2><p>You can create a projected NEP with <code>create_proj_NEP</code>:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.create_proj_NEP" href="#NonlinearEigenproblems.NEPTypes.create_proj_NEP"><code>NonlinearEigenproblems.NEPTypes.create_proj_NEP</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pnep=create_proj_NEP(orgnep::ProjectableNEP[,maxsize [,T]])</code></pre><p>Create a NEP representing a projected problem <span>$N(λ)=W^HM(λ)V$</span>,  where the  base NEP is represented by <code>orgnep</code>. The optional parameter <code>maxsize::Int</code> determines how large the projected problem can be and <code>T</code> is the Number type used for the projection matrices (default <code>ComplexF64</code>). These are needed for memory preallocation reasons. Use <a href="#NonlinearEigenproblems.NEPTypes.set_projectmatrices!"><code>set_projectmatrices!</code></a> and <a href="#NonlinearEigenproblems.NEPTypes.expand_projectmatrices!"><code>expand_projectmatrices!</code></a>  to specify projection matrices <span>$V$</span> and <span>$W$</span>.</p><p><strong>Example:</strong></p><p>The following example illustrates that a projection of a <code>NEP</code> is also a <code>NEP</code> and we can for instance call <code>compute_Mder</code> on it:</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;pep0&quot;)
julia&gt; V=Matrix(1.0*I,size(nep,1),2);
julia&gt; W=Matrix(1.0*I,size(nep,1),2);
julia&gt; pnep=create_proj_NEP(nep);
julia&gt; set_projectmatrices!(pnep,W,V);
julia&gt; compute_Mder(pnep,3.0)
2×2 Array{Complex{Float64},2}:
 -2.03662+0.0im   13.9777+0.0im
 -1.35069+0.0im  -13.0975+0.0im
julia&gt; W&#39;*compute_Mder(nep,3.0)*V  # Gives the same result
2×2 Array{Float64,2}:
 -2.03662   13.9777
 -1.35069  -13.0975</code></pre><p>If you know that you will only use real projection matrices, you can specify this in at the creation:</p><pre><code class="language-julia-repl">julia&gt; pnep=create_proj_NEP(nep,2,Float64);
julia&gt; set_projectmatrices!(pnep,W,V);
julia&gt; compute_Mder(pnep,3.0)
2×2 Array{Float64,2}:
 -2.03662   13.9777
 -1.35069  -13.0975</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.set_projectmatrices!" href="#NonlinearEigenproblems.NEPTypes.set_projectmatrices!"><code>NonlinearEigenproblems.NEPTypes.set_projectmatrices!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">set_projectmatrices!(pnep::Proj_NEP,W,V)</code></pre><p>Set the projection matrices for the NEP to W and V, i.e., corresponding the NEP: <span>$N(λ)=W^HM(λ)V$</span>. See also <a href="#NonlinearEigenproblems.NEPTypes.create_proj_NEP"><code>create_proj_NEP</code></a>.</p><p><strong>Example</strong></p><p>This illustrates if <code>W</code> and <code>V</code> are vectors of ones, the projected problem becomes the sum of the rows and columns of the original NEP.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;pep0&quot;)
julia&gt; pnep=create_proj_NEP(nep);
julia&gt; V=ones(200,1);  W=ones(200,1);
julia&gt; set_projectmatrices!(pnep,W,V);
julia&gt; compute_Mder(pnep,0)
1×1 Array{Complex{Float64},2}:
 48.948104019482756 + 0.0im
julia&gt; sum(compute_Mder(nep,0),dims=[1,2])
1×1 Array{Float64,2}:
 48.948104019482955</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.expand_projectmatrices!" href="#NonlinearEigenproblems.NEPTypes.expand_projectmatrices!"><code>NonlinearEigenproblems.NEPTypes.expand_projectmatrices!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">expand_projectmatrices!(nep::Proj_SPMF_NEP, Wnew, Vnew)</code></pre><p>The projected NEP is updated by adding the last column of <code>Wnew</code> and <code>Vnew</code> to the basis. Note that <code>Wnew</code> and <code>Vnew</code> contain also the &quot;old&quot; basis vectors. See also <a href="#NonlinearEigenproblems.NEPTypes.create_proj_NEP"><code>create_proj_NEP</code></a></p><p><strong>Example:</strong></p><p>In the following example you see that the expanded projected problem has one row and column more, and the leading subblock is the same as the smaller projected NEP.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;pep0&quot;); n=size(nep,1);
julia&gt; V=Matrix(1.0*I,n,2); W=Matrix(1.0*I,n,2);
julia&gt; pnep=create_proj_NEP(nep);
julia&gt; set_projectmatrices!(pnep,W,V);
julia&gt; compute_Mder(pnep,0)
2×2 Array{Complex{Float64},2}:
 0.679107+0.0im   -0.50376+0.0im
 0.828413+0.0im  0.0646768+0.0im
julia&gt; Vnew=[V ones(n)]
julia&gt; Wnew=[W ones(n)]
julia&gt; expand_projectmatrices!(pnep,Wnew,Vnew);
julia&gt; compute_Mder(pnep,0)
3×3 Array{Complex{Float64},2}:
 0.679107+0.0im   -0.50376+0.0im  -12.1418+0.0im
 0.828413+0.0im  0.0646768+0.0im   16.3126+0.0im
 -17.1619+0.0im   -10.1628+0.0im   48.9481+0.0im</code></pre></div></div></section><footer><hr/><a class="previous" href="../linsolvers/"><span class="direction">Previous</span><span class="title">LinSolvers</span></a><a class="next" href="../errmeasure/"><span class="direction">Next</span><span class="title">Measuring the error</span></a></footer></article></body></html>
