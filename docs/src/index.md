
# NEPPACK 

NEPPACK is a package with implementations of methods to solve nonlinear eigenvalue problems of
the type: Find ``(λ,v)\in\mathbb{C}\times\mathbb{C}^n`` such that
```math
M(λ)v=0
```
and ``v\neq 0``. 


# Getting started

Install it as a contributed package 
```
julia> Pkg.clone("git://github.com/nep-pack/NonlinearEigenproblems.jl.git");

```
NEP-PACK uses several contributed julia packages.
These need to be installed the first time you use NEP-PACK,
by running for the corresponding packages:
```julia-repl
julia> Pkg.add("IterativeSolvers")
```
Then we can start to load some NEP-PACK packages
```julia-repl
julia> using NonlinearEigenproblems: NEPSolver, NEPTypes
```
We are now ready to create and solve a nonlinear eigenvalue problem, in this
illustrative example we set 

```math
M(λ)=\begin{bmatrix}1&3\newline5&6\end{bmatrix}+
λ\begin{bmatrix}3&4\newline6&6\end{bmatrix}+
λ^2\begin{bmatrix}1&0\newline0&1\end{bmatrix}
```
The following code creates this NEP (which is a so called polynomial eigenvalue problem)
and solves it using the NEP solution method implemented in `polyeig()`:
```julia-repl
julia> A0=[1 3; 5 6]; A1=[3 4; 6 6]
julia> nep=PEP([A0,A1,eye(2)])
NEPTypes.PEP(2, Array{Float64,2}[[1.0 3.0; 5.0 6.0], [3.0 4.0; 6.0 6.0], [1.0 0.0; 0.0 1.0]])
julia> λ,v=polyeig(nep)
(Complex{Float64}[1.36267+0.0im, -0.824084+0.280682im, -0.824084-0.280682im, -8.7145+0.0im], Complex{Float64}[-1.0+0.0im 0.739183-0.196401im 0.739183+0.196401im 0.627138+0.0im; 0.821812+0.0im -0.501408-0.375337im -0.501408+0.375337im 1.0+0.0im])
```
You have now solved your first nonlinear eigenvalue problem with NEPPACK. 

In order to verify that we have a solution, we can check that  ``M(λ)`` is singular,
with a singular vector ``v`` such that ``M(λ)v=0``:
```julia-repl
julia> λ1=λ[1]; v1=v[:,1];
julia> norm((A0+A1*λ1+eye(2)*λ1^2)*v1)/norm(v1)
1.1502634749464687e-14
```


# Accessing more complicated applications

We have made benchmark examples available in the module `Gallery`. Use it
by loading the module and calling the function `nep_gallery`:

```julia-repl
julia> using NonlinearEigenproblems: Gallery
julia> nep=nep_gallery("dep0",100);
julia> size(nep)
(100, 100)
julia> λ,v=mslp(nep,tol=1e-10);
julia> λ
0.23169217667341738 - 2.1866254654451488e-16im
julia> size(v)
(100,)
julia> resnorm=norm(compute_Mlincomb(nep,λ,v))
3.124042808475689e-14
```
Information about the gallery can be found by typing `?nep_gallery`.
The second arument in the call to `nep_gallery` is a problem parameter,
in this case specifying that the  size of the problem should be `100`.
The example solves the problem with the method MSLP. The parameter `tol` specifies the
tolerance for iteration termination. Type `?mslp` for more information
about this method.

# A model of a neuron

The following (delay) differential equation models a neuron
```math
\dot{x}_1(t)=-\kappa x_1(t)+\beta\tanh(x_1(t-\tau_3))+a_1\tanh(x_2(t-\tau_2))
```
```math
\dot{x}_2(t)=-\kappa x_2(t)+\beta\tanh(x_2(t-\tau_3))+a_2\tanh(x_1(t-\tau_1))
```
See [L. P. Shayer and S. A. Campbell.  Stability, bifurcation and multistability in a system of two
coupled neurons with multiple time delays. SIAM J. Applied Mathematics , 61(2):673–700, 2000](https://www.jstor.org/stable/3061744?seq=1#page_scan_tab_contents). It is
also available as a first demo in [DDE-BIFTOOL](https://sourceforge.net/projects/ddebiftool/).
The linear stability analysis of this problem requires the solution
of a nonlinear eigenvalue eigenvalue problem
```math
M(λ)=-λI+A_0+A_1e^{-\tau_1λ}+A_2e^{-\tau_2λ}+A_3e^{-\tau_3λ}
```
where the matrices are the Jacobian at the stationary solution.
For the zero stationary solution, the matrices are
```julia-repl
kappa=0.5; a2=2.34; a1=1; beta=-1;
A0=-kappa*eye(2);
A1=a2*[0 0; 1 0];
A2=a1*[0 1; 0 0];
A3=beta*eye(2);
```
We can now create the nonlinear eigenvalue problem and compute the stability
by first creating the problem
```julia-repl
julia> tauv=[0;0.2;0.2;1.5];
julia> dep=DEP([A0, A1,   A2, A3],tauv);
```
and solving it with for instance the infinite Arnoldi method
```julia-repl
julia> λ,V=iar_chebyshev(dep,maxit=100);
```
The figure in a demo of DDE-BIFTOOL <http://ddebiftool.sourceforge.net/demos/neuron/html/demo1_stst.html> can be directly generated by
```julia-repl
julia> using PyPlot;
julia> plot(real(λ),imag(λ),"*")
```

This problem is also available in the `Gallery` by calling `dep=nep_gallery("neuron0")`.


# What now?

Now you are ready to have a look at the examples
in [NEP methods](methods/) and  [NEP Gallery](gallery/).






