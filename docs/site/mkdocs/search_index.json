{
    "docs": [
        {
            "location": "/",
            "text": "NEPCore Documentation\n\n\n#\n\n\nNEPCore.NEP\n \u2014 \nType\n.\n\n\nabstract NEP\n\n\n\n\nNEP represents a nonlinear eigenvalue problem\n\n\n#\n\n\nNEPTypes.SPMF_NEP\n \u2014 \nType\n.\n\n\ntype SPMF_NEP <: AbstractSPMF\n\n\n\n\nAn SPMF_NEP is NEP defined by a Sum of Products of Matrices and Functions, defined by the sum \n\n\n$$\nM(\u03bb)=\u03a3_i A_i f_i(\u03bb),\n$$\n\n\nwhere $i = 0,1,2,...$, all of the matrices are of size $n\u00d7n$ and $f_i$ are a functions. The  functions $f_i$ must be defined for matrices and return be defined in a matrix function sense. \n\n\nSPMF_NEP(AA,fii,Schur_fact=false)\n\n\n\n\n#\n\n\nNEPCore.compute_Mder\n \u2014 \nFunction\n.\n\n\ncompute_Mder(nep::NEP,\u03bb::Number [,i::Integer=0])\n\n\n\n\nComputes the ith derivative of \nnep\n evaluated in \n\u03bb\n.\n\n\nExample\n\n\nThis example shows that \ncompute_Mder(nep,\u03bb,1)\n gives the first derivative.\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> \u03f5=1e-5;\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aplus=compute_Mder(nep,\u03bb+\u03f5);\njulia> norm((Aplus-Aminus)/(2\u03f5)-compute_Mder(nep,\u03bb,1))\n1.990970375089371e-11\n\n\n\n\n#\n\n\nNEPCore.compute_Mlincomb\n \u2014 \nFunction\n.\n\n\ncompute_Mlincomb(nep::NEP,\u03bb::Number,V;a=ones(size(V,2)))\n\n\n\n\nComputes the linear combination of derivatives\n$\u03a3_i a_i M^{(i)}(\u03bb) v_i$\n\n\nExample\n\n\nThis example shows that \ncompute_Mder\n gives a result consistent with \ncompute_Mlincomb\n. Note that \ncompute_Mlincomb\n is in general faster since no matrix needs to be constructed.\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> v=ones(size(nep,1)); \u03bb=-1+1im;\njulia> norm(compute_Mder(nep,\u03bb,1)*v-compute_Mlincomb(nep,\u03bb,hcat(v,v),a=[0,1]))\n1.0778315928076987e-15\n\n\n\n\n\ncompute_Mlincomb(nep::NEP,\u03bb::Number,V,a::Array,startder::Integer)\n\n\n\n\nComputes linear combination starting with derivative startder, i.e., $\u03a3_i a_i M^{(i+startder)}(\u03bb) v_i$\n\n\nThe default implementation of this can be slow. Overload for specific NEP if you want efficiency (for aug_newton, IAR, ..).\n\n\nLet's try an equation $x=f(x)$. (a \\ne 0)\n\n\n$$\nx=x_1+1\n$$\n\n\n\n\nCompiling the documentation\n\n\nCompile this documentation site by running:\n\n\njarl@bjork:~/jobb/src/nep-pack-alpha/docs$ julia --color=yes make.jl\njarl@bjork:~/jobb/src/nep-pack-alpha/docs$ mkdocs build --clean\njarl@bjork:~/jobb/src/nep-pack-alpha/docs$ firefox site/index.html\n\n\n\n\nMore information about \nDocumenter.jl\n: \nhere",
            "title": "Home"
        },
        {
            "location": "/#nepcore-documentation",
            "text": "#  NEPCore.NEP  \u2014  Type .  abstract NEP  NEP represents a nonlinear eigenvalue problem  #  NEPTypes.SPMF_NEP  \u2014  Type .  type SPMF_NEP <: AbstractSPMF  An SPMF_NEP is NEP defined by a Sum of Products of Matrices and Functions, defined by the sum   $$\nM(\u03bb)=\u03a3_i A_i f_i(\u03bb),\n$$  where $i = 0,1,2,...$, all of the matrices are of size $n\u00d7n$ and $f_i$ are a functions. The  functions $f_i$ must be defined for matrices and return be defined in a matrix function sense.   SPMF_NEP(AA,fii,Schur_fact=false)  #  NEPCore.compute_Mder  \u2014  Function .  compute_Mder(nep::NEP,\u03bb::Number [,i::Integer=0])  Computes the ith derivative of  nep  evaluated in  \u03bb .  Example  This example shows that  compute_Mder(nep,\u03bb,1)  gives the first derivative.  julia> nep=nep_gallery(\"dep0\");\njulia> \u03f5=1e-5;\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aplus=compute_Mder(nep,\u03bb+\u03f5);\njulia> norm((Aplus-Aminus)/(2\u03f5)-compute_Mder(nep,\u03bb,1))\n1.990970375089371e-11  #  NEPCore.compute_Mlincomb  \u2014  Function .  compute_Mlincomb(nep::NEP,\u03bb::Number,V;a=ones(size(V,2)))  Computes the linear combination of derivatives\n$\u03a3_i a_i M^{(i)}(\u03bb) v_i$  Example  This example shows that  compute_Mder  gives a result consistent with  compute_Mlincomb . Note that  compute_Mlincomb  is in general faster since no matrix needs to be constructed.  julia> nep=nep_gallery(\"dep0\");\njulia> v=ones(size(nep,1)); \u03bb=-1+1im;\njulia> norm(compute_Mder(nep,\u03bb,1)*v-compute_Mlincomb(nep,\u03bb,hcat(v,v),a=[0,1]))\n1.0778315928076987e-15  compute_Mlincomb(nep::NEP,\u03bb::Number,V,a::Array,startder::Integer)  Computes linear combination starting with derivative startder, i.e., $\u03a3_i a_i M^{(i+startder)}(\u03bb) v_i$  The default implementation of this can be slow. Overload for specific NEP if you want efficiency (for aug_newton, IAR, ..).  Let's try an equation $x=f(x)$. (a \\ne 0)  $$\nx=x_1+1\n$$",
            "title": "NEPCore Documentation"
        },
        {
            "location": "/#compiling-the-documentation",
            "text": "Compile this documentation site by running:  jarl@bjork:~/jobb/src/nep-pack-alpha/docs$ julia --color=yes make.jl\njarl@bjork:~/jobb/src/nep-pack-alpha/docs$ mkdocs build --clean\njarl@bjork:~/jobb/src/nep-pack-alpha/docs$ firefox site/index.html  More information about  Documenter.jl :  here",
            "title": "Compiling the documentation"
        }
    ]
}