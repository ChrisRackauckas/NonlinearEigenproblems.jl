{
    "docs": [
        {
            "location": "/",
            "text": "NEPPACK\n\n\nNEPPACK is a package with implementations of methods to solve nonlinear eigenvalue problems of the type: Find $(\u03bb,v)\\in\\mathbb{C}\\times\\mathbb{C}^n$ such that\n\n\n$$\nM(\u03bb)v=0\n$$\n\n\nand $v\\neq 0$. \n\n\n\n\nGetting started\n\n\nDownload NEP-PACK and get into the correct directory and start julia\n\n\njarl@bjork:~/src/NonlinearEigenproblems.jl$\njarl@bjork:~/src/NonlinearEigenproblems.jl$ julia\n   _       _ _(_)_     |  A fresh approach to technical computing\n  (_)     | (_) (_)    |  Documentation: https://docs.julialang.org\n   _ _   _| |_  __ _   |  Type \"?help\" for help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 0.6.2 (2017-12-13 18:08 UTC)\n _/ |\\__'_|_|_|\\__'_|  |  Official http://julialang.org/ release\n|__/                   |  x86_64-pc-linux-gnu\n\njulia> \n\n\n\n\nFirst we need to make julia find the NEP-PACK-files in its path\n\n\njulia> push!(LOAD_PATH, string(ENV[\"HOME\"],\"/src/NonlinearEigenproblems.jl/src/\"))\n\n\n\n\nand then we can start to load the appropriate packages. \n\n\njulia> using NEPSolver, NEPTypes\n\n\n\n\nThe first time you run this, you will normally get an error message,\n\n\nERROR: LoadError: LoadError: ArgumentError: Module IterativeSolvers not found in current path.\nRun `Pkg.add(\"IterativeSolvers\")` to install the IterativeSolvers package.\n\n\n\n\nNEPPACK builds on contributed julia packages. These need to be installed the first time you use NEPPACK, by running for the corresponding packages:\n\n\njulia> Pkg.add(\"IterativeSolvers\")\n\n\n\n\nWe are now ready to create and solve a nonlinear eigenvalue problem, in this illustrative example we set\n\n\n$$\nM(\u03bb)=\\begin{bmatrix}1&3\\newline5&6\\end{bmatrix}+\n\u03bb\\begin{bmatrix}3&4\\newline6&6\\end{bmatrix}+\n\u03bb^2\\begin{bmatrix}1&0\\newline0&1\\end{bmatrix}\n$$\n\n\nThe following code creates this NEP (which is a so called polynomial eigenvalue problem) and solves it using the NEP solution method implemented in \npolyeig()\n:\n\n\njulia> A0=[1 3; 5 6]; A1=[3 4; 6 6]\njulia> nep=PEP([A0,A1,eye(2)])\nNEPTypes.PEP(2, Array{Float64,2}[[1.0 3.0; 5.0 6.0], [3.0 4.0; 6.0 6.0], [1.0 0.0; 0.0 1.0]])\njulia> \u03bb,v=polyeig(nep)\n(Complex{Float64}[1.36267+0.0im, -0.824084+0.280682im, -0.824084-0.280682im, -8.7145+0.0im], Complex{Float64}[-1.0+0.0im 0.739183-0.196401im 0.739183+0.196401im 0.627138+0.0im; 0.821812+0.0im -0.501408-0.375337im -0.501408+0.375337im 1.0+0.0im])\n\n\n\n\nYou have now solved your first nonlinear eigenvalue problem with NEPPACK. \n\n\nIn order to verify that we have a solution, we can check that  $M(\u03bb)$ is singular, with a singular vector $v$ such that $M(\u03bb)v=0$:\n\n\njulia> \u03bb1=\u03bb[1]; v1=v[:,1];\njulia> norm((A0+A1*\u03bb1+eye(2)*\u03bb1^2)*v1)/norm(v1)\n1.1502634749464687e-14\n\n\n\n\n\n\nAccessing more complicated applications\n\n\nWe have made benchmark examples available in the module \nGallery\n. Use it by loading the module and calling the function \nnep_gallery\n:\n\n\njulia> using Gallery\njulia> nep=nep_gallery(\"dep0\",100);\njulia> size(nep)\n(100, 100)\njulia> \u03bb,v=mslp(nep,tol=1e-10);\njulia> \u03bb\n0.23169217667341738 - 2.1866254654451488e-16im\njulia> size(v)\n(100,)\njulia> resnorm=norm(compute_Mlincomb(nep,\u03bb,v))\n3.124042808475689e-14\n\n\n\n\nInformation about the gallery can be found by typing \n?nep_gallery\n. The second arument in the call to \nnep_gallery\n is a problem parameter, in this case specifying that the  size of the problem should be \n100\n. The example solves the problem with the method MSLP. The parameter \ntol\n specifies the tolerance for iteration termination. Type \n?mslp\n for more information about this method.\n\n\nUnder construction: Reproduce an example in DDE-BIFTOOL. Here is a Benchmark Example. \n\n\n\n\nWhat now?\n\n\nNow you are ready to have a look at the examples in \nNEP methods\n and  \nNEP Gallery\n.\n\n\n\n\nCompiling the documentation\n\n\nCompile this documentation page by running:\n\n\njarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ julia --color=yes make.jl &&  mkdocs build --clean\njarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ firefox site/index.html\n\n\n\n\nIf you want this to appear on our documentation page \nhttps://nep-pack.github.io/NonlinearEigenproblems.jl/\n you need to push it to the \ngh-branch\n, e.g.,  by running\n\n\njarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ export DOCSDIR=`pwd`\njarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ cd /tmp\njarl@bjork:/tmp$ git clone -b \"gh-pages\" git@github.com:nep-pack/NonlinearEigenproblems.jl.git\njarl@bjork:/tmp$ cd NonlinearEigenproblems\njarl@bjork:/tmp/NonlinearEigenproblems.jl$ cp -r $DOCSDIR/site/* .\njarl@bjork:/tmp/NonlinearEigenproblems.jl$ git add *;  git commit . -m \"refresh docs\"; git push\n\n\n\n\nMore information about \nDocumenter.jl\n: \nhere",
            "title": "Introduction"
        },
        {
            "location": "/#neppack",
            "text": "NEPPACK is a package with implementations of methods to solve nonlinear eigenvalue problems of the type: Find $(\u03bb,v)\\in\\mathbb{C}\\times\\mathbb{C}^n$ such that  $$\nM(\u03bb)v=0\n$$  and $v\\neq 0$.",
            "title": "NEPPACK"
        },
        {
            "location": "/#getting-started",
            "text": "Download NEP-PACK and get into the correct directory and start julia  jarl@bjork:~/src/NonlinearEigenproblems.jl$\njarl@bjork:~/src/NonlinearEigenproblems.jl$ julia\n   _       _ _(_)_     |  A fresh approach to technical computing\n  (_)     | (_) (_)    |  Documentation: https://docs.julialang.org\n   _ _   _| |_  __ _   |  Type \"?help\" for help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 0.6.2 (2017-12-13 18:08 UTC)\n _/ |\\__'_|_|_|\\__'_|  |  Official http://julialang.org/ release\n|__/                   |  x86_64-pc-linux-gnu\n\njulia>   First we need to make julia find the NEP-PACK-files in its path  julia> push!(LOAD_PATH, string(ENV[\"HOME\"],\"/src/NonlinearEigenproblems.jl/src/\"))  and then we can start to load the appropriate packages.   julia> using NEPSolver, NEPTypes  The first time you run this, you will normally get an error message,  ERROR: LoadError: LoadError: ArgumentError: Module IterativeSolvers not found in current path.\nRun `Pkg.add(\"IterativeSolvers\")` to install the IterativeSolvers package.  NEPPACK builds on contributed julia packages. These need to be installed the first time you use NEPPACK, by running for the corresponding packages:  julia> Pkg.add(\"IterativeSolvers\")  We are now ready to create and solve a nonlinear eigenvalue problem, in this illustrative example we set  $$\nM(\u03bb)=\\begin{bmatrix}1&3\\newline5&6\\end{bmatrix}+\n\u03bb\\begin{bmatrix}3&4\\newline6&6\\end{bmatrix}+\n\u03bb^2\\begin{bmatrix}1&0\\newline0&1\\end{bmatrix}\n$$  The following code creates this NEP (which is a so called polynomial eigenvalue problem) and solves it using the NEP solution method implemented in  polyeig() :  julia> A0=[1 3; 5 6]; A1=[3 4; 6 6]\njulia> nep=PEP([A0,A1,eye(2)])\nNEPTypes.PEP(2, Array{Float64,2}[[1.0 3.0; 5.0 6.0], [3.0 4.0; 6.0 6.0], [1.0 0.0; 0.0 1.0]])\njulia> \u03bb,v=polyeig(nep)\n(Complex{Float64}[1.36267+0.0im, -0.824084+0.280682im, -0.824084-0.280682im, -8.7145+0.0im], Complex{Float64}[-1.0+0.0im 0.739183-0.196401im 0.739183+0.196401im 0.627138+0.0im; 0.821812+0.0im -0.501408-0.375337im -0.501408+0.375337im 1.0+0.0im])  You have now solved your first nonlinear eigenvalue problem with NEPPACK.   In order to verify that we have a solution, we can check that  $M(\u03bb)$ is singular, with a singular vector $v$ such that $M(\u03bb)v=0$:  julia> \u03bb1=\u03bb[1]; v1=v[:,1];\njulia> norm((A0+A1*\u03bb1+eye(2)*\u03bb1^2)*v1)/norm(v1)\n1.1502634749464687e-14",
            "title": "Getting started"
        },
        {
            "location": "/#accessing-more-complicated-applications",
            "text": "We have made benchmark examples available in the module  Gallery . Use it by loading the module and calling the function  nep_gallery :  julia> using Gallery\njulia> nep=nep_gallery(\"dep0\",100);\njulia> size(nep)\n(100, 100)\njulia> \u03bb,v=mslp(nep,tol=1e-10);\njulia> \u03bb\n0.23169217667341738 - 2.1866254654451488e-16im\njulia> size(v)\n(100,)\njulia> resnorm=norm(compute_Mlincomb(nep,\u03bb,v))\n3.124042808475689e-14  Information about the gallery can be found by typing  ?nep_gallery . The second arument in the call to  nep_gallery  is a problem parameter, in this case specifying that the  size of the problem should be  100 . The example solves the problem with the method MSLP. The parameter  tol  specifies the tolerance for iteration termination. Type  ?mslp  for more information about this method.  Under construction: Reproduce an example in DDE-BIFTOOL. Here is a Benchmark Example.",
            "title": "Accessing more complicated applications"
        },
        {
            "location": "/#what-now",
            "text": "Now you are ready to have a look at the examples in  NEP methods  and   NEP Gallery .",
            "title": "What now?"
        },
        {
            "location": "/#compiling-the-documentation",
            "text": "Compile this documentation page by running:  jarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ julia --color=yes make.jl &&  mkdocs build --clean\njarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ firefox site/index.html  If you want this to appear on our documentation page  https://nep-pack.github.io/NonlinearEigenproblems.jl/  you need to push it to the  gh-branch , e.g.,  by running  jarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ export DOCSDIR=`pwd`\njarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ cd /tmp\njarl@bjork:/tmp$ git clone -b \"gh-pages\" git@github.com:nep-pack/NonlinearEigenproblems.jl.git\njarl@bjork:/tmp$ cd NonlinearEigenproblems\njarl@bjork:/tmp/NonlinearEigenproblems.jl$ cp -r $DOCSDIR/site/* .\njarl@bjork:/tmp/NonlinearEigenproblems.jl$ git add *;  git commit . -m \"refresh docs\"; git push  More information about  Documenter.jl :  here",
            "title": "Compiling the documentation"
        },
        {
            "location": "/methods/",
            "text": "NEP Methods\n\n\nThe NEP solver methods implemented in NEP-pack, are accessed by the functions below. The functions all return $\u03bb,v,w$ where $\u03bb$ is either a number (eigenvalue) a vector of eigenvalues $v$ is either a vector containing an eigenvector or a matrix whose columns corresponding to the eigenvectors.\n\n\nThe first parameter optional parameter in all NEP solver methods is a type. This type specifies which arithmetic should be used for the algorithm.\n\n\nExample:\n\n\njulia> nep=nep_gallery(\"dep0\")\njulia> \u03bb,v=augnewton(Complex128,nep,v=ones(5))\n(0.8347353572199425 + 0.0im, Complex{Float64}[0.480386+0.0im, 0.0631636+0.0im, -0.136405+0.0im, 0.214274+0.0im, 0.378581+0.0im])\njulia> typeof(\u03bb)\nComplex{Float64}\njulia> \u03bb,v=augnewton(Float16,nep,v=ones(5))\n(Float16(0.8223), Float16[0.47388, 0.063904, -0.13843, 0.21692, 0.38306])\njulia> typeof(\u03bb)\nFloat16\n\n\n\n\n\n\nNewton type methods\n\n\n#\n\n\nNEPSolver.newton\n \u2014 \nFunction\n.\n\n\n\u03bb,v = newton([eltype],nep::NEP;[errmeasure,][tol,][maxit,][\u03bb,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max])\n\n\n\n\nApplies Newton-Raphsons method on the system of nonlinear equations with \nn+1\n unknowns:\n\n\n$$\nM(\u03bb)v=0\n$$\n\n\n$$\nc^Hv-1=0\n$$\n\n\nThe kwarg \nerrmeasure\n is a function handle which can be used to specify how the error is measured to be used in termination (default is absolute residual norm). The iteration is continued until errmeausure is less than \ntol\n. \n\u03bb\n and \nv\n are starting approximations. \nc\n is the orthogonalization vector.  If \nc=0\n the current approximation will be used for the orthogonalization. \narmijo_factor\n specifies if an Armijo rule should be applied, and its value specifies the scaling factor of the step length (per reduction step). The variable \narmijo_max\n specifies the maximum number of step length reductions.\n\n\nExample\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> \u03bb,v=newton(nep);\njulia> minimum(svdvals(compute_Mder(nep,\u03bb)))\n1.6066157878930876e-16\n\n\n\n\nReferences\n\n\n\n\nNichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.\n\n\nA. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689\n\n\n\n\nsource\n\n\n#\n\n\nNEPSolver.augnewton\n \u2014 \nFunction\n.\n\n\naugnewton([eltype], nep::NEP; [errmeasure,][tol,][maxit,][\u03bb,][v,][c,][displaylevel,][linsolvercreator,][armijo_factor,][armijo_max])\n\n\n\n\nRun the augmented Newton method. The method is equivalent to \nnewton()\n in exact arithmetic,  but works only with operations on vectors of length \nn\n. The \nlinsolvecreator\n is used to initiate linear solvers. See \nnewton()\n for other parameters.\n\n\nExample\n\n\nThis illustrates the equivalence between \nnewton\n and \naugnewton\n.\n\n\njulia> nep=nep_gallery(\"dep1\")\njulia> \u03bb1,v1=newton(nep,maxit=20,v=ones(size(nep,1)),\u03bb=0)\njulia> \u03bb2,v2=augnewton(nep,maxit=20,v=ones(size(nep,1)),\u03bb=0)\njulia> \u03bb1-\u03bb2\n0.0 + 0.0im\n\n\n\n\nReferences\n\n\n\n\nNichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.\n\n\nA. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689\n\n\n\n\nsource\n\n\n#\n\n\nNEPSolver.resinv\n \u2014 \nFunction\n.\n\n\n\u03bb,v = resinv([eltype],nep::NEP;[errmeasure,][tol,][maxit,][\u03bb,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max,][linsolvecreator])\n\n\n\n\nApplies residual inverse iteration method for nonlinear eigenvalue problems. The kwarg \nlinsolvecreator\n is a function which specifies how the linear system is created. The function calls \ncompute_rf\n for the computation of the Rayleigh functional. See \nnewton()\n for other parameters.\n\n\nExample\n\n\nThe example shows how to specify if the method should run in real or complex mode (or any other \nNumber\n type).\n\n\njulia> nep=nep_gallery(\"qdep0\");\njulia> \u03bb,v=resinv(nep,\u03bb=-2,v=ones(size(nep,1)))\njulia> typeof(\u03bb)\nComplex{Float64}\njulia> norm(compute_Mlincomb(nep,\u03bb,v))\n1.817030659827106e-14\njulia> \u03bb,v=resinv(Float64,nep,\u03bb=-2,v=ones(size(nep,1)))\njulia> typeof(\u03bb)\nFloat64\njulia> norm(compute_Mlincomb(nep,\u03bb,v))\n1.817030659827106e-14\n\n\n\n\nReferences\n\n\n\n\nA. Neumaier, Residual inverse iteration for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 22 (1985) 914-923\n\n\n\n\nsource\n\n\n#\n\n\nNEPSolver.quasinewton\n \u2014 \nFunction\n.\n\n\nquasinewton([T=Complex128],nep,[errmeasure,][tol,][maxit,][\u03bb,][v][ws][displaylevel][linsolvercreator,][armijo_factor,][armijo_max])\n\n\n\n\nAn implementation of the quasi-Newton approach referred to as quasi-Newton 2 in the reference. The method involves one linear system solve per iteration corresponding with the matrix $M(\u03bb)$, where $\u03bb$ is constant. The vector \nws\n is a representation of the normalization, in the sense that $c^T=w_s^TM(\u03bb)$, where all iterates satisfy $c^Tx_i=1$. See \nnewton()\n for other parameters.\n\n\nExample\n\n\njulia> nep=nep_gallery(\"pep0\")\njulia> \u03bb,v=quasinewton(nep,v=ones(size(nep,1)));\njulia> norm(compute_Mlincomb(nep,\u03bb,v))/norm(v)\n6.301479387102376e-15\n\n\n\n\nReferences\n\n\n\n\nJarlebring, Koskela, Mele, Disguised and new Quasi-Newton methods for nonlinear eigenvalue problems, arxiv preprint: https://arxiv.org/abs/1702.08492\n\n\n\n\nsource\n\n\n#\n\n\nNEPSolver.mslp\n \u2014 \nFunction\n.\n\n\n mslp([eltype],nep::NEP;[errmeasure,][tol,][maxit,][\u03bb,][v,][displaylevel,][eigsolvertype::DataType][armijo_factor=1,][armijo_max])\n\n\n\n\nRuns the method of successive linear problems. The  method requires the solution of a generalized eigenvalue problem in every iteration. The method used for the eigenvalue computation is specified in eigsolvertype. See \nnewton\n for other parameters.\n\n\nExample\n\n\nCreate a rational NEP with SPMFs.\n\n\njulia> Av=[ones(3,3),eye(3,3),triu(ones(3,3))];\njulia> fv=[S-> S, S -> S^2, S::AbstractArray -> inv(full(S)-eye(S)*10)]\njulia> nep=SPMF_NEP(Av,fv)\njulia> (\u03bb,v)=mslp(nep)\njulia> compute_Mlincomb(nep,\u03bb,v)\n3-element Array{Complex{Float64},1}:\n -1.38778e-17+1.65715e-18im\n -5.55112e-17+1.30633e-17im\n -4.16334e-17-1.54436e-17im\n\n\n\n\nReferences\n\n\n\n\nA. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689\n\n\n\n\nsource\n\n\n#\n\n\nNEPSolver.rfi\n \u2014 \nFunction\n.\n\n\nrfi(nep,nept,[\u03bb=0,][errmeasure=default_errmeasure,][tol=eps()*100,][maxit=100,][v=randn,][u=randn,][displaylevel=0,][linsolvecreator=default_linsolvecreator,])\n\n\n\n\nTwo-sided Rayleigh functional Iteration, as given as Algorithm 4 in  \"Nonlinear Eigenvalue Problems: Newton-type Methods and Nonlinear Rayleigh Functionals\", by Kathrin Schreiber.\n\n\nsource\n\n\n#\n\n\nNEPSolver.newtonqr\n \u2014 \nFunction\n.\n\n\nNewton-QR method.\n\n\n\n\nsource\n\n\n#\n\n\nNEPSolver.implicitdet\n \u2014 \nFunction\n.\n\n\nImplicit determinant method\n\n\n\n\nsource\n\n\n\n\nProjection methods\n\n\nNEPSolver.nlar\n\n\n\n\n\n\nArnoldi type methods\n\n\n#\n\n\nNEPSolver.iar\n \u2014 \nFunction\n.\n\n\niar(nep,[maxit=30,][\u03c3=0,][\u03b3=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])\n\n\n\n\nInfinite Arnoldi method\n\n\nInfinite Arnoldi method, as described in Algorithm 2 in  \"A linear eigenvalue algorithm for the nonlinear eigenvalue problem\", by Jarlebring, Elias and Michiels, Wim and Meerbergen, Karl.\n\n\nsource\n\n\n#\n\n\nNEPSolver.tiar\n \u2014 \nFunction\n.\n\n\ntiar(nep,[maxit=30,][\u03c3=0,][\u03b3=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])\n\n\n\n\nTensor Infinite Arnoldi method\n\n\nTensor Infinite Arnoldi method, as described in Algorithm 2 in  \"The Waveguide Eigenvalue Problem and the Tensor Infinite Arnoldi Method\", by Jarlebring, Elias and Mele, Giampaolo and Runborg, Olof.\n\n\nsource\n\n\n#\n\n\nNEPSolver.infbilanczos\n \u2014 \nFunction\n.\n\n\n\u03bbv,V,U=infbilanczos([eltype],nep, nept,[linsolvecreator,][linsolvertcreator,][v,][u,][\u03c3,][\u03b3,][tol,][Neig,][errmeasure,][displaylevel,][maxit,][check_error_every])\n\n\n\n\nExecutes the Infinite Bi-Lanczos method on the problem defined by \nnep::NEP\n and \nnept::NEP\n. \nnep:NEP\n is the original nonlinear eigenvalue problem and \nnept::NEP\n is its (hermitian) transpose: $M(lambda^*)^H$.  \nv\n and \nu\n are starting vectors, \n\u03c3\n is the shift and \n\u03b3\n the scaling.  See \nnewton()\n for other parameters.\n\n\nExample:\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> A=get_Av(nep); fv=get_fv(nep);\njulia> nept=SPMF_NEP([A[1]',A[2]',A[3]'],fv); # Create the transposed NEP\njulia> \u03bbv,V=infbilanczos(nep,nept,Neig=3)\njulia> norm(compute_Mlincomb(nep,\u03bbv[1],V[:,1]))\n\n\n\n\nReferences:\n\n\n\n\nThe infinite bi-Lanczos method for nonlinear eigenvalue problems, S. W. Gaaf and E. Jarlebring, arxiv: 1607.03454, to appear in SIAM J. Scientific Computing\n\n\n\n\nsource\n\n\n\n\nClass specific methods\n\n\n\n\nCompanion linearizations\n\n\n\n\nRational ?",
            "title": "NEP Methods"
        },
        {
            "location": "/methods/#nep-methods",
            "text": "The NEP solver methods implemented in NEP-pack, are accessed by the functions below. The functions all return $\u03bb,v,w$ where $\u03bb$ is either a number (eigenvalue) a vector of eigenvalues $v$ is either a vector containing an eigenvector or a matrix whose columns corresponding to the eigenvectors.  The first parameter optional parameter in all NEP solver methods is a type. This type specifies which arithmetic should be used for the algorithm.  Example:  julia> nep=nep_gallery(\"dep0\")\njulia> \u03bb,v=augnewton(Complex128,nep,v=ones(5))\n(0.8347353572199425 + 0.0im, Complex{Float64}[0.480386+0.0im, 0.0631636+0.0im, -0.136405+0.0im, 0.214274+0.0im, 0.378581+0.0im])\njulia> typeof(\u03bb)\nComplex{Float64}\njulia> \u03bb,v=augnewton(Float16,nep,v=ones(5))\n(Float16(0.8223), Float16[0.47388, 0.063904, -0.13843, 0.21692, 0.38306])\njulia> typeof(\u03bb)\nFloat16",
            "title": "NEP Methods"
        },
        {
            "location": "/methods/#newton-type-methods",
            "text": "#  NEPSolver.newton  \u2014  Function .  \u03bb,v = newton([eltype],nep::NEP;[errmeasure,][tol,][maxit,][\u03bb,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max])  Applies Newton-Raphsons method on the system of nonlinear equations with  n+1  unknowns:  $$\nM(\u03bb)v=0\n$$  $$\nc^Hv-1=0\n$$  The kwarg  errmeasure  is a function handle which can be used to specify how the error is measured to be used in termination (default is absolute residual norm). The iteration is continued until errmeausure is less than  tol .  \u03bb  and  v  are starting approximations.  c  is the orthogonalization vector.  If  c=0  the current approximation will be used for the orthogonalization.  armijo_factor  specifies if an Armijo rule should be applied, and its value specifies the scaling factor of the step length (per reduction step). The variable  armijo_max  specifies the maximum number of step length reductions.  Example  julia> nep=nep_gallery(\"dep0\");\njulia> \u03bb,v=newton(nep);\njulia> minimum(svdvals(compute_Mder(nep,\u03bb)))\n1.6066157878930876e-16  References   Nichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.  A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689   source  #  NEPSolver.augnewton  \u2014  Function .  augnewton([eltype], nep::NEP; [errmeasure,][tol,][maxit,][\u03bb,][v,][c,][displaylevel,][linsolvercreator,][armijo_factor,][armijo_max])  Run the augmented Newton method. The method is equivalent to  newton()  in exact arithmetic,  but works only with operations on vectors of length  n . The  linsolvecreator  is used to initiate linear solvers. See  newton()  for other parameters.  Example  This illustrates the equivalence between  newton  and  augnewton .  julia> nep=nep_gallery(\"dep1\")\njulia> \u03bb1,v1=newton(nep,maxit=20,v=ones(size(nep,1)),\u03bb=0)\njulia> \u03bb2,v2=augnewton(nep,maxit=20,v=ones(size(nep,1)),\u03bb=0)\njulia> \u03bb1-\u03bb2\n0.0 + 0.0im  References   Nichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.  A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689   source  #  NEPSolver.resinv  \u2014  Function .  \u03bb,v = resinv([eltype],nep::NEP;[errmeasure,][tol,][maxit,][\u03bb,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max,][linsolvecreator])  Applies residual inverse iteration method for nonlinear eigenvalue problems. The kwarg  linsolvecreator  is a function which specifies how the linear system is created. The function calls  compute_rf  for the computation of the Rayleigh functional. See  newton()  for other parameters.  Example  The example shows how to specify if the method should run in real or complex mode (or any other  Number  type).  julia> nep=nep_gallery(\"qdep0\");\njulia> \u03bb,v=resinv(nep,\u03bb=-2,v=ones(size(nep,1)))\njulia> typeof(\u03bb)\nComplex{Float64}\njulia> norm(compute_Mlincomb(nep,\u03bb,v))\n1.817030659827106e-14\njulia> \u03bb,v=resinv(Float64,nep,\u03bb=-2,v=ones(size(nep,1)))\njulia> typeof(\u03bb)\nFloat64\njulia> norm(compute_Mlincomb(nep,\u03bb,v))\n1.817030659827106e-14  References   A. Neumaier, Residual inverse iteration for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 22 (1985) 914-923   source  #  NEPSolver.quasinewton  \u2014  Function .  quasinewton([T=Complex128],nep,[errmeasure,][tol,][maxit,][\u03bb,][v][ws][displaylevel][linsolvercreator,][armijo_factor,][armijo_max])  An implementation of the quasi-Newton approach referred to as quasi-Newton 2 in the reference. The method involves one linear system solve per iteration corresponding with the matrix $M(\u03bb)$, where $\u03bb$ is constant. The vector  ws  is a representation of the normalization, in the sense that $c^T=w_s^TM(\u03bb)$, where all iterates satisfy $c^Tx_i=1$. See  newton()  for other parameters.  Example  julia> nep=nep_gallery(\"pep0\")\njulia> \u03bb,v=quasinewton(nep,v=ones(size(nep,1)));\njulia> norm(compute_Mlincomb(nep,\u03bb,v))/norm(v)\n6.301479387102376e-15  References   Jarlebring, Koskela, Mele, Disguised and new Quasi-Newton methods for nonlinear eigenvalue problems, arxiv preprint: https://arxiv.org/abs/1702.08492   source  #  NEPSolver.mslp  \u2014  Function .   mslp([eltype],nep::NEP;[errmeasure,][tol,][maxit,][\u03bb,][v,][displaylevel,][eigsolvertype::DataType][armijo_factor=1,][armijo_max])  Runs the method of successive linear problems. The  method requires the solution of a generalized eigenvalue problem in every iteration. The method used for the eigenvalue computation is specified in eigsolvertype. See  newton  for other parameters.  Example  Create a rational NEP with SPMFs.  julia> Av=[ones(3,3),eye(3,3),triu(ones(3,3))];\njulia> fv=[S-> S, S -> S^2, S::AbstractArray -> inv(full(S)-eye(S)*10)]\njulia> nep=SPMF_NEP(Av,fv)\njulia> (\u03bb,v)=mslp(nep)\njulia> compute_Mlincomb(nep,\u03bb,v)\n3-element Array{Complex{Float64},1}:\n -1.38778e-17+1.65715e-18im\n -5.55112e-17+1.30633e-17im\n -4.16334e-17-1.54436e-17im  References   A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689   source  #  NEPSolver.rfi  \u2014  Function .  rfi(nep,nept,[\u03bb=0,][errmeasure=default_errmeasure,][tol=eps()*100,][maxit=100,][v=randn,][u=randn,][displaylevel=0,][linsolvecreator=default_linsolvecreator,])  Two-sided Rayleigh functional Iteration, as given as Algorithm 4 in  \"Nonlinear Eigenvalue Problems: Newton-type Methods and Nonlinear Rayleigh Functionals\", by Kathrin Schreiber.  source  #  NEPSolver.newtonqr  \u2014  Function .  Newton-QR method.  source  #  NEPSolver.implicitdet  \u2014  Function .  Implicit determinant method  source",
            "title": "Newton type methods"
        },
        {
            "location": "/methods/#projection-methods",
            "text": "NEPSolver.nlar",
            "title": "Projection methods"
        },
        {
            "location": "/methods/#arnoldi-type-methods",
            "text": "#  NEPSolver.iar  \u2014  Function .  iar(nep,[maxit=30,][\u03c3=0,][\u03b3=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])  Infinite Arnoldi method  Infinite Arnoldi method, as described in Algorithm 2 in  \"A linear eigenvalue algorithm for the nonlinear eigenvalue problem\", by Jarlebring, Elias and Michiels, Wim and Meerbergen, Karl.  source  #  NEPSolver.tiar  \u2014  Function .  tiar(nep,[maxit=30,][\u03c3=0,][\u03b3=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])  Tensor Infinite Arnoldi method  Tensor Infinite Arnoldi method, as described in Algorithm 2 in  \"The Waveguide Eigenvalue Problem and the Tensor Infinite Arnoldi Method\", by Jarlebring, Elias and Mele, Giampaolo and Runborg, Olof.  source  #  NEPSolver.infbilanczos  \u2014  Function .  \u03bbv,V,U=infbilanczos([eltype],nep, nept,[linsolvecreator,][linsolvertcreator,][v,][u,][\u03c3,][\u03b3,][tol,][Neig,][errmeasure,][displaylevel,][maxit,][check_error_every])  Executes the Infinite Bi-Lanczos method on the problem defined by  nep::NEP  and  nept::NEP .  nep:NEP  is the original nonlinear eigenvalue problem and  nept::NEP  is its (hermitian) transpose: $M(lambda^*)^H$.   v  and  u  are starting vectors,  \u03c3  is the shift and  \u03b3  the scaling.  See  newton()  for other parameters.  Example:  julia> nep=nep_gallery(\"dep0\");\njulia> A=get_Av(nep); fv=get_fv(nep);\njulia> nept=SPMF_NEP([A[1]',A[2]',A[3]'],fv); # Create the transposed NEP\njulia> \u03bbv,V=infbilanczos(nep,nept,Neig=3)\njulia> norm(compute_Mlincomb(nep,\u03bbv[1],V[:,1]))  References:   The infinite bi-Lanczos method for nonlinear eigenvalue problems, S. W. Gaaf and E. Jarlebring, arxiv: 1607.03454, to appear in SIAM J. Scientific Computing   source",
            "title": "Arnoldi type methods"
        },
        {
            "location": "/methods/#class-specific-methods",
            "text": "",
            "title": "Class specific methods"
        },
        {
            "location": "/methods/#companion-linearizations",
            "text": "",
            "title": "Companion linearizations"
        },
        {
            "location": "/methods/#rational",
            "text": "",
            "title": "Rational ?"
        },
        {
            "location": "/types/",
            "text": "The basic type\n\n\nThe basic class is the abstract class \nNEP\n which represents a NEP. \n\n\n#\n\n\nNEPCore.NEP\n \u2014 \nType\n.\n\n\nabstract NEP\n\n\n\n\nA \nNEP\n object represents a nonlinear eigenvalue problem. All NEPs should implement\n\n\nsize(nep::NEP,d)\n\n\n\n\nand at least one of the following\n\n\nM=compute_Mder(nep::NEP,\u03bb::Number;der=0)\nV=compute_Mlincomb(nep::NEP,\u03bb::Number,V::Array{<:Number,2})\nMM=compute_MM(nep::NEP,S::Array{<:Number,2},V::Array{<:Number,2})\n\n\n\n\nsource\n\n\n\n\nAccessing the NEP\n\n\nThe nonlinear eigenvalue problem is defined by the data stored in the NEP-class, and the NEP-solvers access the data mainly through three main functions, \ncompute_Mder\n \ncompute_Mlincomb\n and \ncompute_MM\n.\n\n\n#\n\n\nNEPCore.compute_Mder\n \u2014 \nMethod\n.\n\n\ncompute_Mder(nep::NEP,\u03bb::Number [,i::Integer=0])\n\n\n\n\nComputes the ith derivative of \nnep\n evaluated in \n\u03bb\n.\n\n\nExample\n\n\nThis example shows that \ncompute_Mder(nep,\u03bb,1)\n gives the first derivative.\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> \u03f5=1e-5;\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aplus=compute_Mder(nep,\u03bb+\u03f5);\njulia> norm((Aplus-Aminus)/(2\u03f5)-compute_Mder(nep,\u03bb,1))\n1.990970375089371e-11\n\n\n\n\nsource\n\n\n#\n\n\nNEPCore.compute_Mlincomb\n \u2014 \nMethod\n.\n\n\ncompute_Mlincomb(nep::NEP,\u03bb::Number,V;a=ones(size(V,2)))\n\n\n\n\nComputes the linear combination of derivatives\n$\u03a3_i a_i M^{(i)}(\u03bb) v_i$\n\n\nExample\n\n\nThis example shows that \ncompute_Mder\n gives a result consistent with \ncompute_Mlincomb\n. Note that \ncompute_Mlincomb\n is in general faster since no matrix needs to be constructed.\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> v=ones(size(nep,1)); \u03bb=-1+1im;\njulia> norm(compute_Mder(nep,\u03bb,1)*v-compute_Mlincomb(nep,\u03bb,hcat(v,v),a=[0,1]))\n1.0778315928076987e-15\n\n\n\n\n\nsource\n\n\n#\n\n\nNEPCore.compute_MM\n \u2014 \nFunction\n.\n\n\ncompute_MM(nep::NEP,S,V)\n\n\n\n\nComputes the sum $\u03a3_i M_i V f_i(S)$ for a NEP, where $S$ and $V$ are matrices, and the NEP satisfies $M(\u03bb)=\u03a3_i M_i f_i(\u03bb)$.\n\n\nExample\n\n\nThis example shows that for diagonal \nS\n, the result of \ncompute_MM\n can also be computed with \ncompute_Mlincomb\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> D=diagm([1,2])\n2\u00d72 Array{Int64,2}:\n 1  0\n 0  2\njulia> V=ones(size(n,1),2);\njulia> W=compute_MM(nep,D,V);\njulia> norm(W[:,1]-compute_Mlincomb(nep,D[1,1],V[:,1]))\n1.1102230246251565e-16\njulia> norm(W[:,2]-compute_Mlincomb(nep,D[2,2],V[:,2]))\n0.0\n\n\n\n\nReference\n\n\nProperties of the quantity $\u03a3_i M_i V f_i(S)$ for non-polynomial nonlinear eigenvalue problems were extensively used in:\n\n\n\n\nD. Kressner A block Newton method for nonlinear eigenvalue problems, Numer. Math., 114 (2) (2009), pp. 355-372\n\n\nC. Effenberger, Robust solution methods for nonlinear eigenvalue problems, PhD thesis, 2013, EPF Lausanne\n\n\n\n\nsource\n\n\n\n\nNEPTypes\n\n\nIn order to use the methods, the user has the possibility to implement their own problem-specific functions above, or use one of the predefined types. The most common one is the \nSPMF_NEP\n.\n\n\n#\n\n\nNEPTypes.SPMF_NEP\n \u2014 \nType\n.\n\n\ntype SPMF_NEP <: AbstractSPMF\n\n\n\n\nAn SPMF_NEP is a NEP defined by a Sum of Products of Matrices and Functions, i.e.,\n\n\n$$\nM(\u03bb)=\u2211_i A_i f_i(\u03bb).\n$$\n\n\nAll of the matrices $A_0,...$ are of size $n\u00d7n$ and $f_i$ are a functions. The  functions $f_i$ must be defined for matrices in the standard matrix function sense.\n\n\nsource\n\n\nIn order to construct an \nSPMF_NEP\n, we need to provide the matrices and the functions.\n\n\nSPMF_NEP(AA::Array, fii::Array{Function,1}) \n\n\n\n\n#\n\n\nNEPCore.compute_Mder\n \u2014 \nFunction\n.\n\n\ncompute_Mder(nep::NEP,\u03bb::Number [,i::Integer=0])\n\n\n\n\nComputes the ith derivative of \nnep\n evaluated in \n\u03bb\n.\n\n\nExample\n\n\nThis example shows that \ncompute_Mder(nep,\u03bb,1)\n gives the first derivative.\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> \u03f5=1e-5;\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aplus=compute_Mder(nep,\u03bb+\u03f5);\njulia> norm((Aplus-Aminus)/(2\u03f5)-compute_Mder(nep,\u03bb,1))\n1.990970375089371e-11\n\n\n\n\nsource\n\n\n#\n\n\nNEPCore.compute_Mlincomb\n \u2014 \nFunction\n.\n\n\ncompute_Mlincomb(nep::NEP,\u03bb::Number,V;a=ones(size(V,2)))\n\n\n\n\nComputes the linear combination of derivatives\n$\u03a3_i a_i M^{(i)}(\u03bb) v_i$\n\n\nExample\n\n\nThis example shows that \ncompute_Mder\n gives a result consistent with \ncompute_Mlincomb\n. Note that \ncompute_Mlincomb\n is in general faster since no matrix needs to be constructed.\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> v=ones(size(nep,1)); \u03bb=-1+1im;\njulia> norm(compute_Mder(nep,\u03bb,1)*v-compute_Mlincomb(nep,\u03bb,hcat(v,v),a=[0,1]))\n1.0778315928076987e-15\n\n\n\n\n\nsource\n\n\ncompute_Mlincomb(nep::NEP,\u03bb::Number,V,a::Array,startder::Integer)\n\n\n\n\nComputes linear combination starting with derivative startder, i.e., $\u03a3_i a_i M^{(i+startder)}(\u03bb) v_i$\n\n\nThe default implementation of this can be slow. Overload for specific NEP if you want efficiency (for aug_newton, IAR, ..).\n\n\nsource\n\n\nLet's try an equation $x=f(x)$. (a \\ne 0)\n\n\n$$\nx=x_1+1\n$$",
            "title": "NEP Types"
        },
        {
            "location": "/types/#the-basic-type",
            "text": "The basic class is the abstract class  NEP  which represents a NEP.   #  NEPCore.NEP  \u2014  Type .  abstract NEP  A  NEP  object represents a nonlinear eigenvalue problem. All NEPs should implement  size(nep::NEP,d)  and at least one of the following  M=compute_Mder(nep::NEP,\u03bb::Number;der=0)\nV=compute_Mlincomb(nep::NEP,\u03bb::Number,V::Array{<:Number,2})\nMM=compute_MM(nep::NEP,S::Array{<:Number,2},V::Array{<:Number,2})  source",
            "title": "The basic type"
        },
        {
            "location": "/types/#accessing-the-nep",
            "text": "The nonlinear eigenvalue problem is defined by the data stored in the NEP-class, and the NEP-solvers access the data mainly through three main functions,  compute_Mder   compute_Mlincomb  and  compute_MM .  #  NEPCore.compute_Mder  \u2014  Method .  compute_Mder(nep::NEP,\u03bb::Number [,i::Integer=0])  Computes the ith derivative of  nep  evaluated in  \u03bb .  Example  This example shows that  compute_Mder(nep,\u03bb,1)  gives the first derivative.  julia> nep=nep_gallery(\"dep0\");\njulia> \u03f5=1e-5;\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aplus=compute_Mder(nep,\u03bb+\u03f5);\njulia> norm((Aplus-Aminus)/(2\u03f5)-compute_Mder(nep,\u03bb,1))\n1.990970375089371e-11  source  #  NEPCore.compute_Mlincomb  \u2014  Method .  compute_Mlincomb(nep::NEP,\u03bb::Number,V;a=ones(size(V,2)))  Computes the linear combination of derivatives\n$\u03a3_i a_i M^{(i)}(\u03bb) v_i$  Example  This example shows that  compute_Mder  gives a result consistent with  compute_Mlincomb . Note that  compute_Mlincomb  is in general faster since no matrix needs to be constructed.  julia> nep=nep_gallery(\"dep0\");\njulia> v=ones(size(nep,1)); \u03bb=-1+1im;\njulia> norm(compute_Mder(nep,\u03bb,1)*v-compute_Mlincomb(nep,\u03bb,hcat(v,v),a=[0,1]))\n1.0778315928076987e-15  source  #  NEPCore.compute_MM  \u2014  Function .  compute_MM(nep::NEP,S,V)  Computes the sum $\u03a3_i M_i V f_i(S)$ for a NEP, where $S$ and $V$ are matrices, and the NEP satisfies $M(\u03bb)=\u03a3_i M_i f_i(\u03bb)$.  Example  This example shows that for diagonal  S , the result of  compute_MM  can also be computed with  compute_Mlincomb  julia> nep=nep_gallery(\"dep0\");\njulia> D=diagm([1,2])\n2\u00d72 Array{Int64,2}:\n 1  0\n 0  2\njulia> V=ones(size(n,1),2);\njulia> W=compute_MM(nep,D,V);\njulia> norm(W[:,1]-compute_Mlincomb(nep,D[1,1],V[:,1]))\n1.1102230246251565e-16\njulia> norm(W[:,2]-compute_Mlincomb(nep,D[2,2],V[:,2]))\n0.0  Reference  Properties of the quantity $\u03a3_i M_i V f_i(S)$ for non-polynomial nonlinear eigenvalue problems were extensively used in:   D. Kressner A block Newton method for nonlinear eigenvalue problems, Numer. Math., 114 (2) (2009), pp. 355-372  C. Effenberger, Robust solution methods for nonlinear eigenvalue problems, PhD thesis, 2013, EPF Lausanne   source",
            "title": "Accessing the NEP"
        },
        {
            "location": "/types/#neptypes",
            "text": "In order to use the methods, the user has the possibility to implement their own problem-specific functions above, or use one of the predefined types. The most common one is the  SPMF_NEP .  #  NEPTypes.SPMF_NEP  \u2014  Type .  type SPMF_NEP <: AbstractSPMF  An SPMF_NEP is a NEP defined by a Sum of Products of Matrices and Functions, i.e.,  $$\nM(\u03bb)=\u2211_i A_i f_i(\u03bb).\n$$  All of the matrices $A_0,...$ are of size $n\u00d7n$ and $f_i$ are a functions. The  functions $f_i$ must be defined for matrices in the standard matrix function sense.  source  In order to construct an  SPMF_NEP , we need to provide the matrices and the functions.  SPMF_NEP(AA::Array, fii::Array{Function,1})   #  NEPCore.compute_Mder  \u2014  Function .  compute_Mder(nep::NEP,\u03bb::Number [,i::Integer=0])  Computes the ith derivative of  nep  evaluated in  \u03bb .  Example  This example shows that  compute_Mder(nep,\u03bb,1)  gives the first derivative.  julia> nep=nep_gallery(\"dep0\");\njulia> \u03f5=1e-5;\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aplus=compute_Mder(nep,\u03bb+\u03f5);\njulia> norm((Aplus-Aminus)/(2\u03f5)-compute_Mder(nep,\u03bb,1))\n1.990970375089371e-11  source  #  NEPCore.compute_Mlincomb  \u2014  Function .  compute_Mlincomb(nep::NEP,\u03bb::Number,V;a=ones(size(V,2)))  Computes the linear combination of derivatives\n$\u03a3_i a_i M^{(i)}(\u03bb) v_i$  Example  This example shows that  compute_Mder  gives a result consistent with  compute_Mlincomb . Note that  compute_Mlincomb  is in general faster since no matrix needs to be constructed.  julia> nep=nep_gallery(\"dep0\");\njulia> v=ones(size(nep,1)); \u03bb=-1+1im;\njulia> norm(compute_Mder(nep,\u03bb,1)*v-compute_Mlincomb(nep,\u03bb,hcat(v,v),a=[0,1]))\n1.0778315928076987e-15  source  compute_Mlincomb(nep::NEP,\u03bb::Number,V,a::Array,startder::Integer)  Computes linear combination starting with derivative startder, i.e., $\u03a3_i a_i M^{(i+startder)}(\u03bb) v_i$  The default implementation of this can be slow. Overload for specific NEP if you want efficiency (for aug_newton, IAR, ..).  source  Let's try an equation $x=f(x)$. (a \\ne 0)  $$\nx=x_1+1\n$$",
            "title": "NEPTypes"
        },
        {
            "location": "/transformations/",
            "text": "Transforming NEPs\n\n\nThere are various ways to transform NEPs into other NEPs. The simplest example is the function \nshift_and_scale()\n.\n\n\n#\n\n\nNEPTypes.shift_and_scale\n \u2014 \nFunction\n.\n\n\nshift_and_scale(orgnep::NEP;shift=0,scale=1)\n\n\n\n\nTransforms the orgnep by defining a new NEP from the relation T(\u03bb)=M(scale * \u03bb+shift) where M is the orgnep. This function tries  to preserve the NEP type.\n\n\nExample\n\n\njulia> nep0=nep_gallery(\"pep0\")\njulia> \u03c3=3; \u03b1=10;\njulia> nep1=shift_and_scale(nep0,shift=\u03c3,scale=\u03b1)\njulia> norm(compute_Mder(nep0,\u03b1*(4+4im)+\u03c3)-compute_Mder(nep1,4+4im))\n8.875435870738592e-12\n\n\n\n\nsource\n\n\nSimilarly \nmobius_transform()\n is more general than \nshift_and_scale\n which transform the problem using a M\u00f6bius transformation. The function \ntaylor_exp\n create new PEP by doing truncating a Taylor expansion.\n\n\n\n\nProjection\n\n\nSeveral methods for NEPs are based on forming a smaller NEP, which we will refer to as a projection:\n\n\n$$\nN(\u03bb)=W^HM(\u03bb)V,\n$$\n\n\nwhere $V,W\\in\\mathbb{C}^{n\\times p}$  and the corresponding projected problem\n\n\n$$\nN(\u03bb)u=0.\n$$\n\n\nNEPs which for which this projection can be computed inherit from \nProjectableNEP\n. The most important type is the \nSPMF_NEP\n. \n\n\nYou can create a projected NEP with \ncreate_proj_NEP\n:\n\n\n#\n\n\nNEPTypes.create_proj_NEP\n \u2014 \nFunction\n.\n\n\npnep=create_proj_NEP(orgnep::ProjectableNEP)\n\n\n\n\nCreate a NEP representing a projected problem. The projection is defined as the problem $N(\u03bb)=W^HM(\u03bb)V$ where $M(\u03bb)$ is represented by \norgnep\n. Use \nset_projectionmatrices!()\n to specify projection matrices $V$ and $W$.\n\n\nsource\n\n\n#\n\n\nNEPTypes.set_projectmatrices!\n \u2014 \nMethod\n.\n\n\nset_projectmatrices!(pnep::Proj_NEP,W,V)\n\n\n\n\nSet the projection matrices for the NEP to W and V, i.e., corresponding the NEP: $N(\u03bb)=W^HM(\u03bb)V$.\n\n\nExample:\n\n\nThe following example illustrates that a projection of a \nNEP\n is also a \nNEP\n and we can for instance call \ncompute_Mder\non it:\n\n\njulia> nep=nep_gallery(\"pep0\")\njulia> V=eye(size(nep,1),2);\njulia> W=eye(size(nep,1),2);\njulia> pnep=create_proj_NEP(nep);\njulia> set_projectmatrices!(pnep,W,V);\njulia> compute_Mder(pnep,\u03bb)\n2\u00d72 Array{Float64,2}:\n -2.03662   13.9777\n -1.35069  -13.0975\njulia> compute_Mder(nep,\u03bb)[1:2,1:2]\n2\u00d72 Array{Float64,2}:\n -2.03662   13.9777\n -1.35069  -13.0975\n\n\n\n\nsource\n\n\n\n\nDeflation\n\n\nDue to structure of the representation of NEPs in NEP-PACK it is possible to do deflation, by transformation of the NEP-object. The deflation is based on theory provided in Effenbergers thesis and the main function consists of \neffenberger_deflation\n.\n\n\n#\n\n\nNEPTypes.effenberger_deflation\n \u2014 \nFunction\n.\n\n\neffenberger_deflation(nep::NEP,S0,V0)\n\n\n\n\nA deflation procedure as described in the PhD thesis of Effenberger. More documentation to come.\n\n\n\n\nExample:\n\n\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> (\u03bb,v)=newton(nep);\njulia> n=size(nep,1);\njulia> S0=reshape([\u03bb],1,1);\njulia> V0=reshape(v,n,1);\njulia> dnep=effenberger_deflation(nep,S0,V0)\njulia> (\u03bb2,v2)=augnewton(dnep);  # this converges to different eigval\njulia> minimum(svdvals(compute_Mder(nep,\u03bb2)))\n9.323003321058995e-17\n\n\n\n\nsource",
            "title": "NEP transformations"
        },
        {
            "location": "/transformations/#transforming-neps",
            "text": "There are various ways to transform NEPs into other NEPs. The simplest example is the function  shift_and_scale() .  #  NEPTypes.shift_and_scale  \u2014  Function .  shift_and_scale(orgnep::NEP;shift=0,scale=1)  Transforms the orgnep by defining a new NEP from the relation T(\u03bb)=M(scale * \u03bb+shift) where M is the orgnep. This function tries  to preserve the NEP type.  Example  julia> nep0=nep_gallery(\"pep0\")\njulia> \u03c3=3; \u03b1=10;\njulia> nep1=shift_and_scale(nep0,shift=\u03c3,scale=\u03b1)\njulia> norm(compute_Mder(nep0,\u03b1*(4+4im)+\u03c3)-compute_Mder(nep1,4+4im))\n8.875435870738592e-12  source  Similarly  mobius_transform()  is more general than  shift_and_scale  which transform the problem using a M\u00f6bius transformation. The function  taylor_exp  create new PEP by doing truncating a Taylor expansion.",
            "title": "Transforming NEPs"
        },
        {
            "location": "/transformations/#projection",
            "text": "Several methods for NEPs are based on forming a smaller NEP, which we will refer to as a projection:  $$\nN(\u03bb)=W^HM(\u03bb)V,\n$$  where $V,W\\in\\mathbb{C}^{n\\times p}$  and the corresponding projected problem  $$\nN(\u03bb)u=0.\n$$  NEPs which for which this projection can be computed inherit from  ProjectableNEP . The most important type is the  SPMF_NEP .   You can create a projected NEP with  create_proj_NEP :  #  NEPTypes.create_proj_NEP  \u2014  Function .  pnep=create_proj_NEP(orgnep::ProjectableNEP)  Create a NEP representing a projected problem. The projection is defined as the problem $N(\u03bb)=W^HM(\u03bb)V$ where $M(\u03bb)$ is represented by  orgnep . Use  set_projectionmatrices!()  to specify projection matrices $V$ and $W$.  source  #  NEPTypes.set_projectmatrices!  \u2014  Method .  set_projectmatrices!(pnep::Proj_NEP,W,V)  Set the projection matrices for the NEP to W and V, i.e., corresponding the NEP: $N(\u03bb)=W^HM(\u03bb)V$.  Example:  The following example illustrates that a projection of a  NEP  is also a  NEP  and we can for instance call  compute_Mder on it:  julia> nep=nep_gallery(\"pep0\")\njulia> V=eye(size(nep,1),2);\njulia> W=eye(size(nep,1),2);\njulia> pnep=create_proj_NEP(nep);\njulia> set_projectmatrices!(pnep,W,V);\njulia> compute_Mder(pnep,\u03bb)\n2\u00d72 Array{Float64,2}:\n -2.03662   13.9777\n -1.35069  -13.0975\njulia> compute_Mder(nep,\u03bb)[1:2,1:2]\n2\u00d72 Array{Float64,2}:\n -2.03662   13.9777\n -1.35069  -13.0975  source",
            "title": "Projection"
        },
        {
            "location": "/transformations/#deflation",
            "text": "Due to structure of the representation of NEPs in NEP-PACK it is possible to do deflation, by transformation of the NEP-object. The deflation is based on theory provided in Effenbergers thesis and the main function consists of  effenberger_deflation .  #  NEPTypes.effenberger_deflation  \u2014  Function .  effenberger_deflation(nep::NEP,S0,V0)  A deflation procedure as described in the PhD thesis of Effenberger. More documentation to come.   Example:   julia> nep=nep_gallery(\"dep0\");\njulia> (\u03bb,v)=newton(nep);\njulia> n=size(nep,1);\njulia> S0=reshape([\u03bb],1,1);\njulia> V0=reshape(v,n,1);\njulia> dnep=effenberger_deflation(nep,S0,V0)\njulia> (\u03bb2,v2)=augnewton(dnep);  # this converges to different eigval\njulia> minimum(svdvals(compute_Mder(nep,\u03bb2)))\n9.323003321058995e-17  source",
            "title": "Deflation"
        },
        {
            "location": "/gallery/",
            "text": "A large number of examples are provided in the \nnep_gallery\n.\n\n\njulia> using Gallery\njulia> nep=nep_gallery(\"dep0\")\njulia> \u03bb,v=newton(nep)\n(-0.3587189459686265 + 0.0im, Complex{Float64}[0.284742+0.0im, -0.143316+0.0im, 0.278378+0.0im, -0.5009+0.0im, -0.613634+0.0im])\njulia> norm(compute_Mlincomb(nep,\u03bb,v))\n4.718447854656915e-16\n\n\n\n\nIf MATLAB and the Berlin-Manchester collection areinstalled, we can access them with the GalleryNLEVP (which does MATLAB-access through julia's MATLAB-package).\n\n\njulia> using GalleryNLEVP\njulia> nep=nep_gallery(NLEVP_NEP,\"hadeler\")\njulia> \u03bb,v=quasinewton(nep,\u03bb=0.2,displaylevel=1,maxit=20,tol=1e-10);\njulia> norm(compute_Mlincomb(nep,\u03bb,v))/norm(v)\n9.698206079849311e-11\n\n\n\n\nProblems loaded from the Berlin-Manchester collection are NEP-objects where every call to access a function generates a call to an underlying MATLAB-session. Some problems in the Berlin-Manchester collection have native support in NEPPACK, i.e., avoiding a MATLAB-access in every call. The native equivalent object is generated with  \nnlevp_make_native\n:\n\n\njulia> using GalleryNLEVP\njulia> nep1=nep_gallery(NLEVP_NEP,\"gun\")\njulia> nep2=nlevp_make_native(nep1);\njulia> norm(compute_Mder(nep1,0)-compute_Mder(nep2,0),1)\n0.0\n\n\n\n\nStand-alone implementation can be accessed in a similar way, e.g., a native implementation of the waveguide eigenvalue problem:\n\n\njulia> using GalleryWaveguide\njulia> nep=nep_gallery(WEP,benchmark_problem=\"TAUSCH\");",
            "title": "NEP Gallery"
        }
    ]
}