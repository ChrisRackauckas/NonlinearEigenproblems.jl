{
    "docs": [
        {
            "location": "/",
            "text": "NEPPACK\n\n\nNEPPACK is a package with implementations of methods to solve nonlinear eigenvalue problems of the type: Find $(\u03bb,v)\\in\\mathbb{C}\\times\\mathbb{C}^n$ such that\n\n\n$$\nM(\u03bb)v=0\n$$\n\n\nand $v\\neq 0$.\n\n\n\n\nGetting started\n\n\nInstall it as an unregistered package in julia's REPL package mode by writing \n] add git:/..\n:\n\n\njulia> ]\n(v1.0) pkg> add git://github.com/nep-pack/NonlinearEigenproblems.jl.git\n\n\n\n\n\nThen we can start to load the NEP-PACK package\n\n\njulia> using NonlinearEigenproblems\n\n\n\n\nWe are now ready to create and solve a nonlinear eigenvalue problem, in this illustrative example we set\n\n\n$$\nM(\u03bb)=\\begin{bmatrix}1&3\\newline5&6\\end{bmatrix}+\n\u03bb\\begin{bmatrix}3&4\\newline6&6\\end{bmatrix}+\n\u03bb^2\\begin{bmatrix}1&0\\newline0&1\\end{bmatrix}\n$$\n\n\nThe following code creates this NEP (which is a so called polynomial eigenvalue problem) and solves it using the NEP solution method implemented in \npolyeig()\n:\n\n\njulia> A0=[1.0 3; 5 6]; A1=[3.0 4; 6 6]; A2=[1.0 0; 0 1.0];\njulia> nep=PEP([A0,A1,A2])\nPEP(2, Array{Float64,2}[[1.0 3.0; 5.0 6.0], [3.0 4.0; 6.0 6.0], [1.0 0.0; 0.0 1.0]])\njulia> \u03bb,v=polyeig(nep)\n(Complex{Float64}[1.36267+0.0im, -0.824084+0.280682im, -0.824084-0.280682im, -8.7145+0.0im], Complex{Float64}[-1.0+0.0im 0.739183-0.196401im 0.739183+0.196401im 0.627138+0.0im; 0.821812+0.0im -0.501408-0.375337im -0.501408+0.375337im 1.0+0.0im])\n\n\n\n\nYou have now solved your first nonlinear eigenvalue problem with NEPPACK.\n\n\nIn order to verify that we have a solution, we can check that  $M(\u03bb)$ is singular, with a singular vector $v$ such that $M(\u03bb)v=0$:\n\n\njulia> \u03bb1=\u03bb[1]; v1=v[:,1];\njulia> using LinearAlgebra # the norm-function is in this julia package\njulia> norm(A0*v1+\u03bb1*A1*v1+\u03bb1^2*v1)/norm(v1)\n1.1502634749464687e-14\n\n\n\n\n\n\nAccessing more complicated applications\n\n\nWe have made benchmark examples available in through the function \nnep_gallery\n:\n\n\njulia> nep=nep_gallery(\"dep0\",100);\njulia> size(nep)\n(100, 100)\njulia> \u03bb,v=mslp(nep,tol=1e-10);\njulia> \u03bb\n0.23169217667341738 - 2.1866254654451488e-16im\njulia> size(v)\n(100,)\njulia> resnorm=norm(compute_Mlincomb(nep,\u03bb,v))\n3.124042808475689e-14\n\n\n\n\nInformation about the gallery can be found by typing \n?nep_gallery\n. The second arument in the call to \nnep_gallery\n is a problem parameter, in this case specifying that the  size of the problem should be \n100\n. The example solves the problem with the method MSLP. The parameter \ntol\n specifies the tolerance for iteration termination. Type \n?mslp\n for more information about this method.\n\n\n\n\nA model of a neuron\n\n\nThe following (delay) differential equation models a neuron\n\n\n$$\n\\dot{x}_1(t)=-\\kappa x_1(t)+\\beta\\tanh(x_1(t-\\tau_3))+a_1\\tanh(x_2(t-\\tau_2))\n$$\n\n\n$$\n\\dot{x}_2(t)=-\\kappa x_2(t)+\\beta\\tanh(x_2(t-\\tau_3))+a_2\\tanh(x_1(t-\\tau_1))\n$$\n\n\nSee \nL. P. Shayer and S. A. Campbell.  Stability, bifurcation and multistability in a system of two coupled neurons with multiple time delays. SIAM J. Applied Mathematics , 61(2):673\u2013700, 2000\n. It is also available as a first demo in \nDDE-BIFTOOL\n. The linear stability analysis of this problem requires the solution of a nonlinear eigenvalue eigenvalue problem\n\n\n$$\nM(\u03bb)=-\u03bbI+A_0+A_1e^{-\\tau_1\u03bb}+A_2e^{-\\tau_2\u03bb}+A_3e^{-\\tau_3\u03bb}\n$$\n\n\nwhere the matrices are the Jacobian at the stationary solution. For the zero stationary solution, the matrices are\n\n\nkappa=0.5; a2=2.34; a1=1; beta=-1;\nA0=-kappa*[1 0; 0 1];\nA1=a2*[0 0; 1 0];\nA2=a1*[0 1; 0 0];\nA3=beta*[1 0; 0 1];\n\n\n\n\nWe can now create the nonlinear eigenvalue problem and compute the stability by first creating the problem\n\n\njulia> tauv=[0;0.2;0.2;1.5];\njulia> dep=DEP([A0, A1,   A2, A3],tauv);\n\n\n\n\nand solving it with for instance the infinite Arnoldi method\n\n\njulia> \u03bb,V=iar_chebyshev(dep,maxit=100); # This takes some time the first time is run due to JIT-compiler\n\n\n\n\nThe figure in a demo of DDE-BIFTOOL \nhttp://ddebiftool.sourceforge.net/demos/neuron/html/demo1_stst.html\n can be directly generated by\n\n\njulia> using PyPlot;\njulia> plot(real(\u03bb),imag(\u03bb),\"*\")\n\n\n\n\nThis problem is also available in the \nGallery\n by calling \ndep=nep_gallery(\"neuron0\")\n.\n\n\n\n\nThe \"gun\" benchmark problem\n\n\nOne of the most common benchmark problems for NEPs is the so-called \"gun\"-problem. It models an electromagnetic cavity, and it is directly available in the \nGallery\n. (See \n?nep_gallery\n for references.) This is how you can solve it with the block Newton method:\n\n\njulia> nep=nep_gallery(\"nlevp_native_gun\");\njulia> S=150^2*[1.0 0; 0 1]; V=[[1 0; 0 1]; zeros(n-2,2)];\njulia> (Z,X)=blocknewton(nep,S=S,X=V,displaylevel=1,armijo_factor=0.5,maxit=20)\nIteration 1: Error: 6.081316e+03\nIteration 2: Error: 1.701970e-02 Armijo scaling=0.031250\nIteration 3: Error: 1.814887e-02 Armijo scaling=0.250000\n...\nIteration 13: Error: 6.257442e-09\nIteration 14: Error: 2.525942e-15\n\n\n\n\nThe solutions are eigenvalues of \nZ\n.\n\n\njulia>\n\n\n\n\nWhat now?\n\n\nNow you are ready to have a look at the examples in \nNEP methods\n and  \nNEP Gallery\n.",
            "title": "Introduction"
        },
        {
            "location": "/#neppack",
            "text": "NEPPACK is a package with implementations of methods to solve nonlinear eigenvalue problems of the type: Find $(\u03bb,v)\\in\\mathbb{C}\\times\\mathbb{C}^n$ such that  $$\nM(\u03bb)v=0\n$$  and $v\\neq 0$.",
            "title": "NEPPACK"
        },
        {
            "location": "/#getting-started",
            "text": "Install it as an unregistered package in julia's REPL package mode by writing  ] add git:/.. :  julia> ]\n(v1.0) pkg> add git://github.com/nep-pack/NonlinearEigenproblems.jl.git  Then we can start to load the NEP-PACK package  julia> using NonlinearEigenproblems  We are now ready to create and solve a nonlinear eigenvalue problem, in this illustrative example we set  $$\nM(\u03bb)=\\begin{bmatrix}1&3\\newline5&6\\end{bmatrix}+\n\u03bb\\begin{bmatrix}3&4\\newline6&6\\end{bmatrix}+\n\u03bb^2\\begin{bmatrix}1&0\\newline0&1\\end{bmatrix}\n$$  The following code creates this NEP (which is a so called polynomial eigenvalue problem) and solves it using the NEP solution method implemented in  polyeig() :  julia> A0=[1.0 3; 5 6]; A1=[3.0 4; 6 6]; A2=[1.0 0; 0 1.0];\njulia> nep=PEP([A0,A1,A2])\nPEP(2, Array{Float64,2}[[1.0 3.0; 5.0 6.0], [3.0 4.0; 6.0 6.0], [1.0 0.0; 0.0 1.0]])\njulia> \u03bb,v=polyeig(nep)\n(Complex{Float64}[1.36267+0.0im, -0.824084+0.280682im, -0.824084-0.280682im, -8.7145+0.0im], Complex{Float64}[-1.0+0.0im 0.739183-0.196401im 0.739183+0.196401im 0.627138+0.0im; 0.821812+0.0im -0.501408-0.375337im -0.501408+0.375337im 1.0+0.0im])  You have now solved your first nonlinear eigenvalue problem with NEPPACK.  In order to verify that we have a solution, we can check that  $M(\u03bb)$ is singular, with a singular vector $v$ such that $M(\u03bb)v=0$:  julia> \u03bb1=\u03bb[1]; v1=v[:,1];\njulia> using LinearAlgebra # the norm-function is in this julia package\njulia> norm(A0*v1+\u03bb1*A1*v1+\u03bb1^2*v1)/norm(v1)\n1.1502634749464687e-14",
            "title": "Getting started"
        },
        {
            "location": "/#accessing-more-complicated-applications",
            "text": "We have made benchmark examples available in through the function  nep_gallery :  julia> nep=nep_gallery(\"dep0\",100);\njulia> size(nep)\n(100, 100)\njulia> \u03bb,v=mslp(nep,tol=1e-10);\njulia> \u03bb\n0.23169217667341738 - 2.1866254654451488e-16im\njulia> size(v)\n(100,)\njulia> resnorm=norm(compute_Mlincomb(nep,\u03bb,v))\n3.124042808475689e-14  Information about the gallery can be found by typing  ?nep_gallery . The second arument in the call to  nep_gallery  is a problem parameter, in this case specifying that the  size of the problem should be  100 . The example solves the problem with the method MSLP. The parameter  tol  specifies the tolerance for iteration termination. Type  ?mslp  for more information about this method.",
            "title": "Accessing more complicated applications"
        },
        {
            "location": "/#a-model-of-a-neuron",
            "text": "The following (delay) differential equation models a neuron  $$\n\\dot{x}_1(t)=-\\kappa x_1(t)+\\beta\\tanh(x_1(t-\\tau_3))+a_1\\tanh(x_2(t-\\tau_2))\n$$  $$\n\\dot{x}_2(t)=-\\kappa x_2(t)+\\beta\\tanh(x_2(t-\\tau_3))+a_2\\tanh(x_1(t-\\tau_1))\n$$  See  L. P. Shayer and S. A. Campbell.  Stability, bifurcation and multistability in a system of two coupled neurons with multiple time delays. SIAM J. Applied Mathematics , 61(2):673\u2013700, 2000 . It is also available as a first demo in  DDE-BIFTOOL . The linear stability analysis of this problem requires the solution of a nonlinear eigenvalue eigenvalue problem  $$\nM(\u03bb)=-\u03bbI+A_0+A_1e^{-\\tau_1\u03bb}+A_2e^{-\\tau_2\u03bb}+A_3e^{-\\tau_3\u03bb}\n$$  where the matrices are the Jacobian at the stationary solution. For the zero stationary solution, the matrices are  kappa=0.5; a2=2.34; a1=1; beta=-1;\nA0=-kappa*[1 0; 0 1];\nA1=a2*[0 0; 1 0];\nA2=a1*[0 1; 0 0];\nA3=beta*[1 0; 0 1];  We can now create the nonlinear eigenvalue problem and compute the stability by first creating the problem  julia> tauv=[0;0.2;0.2;1.5];\njulia> dep=DEP([A0, A1,   A2, A3],tauv);  and solving it with for instance the infinite Arnoldi method  julia> \u03bb,V=iar_chebyshev(dep,maxit=100); # This takes some time the first time is run due to JIT-compiler  The figure in a demo of DDE-BIFTOOL  http://ddebiftool.sourceforge.net/demos/neuron/html/demo1_stst.html  can be directly generated by  julia> using PyPlot;\njulia> plot(real(\u03bb),imag(\u03bb),\"*\")  This problem is also available in the  Gallery  by calling  dep=nep_gallery(\"neuron0\") .",
            "title": "A model of a neuron"
        },
        {
            "location": "/#the-gun-benchmark-problem",
            "text": "One of the most common benchmark problems for NEPs is the so-called \"gun\"-problem. It models an electromagnetic cavity, and it is directly available in the  Gallery . (See  ?nep_gallery  for references.) This is how you can solve it with the block Newton method:  julia> nep=nep_gallery(\"nlevp_native_gun\");\njulia> S=150^2*[1.0 0; 0 1]; V=[[1 0; 0 1]; zeros(n-2,2)];\njulia> (Z,X)=blocknewton(nep,S=S,X=V,displaylevel=1,armijo_factor=0.5,maxit=20)\nIteration 1: Error: 6.081316e+03\nIteration 2: Error: 1.701970e-02 Armijo scaling=0.031250\nIteration 3: Error: 1.814887e-02 Armijo scaling=0.250000\n...\nIteration 13: Error: 6.257442e-09\nIteration 14: Error: 2.525942e-15  The solutions are eigenvalues of  Z .  julia>",
            "title": "The \"gun\" benchmark problem"
        },
        {
            "location": "/#what-now",
            "text": "Now you are ready to have a look at the examples in  NEP methods  and   NEP Gallery .",
            "title": "What now?"
        },
        {
            "location": "/methods/",
            "text": "NEP Methods\n\n\nThe NEP solver methods implemented in NEP-pack, are accessed by the functions below. The functions all return $\u03bb,v,w$ where $\u03bb$ is either a number (eigenvalue) a vector of eigenvalues $v$ is either a vector containing an eigenvector or a matrix whose columns corresponding to the eigenvectors.\n\n\nThe first parameter optional parameter in all NEP solver methods is a type. This type specifies which arithmetic should be used for the algorithm.\n\n\nExample:\n\n\njulia> nep=nep_gallery(\"dep0\")\njulia> \u03bb,v=augnewton(Complex128,nep,v=ones(5))\n(0.8347353572199425 + 0.0im, Complex{Float64}[0.480386+0.0im, 0.0631636+0.0im, -0.136405+0.0im, 0.214274+0.0im, 0.378581+0.0im])\njulia> typeof(\u03bb)\nComplex{Float64}\njulia> \u03bb,v=augnewton(Float16,nep,v=ones(5))\n(Float16(0.8223), Float16[0.47388, 0.063904, -0.13843, 0.21692, 0.38306])\njulia> typeof(\u03bb)\nFloat16\n\n\n\n\n\n\nNewton type methods\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.newton\n \u2014 \nFunction\n.\n\n\n\u03bb,v = newton([eltype],nep::NEP;[errmeasure,][tol,][maxit,][\u03bb,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max])\n\n\n\n\nApplies Newton-Raphsons method on the system of nonlinear equations with \nn+1\n unknowns:\n\n\n$$\nM(\u03bb)v=0\n$$\n\n\n$$\nc^Hv-1=0\n$$\n\n\nThe kwarg \nerrmeasure\n is a function handle which can be used to specify how the error is measured to be used in termination (default is absolute residual norm). The iteration is continued until \nerrmeasure\n is less than \ntol\n. \n\u03bb\n and \nv\n are starting approximations. \nc\n is the orthogonalization vector.  If \nc=0\n the current approximation will be used for the orthogonalization. \narmijo_factor\n specifies if an Armijo rule should be applied, and its value specifies the scaling factor of the step length (per reduction step). The variable \narmijo_max\n specifies the maximum number of step length reductions.\n\n\nExample\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> \u03bb,v=newton(nep);\njulia> minimum(svdvals(compute_Mder(nep,\u03bb)))\n1.6066157878930876e-16\n\n\n\n\nReferences\n\n\n\n\nNichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.\n\n\nA. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689\n\n\n\n\nsource\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.augnewton\n \u2014 \nFunction\n.\n\n\naugnewton([eltype], nep::NEP; [errmeasure,][tol,][maxit,][\u03bb,][v,][c,][displaylevel,][linsolvercreator,][armijo_factor,][armijo_max])\n\n\n\n\nRun the augmented Newton method. The method is equivalent to \nnewton()\n in exact arithmetic,  but works only with operations on vectors of length \nn\n. The \nlinsolvecreator\n is used to initiate linear solvers. See \nnewton()\n for other parameters.\n\n\nExample\n\n\nThis illustrates the equivalence between \nnewton\n and \naugnewton\n.\n\n\njulia> nep=nep_gallery(\"dep1\")\njulia> \u03bb1,v1=newton(nep,maxit=20,v=ones(size(nep,1)),\u03bb=0)\njulia> \u03bb2,v2=augnewton(nep,maxit=20,v=ones(size(nep,1)),\u03bb=0)\njulia> \u03bb1-\u03bb2\n0.0 + 0.0im\n\n\n\n\nReferences\n\n\n\n\nNichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.\n\n\nA. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689\n\n\n\n\nsource\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.resinv\n \u2014 \nFunction\n.\n\n\n\u03bb,v = resinv([eltype],nep::NEP;[errmeasure,][tol,][maxit,][\u03bb,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max,][linsolvecreator])\n\n\n\n\nApplies residual inverse iteration method for nonlinear eigenvalue problems. The kwarg \nlinsolvecreator\n is a function which specifies how the linear system is created. The function calls \ncompute_rf\n for the computation of the Rayleigh functional. See \nnewton()\n for other parameters.\n\n\nExample\n\n\nThe example shows how to specify if the method should run in real or complex mode (or any other \nNumber\n type).\n\n\njulia> nep=nep_gallery(\"qdep0\");\njulia> \u03bb,v=resinv(nep,\u03bb=-2,v=ones(size(nep,1)))\njulia> typeof(\u03bb)\nComplex{Float64}\njulia> norm(compute_Mlincomb(nep,\u03bb,v))\n1.817030659827106e-14\njulia> \u03bb,v=resinv(Float64,nep,\u03bb=-2,v=ones(size(nep,1)))\njulia> typeof(\u03bb)\nFloat64\njulia> norm(compute_Mlincomb(nep,\u03bb,v))\n1.817030659827106e-14\n\n\n\n\nReferences\n\n\n\n\nA. Neumaier, Residual inverse iteration for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 22 (1985) 914-923\n\n\n\n\nsource\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.quasinewton\n \u2014 \nFunction\n.\n\n\nquasinewton([T=ComplexF64],nep,[errmeasure,][tol,][maxit,][\u03bb,][v][ws][displaylevel][linsolvercreator,][armijo_factor,][armijo_max])\n\n\n\n\nAn implementation of the quasi-Newton approach referred to as quasi-Newton 2 in the reference. The method involves one linear system solve per iteration corresponding with the matrix $M(\u03bb)$, where $\u03bb$ is constant. The vector \nws\n is a representation of the normalization, in the sense that $c^T=w_s^TM(\u03bb)$, where all iterates satisfy $c^Tx_i=1$. See \nnewton()\n for other parameters.\n\n\nExample\n\n\njulia> nep=nep_gallery(\"pep0\")\njulia> \u03bb,v=quasinewton(nep,v=ones(size(nep,1)));\njulia> norm(compute_Mlincomb(nep,\u03bb,v))/norm(v)\n6.301479387102376e-15\n\n\n\n\nReferences\n\n\n\n\nJarlebring, Koskela, Mele, Disguised and new Quasi-Newton methods for nonlinear eigenvalue problems, arxiv preprint: https://arxiv.org/abs/1702.08492\n\n\n\n\nsource\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.mslp\n \u2014 \nFunction\n.\n\n\n mslp([eltype],nep::NEP;[errmeasure,][tol,][maxit,][\u03bb,][v,][displaylevel,][eigsolvertype::DataType][armijo_factor=1,][armijo_max])\n\n\n\n\nRuns the method of successive linear problems. The  method requires the solution of a generalized eigenvalue problem in every iteration. The method used for the eigenvalue computation is specified in eigsolvertype. See \nnewton\n for other parameters.\n\n\nExample\n\n\nCreate a rational NEP with SPMFs.\n\n\njulia> Av=[ones(3,3),eye(3,3),triu(ones(3,3))];\njulia> fv=[S-> S, S -> S^2, S::AbstractArray -> inv(Matrix(S)-eye(S)*10)]\njulia> nep=SPMF_NEP(Av,fv)\njulia> (\u03bb,v)=mslp(nep)\njulia> compute_Mlincomb(nep,\u03bb,v)\n3-element Array{Complex{Float64},1}:\n -1.38778e-17+1.65715e-18im\n -5.55112e-17+1.30633e-17im\n -4.16334e-17-1.54436e-17im\n\n\n\n\nReferences\n\n\n\n\nA. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689\n\n\n\n\nsource\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.rfi\n \u2014 \nFunction\n.\n\n\nrfi(nep,nept,[\u03bb=0,][errmeasure=default_errmeasure,][tol=eps()*100,][maxit=100,][v=randn,][u=randn,][displaylevel=0,][linsolvecreator=default_linsolvecreator,])\n\n\n\n\nThis is an implementation of the two-sided Rayleigh functional Iteration. This method requires the transpose of the NEP, which needs to be provided in nept.\n\n\nExample:\n\n\njulia> nep=nep\ngallery(\"dep0\"); julia> nept=DEP([nep.A[1]',nep.A[2]']) julia> \u03bb,v,u=rfi(nep,nept,v=ones(size(nep,1))) julia> opnorm(compute\nMder(nep,\u03bb)\nv) % v is a right eigenvector 5.4672143489065705e-16 julia> opnorm(u'\ncompute_Mder(nep,\u03bb)) % u is a left eigenvector 4.1447913221215544e-16\n\n\nReference\n\n\n\n\nAlgorithm 4 in  Schreiber, Nonlinear Eigenvalue Problems: Newton-type Methods and Nonlinear Rayleigh Functionals, PhD thesis, TU Berlin, 2008\n\n\n\n\nsource\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.newtonqr\n \u2014 \nFunction\n.\n\n\nNewton-QR method.\n\n\n\n\nsource\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.implicitdet\n \u2014 \nFunction\n.\n\n\nImplicit determinant method\n\n\n\n\nsource\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.broyden\n \u2014 \nFunction\n.\n\n\nS,V = broyden([eltype,]nep::NEP[,approxnep::NEP];kwargs)\n\n\n\n\nRuns Broydens method (with deflation) for the nonlinear eigenvalue problem defined by nep. An approximate nep can be provided which is used as an initialization of starting matrix/vectors.\n\n\nThe method computes an invariant pair and can therefore find several eigenvalues. The retured value is (S,V) is an invariant pair and the eigenvalues are on the diagonal of S.\n\n\nExample\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> S,V=broyden(nep);\njulia> \u03bb=S[1,1]\n-0.3587189459686267 - 3.0010731412746105e-31im\njulia> minimum(svdvals(compute_Mder(nep,\u03bb)))\n1.6066157878930856e-16\njulia> \u03bb=S[2,2]\n-0.04093521177097334 + 1.486011530941621im\njulia> minimum(svdvals(compute_Mder(nep,\u03bb)))\n4.159109513753696e-16\njulia> \u03bb=S[3,3]\n0.8347353572199486 + 1.5032076225139986e-14im\njulia> minimum(svdvals(compute_Mder(nep,\u03bb)))\n1.296144276122994e-14\njulia> broyden(nep,displaylevel=2,check_error_every=1);  % Prints out a lot more convergence info\n\n\n\n\nReferences\n\n\n\n\nJarlebring, Broyden\u2019s method for nonlinear eigenproblems, 2018, https://arxiv.org/pdf/1802.07322\n\n\n\n\nsource\n\n\n\n\nProjection methods\n\n\nnlar\n\n\n\n\n\n\nArnoldi type methods\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.iar\n \u2014 \nFunction\n.\n\n\niar(nep,[maxit=30,][\u03c3=0,][\u03b3=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])\n\n\n\n\nInfinite Arnoldi method\n\n\nRuns the infinite Arnoldi method which tries to find eigenvalues close to the shift \u03c3.\n\n\nExample\n\n\njulia> using NonlinearEigenproblems, LinearAlgebra\njulia> nep=nep_gallery(\"dep0\",100);\njulia> v0=ones(size(nep,1));\njulia> \u03bb,v=iar(nep;v=v0,tol=1e-5,Neig=3);\njulia> norm(compute_Mlincomb!(nep,\u03bb[1],v[:,1])) # Is it an eigenvalue?\njulia> \u03bb    # print the computed eigenvalues\n3-element Array{Complex{Float64},1}:\n -0.15606211475666945 - 0.12273439802763578im\n -0.15606211475666862 + 0.12273439802763489im\n  0.23169243065648365 - 9.464790582509696e-17im \n\n\n\n\nReferences\n\n\n\n\nAlgorithm 2 in Jarlebring, Michiels Meerbergen, A linear eigenvalue algorithm for the nonlinear eigenvalue problem, Numer. Math, 2012\n\n\n\n\nsource\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.tiar\n \u2014 \nFunction\n.\n\n\ntiar(nep,[maxit=30,][\u03c3=0,][\u03b3=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])\n\n\n\n\nRuns the tensor infinite Arnoldi method which tries to find eigenvalues close to the shift \u03c3.\n\n\nExample\n\n\njulia> using NonlinearEigenproblems, LinearAlgebra\njulia> nep=nep_gallery(\"dep0\",100);\njulia> v0=ones(size(nep,1));\njulia> \u03bb,v=tiar(nep;v=v0,tol=1e-5,Neig=3);\njulia> norm(compute_Mlincomb!(nep,\u03bb[1],v[:,1])) # Is it an eigenvalue?\njulia> \u03bb    # print the computed eigenvalues\n3-element Array{Complex{Float64},1}:\n -0.1560621147566685 + 0.12273439802763504im\n -0.1560621147566693 - 0.1227343980276357im\n 0.23169243065648332 - 4.699260229885766e-17im\n\n\n\n\n\nReferences\n\n\n\n\nAlgorithm 2 in Jarlebring, Mele, Runborg, The Waveguide Eigenvalue Problem and the Tensor Infinite Arnoldi Method, SIAM J. Scient. computing, 39 (3), A1062-A1088, 2017\n\n\n\n\nsource\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.infbilanczos\n \u2014 \nFunction\n.\n\n\n\u03bbv,V,U=infbilanczos([eltype],nep, nept,[linsolvecreator,][linsolvertcreator,][v,][u,][\u03c3,][\u03b3,][tol,][Neig,][errmeasure,][displaylevel,][maxit,][check_error_every])\n\n\n\n\nExecutes the Infinite Bi-Lanczos method on the problem defined by \nnep::NEP\n and \nnept::NEP\n. \nnep:NEP\n is the original nonlinear eigenvalue problem and \nnept::NEP\n is its (hermitian) transpose: $M(\u03bb^*)^H$.  \nv\n and \nu\n are starting vectors, \n\u03c3\n is the shift and \n\u03b3\n the scaling.  See \nnewton()\n for other parameters.\n\n\nExample:\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> A=get_Av(nep); fv=get_fv(nep);\njulia> At=[copy(A[1]'),copy(A[2]'),copy(A[3]')]\njulia> nept=SPMF_NEP(At,fv); # Create the transposed NEP\njulia> \u03bbv,V=infbilanczos(nep,nept,Neig=3)\njulia> norm(compute_Mlincomb(nep,\u03bbv[1],V[:,1]))\n\n\n\n\nReferences:\n\n\n\n\nThe infinite bi-Lanczos method for nonlinear eigenvalue problems, S. W. Gaaf and E. Jarlebring, arxiv: 1607.03454, to appear in SIAM J. Scientific Computing\n\n\n\n\nsource\n\n\n\n\nClass specific methods\n\n\n\n\nCompanion linearizations\n\n\n\n\nRational ?",
            "title": "NEP Methods"
        },
        {
            "location": "/methods/#nep-methods",
            "text": "The NEP solver methods implemented in NEP-pack, are accessed by the functions below. The functions all return $\u03bb,v,w$ where $\u03bb$ is either a number (eigenvalue) a vector of eigenvalues $v$ is either a vector containing an eigenvector or a matrix whose columns corresponding to the eigenvectors.  The first parameter optional parameter in all NEP solver methods is a type. This type specifies which arithmetic should be used for the algorithm.  Example:  julia> nep=nep_gallery(\"dep0\")\njulia> \u03bb,v=augnewton(Complex128,nep,v=ones(5))\n(0.8347353572199425 + 0.0im, Complex{Float64}[0.480386+0.0im, 0.0631636+0.0im, -0.136405+0.0im, 0.214274+0.0im, 0.378581+0.0im])\njulia> typeof(\u03bb)\nComplex{Float64}\njulia> \u03bb,v=augnewton(Float16,nep,v=ones(5))\n(Float16(0.8223), Float16[0.47388, 0.063904, -0.13843, 0.21692, 0.38306])\njulia> typeof(\u03bb)\nFloat16",
            "title": "NEP Methods"
        },
        {
            "location": "/methods/#newton-type-methods",
            "text": "#  NonlinearEigenproblems.NEPSolver.newton  \u2014  Function .  \u03bb,v = newton([eltype],nep::NEP;[errmeasure,][tol,][maxit,][\u03bb,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max])  Applies Newton-Raphsons method on the system of nonlinear equations with  n+1  unknowns:  $$\nM(\u03bb)v=0\n$$  $$\nc^Hv-1=0\n$$  The kwarg  errmeasure  is a function handle which can be used to specify how the error is measured to be used in termination (default is absolute residual norm). The iteration is continued until  errmeasure  is less than  tol .  \u03bb  and  v  are starting approximations.  c  is the orthogonalization vector.  If  c=0  the current approximation will be used for the orthogonalization.  armijo_factor  specifies if an Armijo rule should be applied, and its value specifies the scaling factor of the step length (per reduction step). The variable  armijo_max  specifies the maximum number of step length reductions.  Example  julia> nep=nep_gallery(\"dep0\");\njulia> \u03bb,v=newton(nep);\njulia> minimum(svdvals(compute_Mder(nep,\u03bb)))\n1.6066157878930876e-16  References   Nichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.  A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689   source  #  NonlinearEigenproblems.NEPSolver.augnewton  \u2014  Function .  augnewton([eltype], nep::NEP; [errmeasure,][tol,][maxit,][\u03bb,][v,][c,][displaylevel,][linsolvercreator,][armijo_factor,][armijo_max])  Run the augmented Newton method. The method is equivalent to  newton()  in exact arithmetic,  but works only with operations on vectors of length  n . The  linsolvecreator  is used to initiate linear solvers. See  newton()  for other parameters.  Example  This illustrates the equivalence between  newton  and  augnewton .  julia> nep=nep_gallery(\"dep1\")\njulia> \u03bb1,v1=newton(nep,maxit=20,v=ones(size(nep,1)),\u03bb=0)\njulia> \u03bb2,v2=augnewton(nep,maxit=20,v=ones(size(nep,1)),\u03bb=0)\njulia> \u03bb1-\u03bb2\n0.0 + 0.0im  References   Nichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.  A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689   source  #  NonlinearEigenproblems.NEPSolver.resinv  \u2014  Function .  \u03bb,v = resinv([eltype],nep::NEP;[errmeasure,][tol,][maxit,][\u03bb,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max,][linsolvecreator])  Applies residual inverse iteration method for nonlinear eigenvalue problems. The kwarg  linsolvecreator  is a function which specifies how the linear system is created. The function calls  compute_rf  for the computation of the Rayleigh functional. See  newton()  for other parameters.  Example  The example shows how to specify if the method should run in real or complex mode (or any other  Number  type).  julia> nep=nep_gallery(\"qdep0\");\njulia> \u03bb,v=resinv(nep,\u03bb=-2,v=ones(size(nep,1)))\njulia> typeof(\u03bb)\nComplex{Float64}\njulia> norm(compute_Mlincomb(nep,\u03bb,v))\n1.817030659827106e-14\njulia> \u03bb,v=resinv(Float64,nep,\u03bb=-2,v=ones(size(nep,1)))\njulia> typeof(\u03bb)\nFloat64\njulia> norm(compute_Mlincomb(nep,\u03bb,v))\n1.817030659827106e-14  References   A. Neumaier, Residual inverse iteration for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 22 (1985) 914-923   source  #  NonlinearEigenproblems.NEPSolver.quasinewton  \u2014  Function .  quasinewton([T=ComplexF64],nep,[errmeasure,][tol,][maxit,][\u03bb,][v][ws][displaylevel][linsolvercreator,][armijo_factor,][armijo_max])  An implementation of the quasi-Newton approach referred to as quasi-Newton 2 in the reference. The method involves one linear system solve per iteration corresponding with the matrix $M(\u03bb)$, where $\u03bb$ is constant. The vector  ws  is a representation of the normalization, in the sense that $c^T=w_s^TM(\u03bb)$, where all iterates satisfy $c^Tx_i=1$. See  newton()  for other parameters.  Example  julia> nep=nep_gallery(\"pep0\")\njulia> \u03bb,v=quasinewton(nep,v=ones(size(nep,1)));\njulia> norm(compute_Mlincomb(nep,\u03bb,v))/norm(v)\n6.301479387102376e-15  References   Jarlebring, Koskela, Mele, Disguised and new Quasi-Newton methods for nonlinear eigenvalue problems, arxiv preprint: https://arxiv.org/abs/1702.08492   source  #  NonlinearEigenproblems.NEPSolver.mslp  \u2014  Function .   mslp([eltype],nep::NEP;[errmeasure,][tol,][maxit,][\u03bb,][v,][displaylevel,][eigsolvertype::DataType][armijo_factor=1,][armijo_max])  Runs the method of successive linear problems. The  method requires the solution of a generalized eigenvalue problem in every iteration. The method used for the eigenvalue computation is specified in eigsolvertype. See  newton  for other parameters.  Example  Create a rational NEP with SPMFs.  julia> Av=[ones(3,3),eye(3,3),triu(ones(3,3))];\njulia> fv=[S-> S, S -> S^2, S::AbstractArray -> inv(Matrix(S)-eye(S)*10)]\njulia> nep=SPMF_NEP(Av,fv)\njulia> (\u03bb,v)=mslp(nep)\njulia> compute_Mlincomb(nep,\u03bb,v)\n3-element Array{Complex{Float64},1}:\n -1.38778e-17+1.65715e-18im\n -5.55112e-17+1.30633e-17im\n -4.16334e-17-1.54436e-17im  References   A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689   source  #  NonlinearEigenproblems.NEPSolver.rfi  \u2014  Function .  rfi(nep,nept,[\u03bb=0,][errmeasure=default_errmeasure,][tol=eps()*100,][maxit=100,][v=randn,][u=randn,][displaylevel=0,][linsolvecreator=default_linsolvecreator,])  This is an implementation of the two-sided Rayleigh functional Iteration. This method requires the transpose of the NEP, which needs to be provided in nept.  Example:  julia> nep=nep gallery(\"dep0\"); julia> nept=DEP([nep.A[1]',nep.A[2]']) julia> \u03bb,v,u=rfi(nep,nept,v=ones(size(nep,1))) julia> opnorm(compute Mder(nep,\u03bb) v) % v is a right eigenvector 5.4672143489065705e-16 julia> opnorm(u' compute_Mder(nep,\u03bb)) % u is a left eigenvector 4.1447913221215544e-16  Reference   Algorithm 4 in  Schreiber, Nonlinear Eigenvalue Problems: Newton-type Methods and Nonlinear Rayleigh Functionals, PhD thesis, TU Berlin, 2008   source  #  NonlinearEigenproblems.NEPSolver.newtonqr  \u2014  Function .  Newton-QR method.  source  #  NonlinearEigenproblems.NEPSolver.implicitdet  \u2014  Function .  Implicit determinant method  source  #  NonlinearEigenproblems.NEPSolver.broyden  \u2014  Function .  S,V = broyden([eltype,]nep::NEP[,approxnep::NEP];kwargs)  Runs Broydens method (with deflation) for the nonlinear eigenvalue problem defined by nep. An approximate nep can be provided which is used as an initialization of starting matrix/vectors.  The method computes an invariant pair and can therefore find several eigenvalues. The retured value is (S,V) is an invariant pair and the eigenvalues are on the diagonal of S.  Example  julia> nep=nep_gallery(\"dep0\");\njulia> S,V=broyden(nep);\njulia> \u03bb=S[1,1]\n-0.3587189459686267 - 3.0010731412746105e-31im\njulia> minimum(svdvals(compute_Mder(nep,\u03bb)))\n1.6066157878930856e-16\njulia> \u03bb=S[2,2]\n-0.04093521177097334 + 1.486011530941621im\njulia> minimum(svdvals(compute_Mder(nep,\u03bb)))\n4.159109513753696e-16\njulia> \u03bb=S[3,3]\n0.8347353572199486 + 1.5032076225139986e-14im\njulia> minimum(svdvals(compute_Mder(nep,\u03bb)))\n1.296144276122994e-14\njulia> broyden(nep,displaylevel=2,check_error_every=1);  % Prints out a lot more convergence info  References   Jarlebring, Broyden\u2019s method for nonlinear eigenproblems, 2018, https://arxiv.org/pdf/1802.07322   source",
            "title": "Newton type methods"
        },
        {
            "location": "/methods/#projection-methods",
            "text": "nlar",
            "title": "Projection methods"
        },
        {
            "location": "/methods/#arnoldi-type-methods",
            "text": "#  NonlinearEigenproblems.NEPSolver.iar  \u2014  Function .  iar(nep,[maxit=30,][\u03c3=0,][\u03b3=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])  Infinite Arnoldi method  Runs the infinite Arnoldi method which tries to find eigenvalues close to the shift \u03c3.  Example  julia> using NonlinearEigenproblems, LinearAlgebra\njulia> nep=nep_gallery(\"dep0\",100);\njulia> v0=ones(size(nep,1));\njulia> \u03bb,v=iar(nep;v=v0,tol=1e-5,Neig=3);\njulia> norm(compute_Mlincomb!(nep,\u03bb[1],v[:,1])) # Is it an eigenvalue?\njulia> \u03bb    # print the computed eigenvalues\n3-element Array{Complex{Float64},1}:\n -0.15606211475666945 - 0.12273439802763578im\n -0.15606211475666862 + 0.12273439802763489im\n  0.23169243065648365 - 9.464790582509696e-17im   References   Algorithm 2 in Jarlebring, Michiels Meerbergen, A linear eigenvalue algorithm for the nonlinear eigenvalue problem, Numer. Math, 2012   source  #  NonlinearEigenproblems.NEPSolver.tiar  \u2014  Function .  tiar(nep,[maxit=30,][\u03c3=0,][\u03b3=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])  Runs the tensor infinite Arnoldi method which tries to find eigenvalues close to the shift \u03c3.  Example  julia> using NonlinearEigenproblems, LinearAlgebra\njulia> nep=nep_gallery(\"dep0\",100);\njulia> v0=ones(size(nep,1));\njulia> \u03bb,v=tiar(nep;v=v0,tol=1e-5,Neig=3);\njulia> norm(compute_Mlincomb!(nep,\u03bb[1],v[:,1])) # Is it an eigenvalue?\njulia> \u03bb    # print the computed eigenvalues\n3-element Array{Complex{Float64},1}:\n -0.1560621147566685 + 0.12273439802763504im\n -0.1560621147566693 - 0.1227343980276357im\n 0.23169243065648332 - 4.699260229885766e-17im  References   Algorithm 2 in Jarlebring, Mele, Runborg, The Waveguide Eigenvalue Problem and the Tensor Infinite Arnoldi Method, SIAM J. Scient. computing, 39 (3), A1062-A1088, 2017   source  #  NonlinearEigenproblems.NEPSolver.infbilanczos  \u2014  Function .  \u03bbv,V,U=infbilanczos([eltype],nep, nept,[linsolvecreator,][linsolvertcreator,][v,][u,][\u03c3,][\u03b3,][tol,][Neig,][errmeasure,][displaylevel,][maxit,][check_error_every])  Executes the Infinite Bi-Lanczos method on the problem defined by  nep::NEP  and  nept::NEP .  nep:NEP  is the original nonlinear eigenvalue problem and  nept::NEP  is its (hermitian) transpose: $M(\u03bb^*)^H$.   v  and  u  are starting vectors,  \u03c3  is the shift and  \u03b3  the scaling.  See  newton()  for other parameters.  Example:  julia> nep=nep_gallery(\"dep0\");\njulia> A=get_Av(nep); fv=get_fv(nep);\njulia> At=[copy(A[1]'),copy(A[2]'),copy(A[3]')]\njulia> nept=SPMF_NEP(At,fv); # Create the transposed NEP\njulia> \u03bbv,V=infbilanczos(nep,nept,Neig=3)\njulia> norm(compute_Mlincomb(nep,\u03bbv[1],V[:,1]))  References:   The infinite bi-Lanczos method for nonlinear eigenvalue problems, S. W. Gaaf and E. Jarlebring, arxiv: 1607.03454, to appear in SIAM J. Scientific Computing   source",
            "title": "Arnoldi type methods"
        },
        {
            "location": "/methods/#class-specific-methods",
            "text": "",
            "title": "Class specific methods"
        },
        {
            "location": "/methods/#companion-linearizations",
            "text": "",
            "title": "Companion linearizations"
        },
        {
            "location": "/methods/#rational",
            "text": "",
            "title": "Rational ?"
        },
        {
            "location": "/types/",
            "text": "The basic type\n\n\nThe basic class is the abstract class \nNEP\n which represents a NEP. \n\n\n#\n\n\nNonlinearEigenproblems.NEPCore.NEP\n \u2014 \nType\n.\n\n\nabstract NEP\n\n\n\n\nA \nNEP\n object represents a nonlinear eigenvalue problem. All NEPs should implement\n\n\nsize(nep::NEP,d)\n\n\n\n\nand at least one of the following\n\n\nM=compute_Mder(nep::NEP,\u03bb::Number;der=0)\nV=compute_Mlincomb(nep::NEP,\u03bb::Number,V::Array{<:Number,2})\nMM=compute_MM(nep::NEP,S::Array{<:Number,2},V::Array{<:Number,2})\n\n\n\n\nsource\n\n\n\n\nAccessing the NEP\n\n\nThe nonlinear eigenvalue problem is defined by the data stored in the NEP-class, and the NEP-solvers access the data mainly through three main functions, \ncompute_Mder\n \ncompute_Mlincomb\n and \ncompute_MM\n.\n\n\ncompute_Mder(nep::NEPCore.NEP, \u03bb::Number, i::Integer) \ncompute_Mlincomb(nep::NEPCore.NEP, \u03bb::Number, V; a)\ncompute_MM\n\n\n\n\n\n\nNEPTypes\n\n\nIn order to use the methods, the user has the possibility to implement their own problem-specific functions above, or use one of the predefined types. The most common one is the \nSPMF_NEP\n.\n\n\n#\n\n\nNonlinearEigenproblems.NEPTypes.SPMF_NEP\n \u2014 \nConstant\n.\n\n\n SPMF_NEP(AA, fii, Schur_fact = false, use_sparsity_pattern = true, check_consistency=true)\n\n\n\n\nCreates a \nSPMF_NEP\n consisting of matrices \nAA\n and functions \nfii\n. \nfii\n must be an array of functions defined for matrices and numbers. \nAA\n is an array of matrices. \nSchur_fact\n specifies if the computation of \ncompute_MM\n should be done by first pre-computing a Schur-factorization (which can be faster). If \nuse_sparsity_pattern\n is true, and the \nAA\n matrices are sparse, each matrix will be stored with a sparsity pattern matching the union of all \nAA\n matrices. This leads to more efficient calculation of \ncompute_Mder\n. If the sparsity patterns are completely or mostly distinct, it may be more efficient to set this flag to false. If check_consistency is true the input checking will be performed.\n\n\njulia> A0=[1 3; 4 5]; A1=[3 4; 5 6];\njulia> id_op=S -> one(S)\njulia> exp_op=S -> exp(S)\njulia> nep=SPMF_NEP([A0,A1],[id_op,exp_op]);\njulia> compute_Mder(nep,1)-(A0+A1*exp(1))\n2\u00d72 Array{Float64,2}:\n 0.0  0.0\n 0.0  0.0\n\n\n\n\nsource\n\n\nIn order to construct an \nSPMF_NEP\n, we need to provide the matrices and the functions.\n\n\nSPMF_NEP(AA::Array, fii::Array{Function,1}) \n\n\n\n\n#\n\n\nNonlinearEigenproblems.NEPCore.compute_Mder\n \u2014 \nFunction\n.\n\n\ncompute_Mder(nep::NEP,\u03bb::Number [,i::Integer=0])\n\n\n\n\nComputes the ith derivative of \nnep\n evaluated in \n\u03bb\n.\n\n\nExample\n\n\nThis example shows that \ncompute_Mder(nep,\u03bb,1)\n gives the first derivative.\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> \u03f5=1e-5;\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aplus=compute_Mder(nep,\u03bb+\u03f5);\njulia> opnorm((Aplus-Aminus)/(2\u03f5)-compute_Mder(nep,\u03bb,1))\n1.990970375089371e-11\n\n\n\n\nsource\n\n\n#\n\n\nNonlinearEigenproblems.NEPCore.compute_Mlincomb\n \u2014 \nFunction\n.\n\n\ncompute_Mlincomb(nep::NEP,\u03bb::Number,V,a::Array,startder::Integer)\n\n\n\n\nComputes linear combination starting with derivative startder, i.e., $\u03a3_i a_i M^{(i+startder)}(\u03bb) v_i$\n\n\nThe default implementation of this can be slow. Overload for specific NEP if you want efficiency (for aug_newton, IAR, ..).\n\n\nsource\n\n\nLet's try an equation $x=f(x)$. (a \\ne 0)\n\n\n$$\nx=x_1+1\n$$",
            "title": "NEP Types"
        },
        {
            "location": "/types/#the-basic-type",
            "text": "The basic class is the abstract class  NEP  which represents a NEP.   #  NonlinearEigenproblems.NEPCore.NEP  \u2014  Type .  abstract NEP  A  NEP  object represents a nonlinear eigenvalue problem. All NEPs should implement  size(nep::NEP,d)  and at least one of the following  M=compute_Mder(nep::NEP,\u03bb::Number;der=0)\nV=compute_Mlincomb(nep::NEP,\u03bb::Number,V::Array{<:Number,2})\nMM=compute_MM(nep::NEP,S::Array{<:Number,2},V::Array{<:Number,2})  source",
            "title": "The basic type"
        },
        {
            "location": "/types/#accessing-the-nep",
            "text": "The nonlinear eigenvalue problem is defined by the data stored in the NEP-class, and the NEP-solvers access the data mainly through three main functions,  compute_Mder   compute_Mlincomb  and  compute_MM .  compute_Mder(nep::NEPCore.NEP, \u03bb::Number, i::Integer) \ncompute_Mlincomb(nep::NEPCore.NEP, \u03bb::Number, V; a)\ncompute_MM",
            "title": "Accessing the NEP"
        },
        {
            "location": "/types/#neptypes",
            "text": "In order to use the methods, the user has the possibility to implement their own problem-specific functions above, or use one of the predefined types. The most common one is the  SPMF_NEP .  #  NonlinearEigenproblems.NEPTypes.SPMF_NEP  \u2014  Constant .   SPMF_NEP(AA, fii, Schur_fact = false, use_sparsity_pattern = true, check_consistency=true)  Creates a  SPMF_NEP  consisting of matrices  AA  and functions  fii .  fii  must be an array of functions defined for matrices and numbers.  AA  is an array of matrices.  Schur_fact  specifies if the computation of  compute_MM  should be done by first pre-computing a Schur-factorization (which can be faster). If  use_sparsity_pattern  is true, and the  AA  matrices are sparse, each matrix will be stored with a sparsity pattern matching the union of all  AA  matrices. This leads to more efficient calculation of  compute_Mder . If the sparsity patterns are completely or mostly distinct, it may be more efficient to set this flag to false. If check_consistency is true the input checking will be performed.  julia> A0=[1 3; 4 5]; A1=[3 4; 5 6];\njulia> id_op=S -> one(S)\njulia> exp_op=S -> exp(S)\njulia> nep=SPMF_NEP([A0,A1],[id_op,exp_op]);\njulia> compute_Mder(nep,1)-(A0+A1*exp(1))\n2\u00d72 Array{Float64,2}:\n 0.0  0.0\n 0.0  0.0  source  In order to construct an  SPMF_NEP , we need to provide the matrices and the functions.  SPMF_NEP(AA::Array, fii::Array{Function,1})   #  NonlinearEigenproblems.NEPCore.compute_Mder  \u2014  Function .  compute_Mder(nep::NEP,\u03bb::Number [,i::Integer=0])  Computes the ith derivative of  nep  evaluated in  \u03bb .  Example  This example shows that  compute_Mder(nep,\u03bb,1)  gives the first derivative.  julia> nep=nep_gallery(\"dep0\");\njulia> \u03f5=1e-5;\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aplus=compute_Mder(nep,\u03bb+\u03f5);\njulia> opnorm((Aplus-Aminus)/(2\u03f5)-compute_Mder(nep,\u03bb,1))\n1.990970375089371e-11  source  #  NonlinearEigenproblems.NEPCore.compute_Mlincomb  \u2014  Function .  compute_Mlincomb(nep::NEP,\u03bb::Number,V,a::Array,startder::Integer)  Computes linear combination starting with derivative startder, i.e., $\u03a3_i a_i M^{(i+startder)}(\u03bb) v_i$  The default implementation of this can be slow. Overload for specific NEP if you want efficiency (for aug_newton, IAR, ..).  source  Let's try an equation $x=f(x)$. (a \\ne 0)  $$\nx=x_1+1\n$$",
            "title": "NEPTypes"
        },
        {
            "location": "/linsolvers/",
            "text": "LinSolvers\n\n\nMost NEP-algorithms need to solve the linear system associated with \nM(\u03bb)\n. We provide an interface to specify which solver to use or define your own solver.\n\n\n#\n\n\nNonlinearEigenproblems.LinSolvers.LinSolver\n \u2014 \nType\n.\n\n\nabstract type LinSolver\n\n\n\n\nStructs inheriting from this type are able to solve linear systems associated with a NEP, for a specific \n\u03bb\n-value. The most common are direct solvers such as \nDefaultLinSolver\n, \nBackslashLinSolver\n and iterative solvers such as \nGMRESlinsolver\n.\n\n\nThe LinSolver objects are usually created by the NEP-algorithms through creator functions, which are passed as parameters.\n\n\nExample\n\n\nThe most common usecase is that you want to pass a \nlinsolvercreator\n-function as parameter to the NEP-algorithm. This example shows how you can solvers based on backslash or \nfactorize()\n. In the example, \nBackslashLinSolver\n does not exploit that the system matrix remains the same throughout the algorithm and is therefore slower.\n\n\njulia> nep=nep_gallery(\"qdep0\");\njulia> using BenchmarkTools\njulia> v0=ones(size(nep,1));\njulia> @btime \u03bb,v=quasinewton(nep,\u03bb=-1,v=v0, linsolvercreator=default_linsolvercreator);\n  199.540 ms (4929 allocations: 59.83 MiB)\njulia> @btime \u03bb,v=quasinewton(nep,\u03bb=-1,v=v0, linsolvercreator=backslash_linsolvercreator);\n  1.632 s (6137 allocations: 702.85 MiB)\n\n\n\n\nExample\n\n\nThe \nLinSolver\ns are constructed for extendability. This example creates our own \nLinSolver\n which uses an explicit formula for the inverse if the NEP has dimension 2x2.\n\n\nCreate the types and a creator.\n\n\njulia> using LinearAlgebra\njulia> struct MyLinSolver <: LinSolver\n   M::Matrix{ComplexF64}\nend\njulia> function my_linsolvercreator(nep,\u03bb)\n   M=compute_Mder(nep,\u03bb);\n   return MyLinSolver(M);\nend\n\n\n\n\nExplicit import \nlin_solve\n to show how to solve a linear system.\n\n\njulia> import NonlinearEigenproblems.LinSolvers.lin_solve;\njulia> function lin_solve(solver::MyLinSolver,b::AbstractVecOrMat;tol=0)\n   M=solver.M;\n   invM=(1/(det(M)))*[M[2,2] -M[1,2];-M[2,1] M[1,1]]\n   return invM*b\nend\njulia> nep=SPMF_NEP([[1.0 3.0; 4.0 5.0], [2.0 1.0; -1 2.0]], [S->S^2,S->exp(S)])\njulia> \u03bb,v=quasinewton(nep,\u03bb=-1,v=[1;1],linsolvercreator=my_linsolvercreator);\n\n\n\n\nSee also: \nlin_solve\n, \nDefaultSolver\n, \ndefault_linsolvercreator\n, \nBackslashSolver\n, \nbackslash_linsolvercreator\n, \nGMRESLinSolver\n, \ngmres_linsolvercreator\n\n\nsource\n\n\n#\n\n\nNonlinearEigenproblems.LinSolvers.lin_solve\n \u2014 \nFunction\n.\n\n\nlin_solve(solver::LinSolver, b::AbstractVecOrMat; tol=0)\n\n\n\n\nThis function solves the linear system represented in \nsolver::LinSolver\n with a right-hand side \nb\n. The \ntol\n kwarg is controlling how accurate the linear system needs to be solved. A NEP-algorithm will call this solver every time a linear system associated with \nM(\u03bb)\n needs to be solved.\n\n\nThis function must be overloaded if a user wants to define their own way of solving linear systems. See \nLinSolver\n for examples.\n\n\nsource\n\n\n#\n\n\nNonlinearEigenproblems.LinSolvers.DefaultLinSolver\n \u2014 \nType\n.\n\n\nstruct DefaultLinSolver <: LinSolver\n\n\n\n\nThis represents the linear solver associated with julia \nfactorize()\n. See \nLinSolver\n and \ndefault_linsolvercreator\n for examples.\n\n\nsource\n\n\n#\n\n\nNonlinearEigenproblems.LinSolvers.default_linsolvercreator\n \u2014 \nFunction\n.\n\n\ndefault_linsolvercreator(nep::NEP, \u03bb; umfpack_refinements = 2)\n\n\n\n\nCreate a linear solver of type \nDefaultLinSolver\n for the NEP evaluated in point \n\u03bb\n. For sparse matrices (the underlying solver is usually UMFPACK) the maximum number of iterative refinements can be changed to trade accuracy for performance with the parameter \numfpack_refinements\n. UMFPACK defaults to a maximum of 2 iterative refinements.\n\n\nFor examples see \nLinSolver\n.\n\n\nSee also: \nDefaultLinSolver\n.\n\n\nsource\n\n\n#\n\n\nNonlinearEigenproblems.LinSolvers.BackslashLinSolver\n \u2014 \nType\n.\n\n\nstruct BackslashLinSolver <: LinSolver\n\n\n\n\nThis represents a linear solver corresponding to the backslash operator (no pre-factorization).\n\n\nSee also: \nLinSolver\n and \nbackslash_linsolvercreator\n\n\nsource\n\n\n#\n\n\nNonlinearEigenproblems.LinSolvers.backslash_linsolvercreator\n \u2014 \nFunction\n.\n\n\nbackslash_linsolvercreator(nep::NEP, \u03bb)\n\n\n\n\nCreate a linear solver of type 'BackslashLinSolver' evaluated in \n\u03bb\n.\n\n\nSee also: \nLinSolver\n, \nBackslashLinSolver\n\n\nsource\n\n\n#\n\n\nNonlinearEigenproblems.LinSolvers.GMRESLinSolver\n \u2014 \nType\n.\n\n\n struct GMRESLinSolver <: LinSolver\n\n\n\n\nThis represents a solver done with the julia GMRES implementation.\n\n\nSee also: \nLinSolver\n, \ngmres_linsolvercreator\n\n\nsource\n\n\n#\n\n\nNonlinearEigenproblems.LinSolvers.gmres_linsolvercreator\n \u2014 \nFunction\n.\n\n\ngmres_linsolvercreator(nep::NEP, \u03bb, kwargs=())\n\n\n\n\nCreate a linear solver of type 'GMRESLinSolver'. The kwargs are passed as parameter to Julia-built-in-GMRES.\n\n\nSee also: \nLinSolver\n, \nGMRESLinSolver\n\n\nsource",
            "title": "LinSolver"
        },
        {
            "location": "/linsolvers/#linsolvers",
            "text": "Most NEP-algorithms need to solve the linear system associated with  M(\u03bb) . We provide an interface to specify which solver to use or define your own solver.  #  NonlinearEigenproblems.LinSolvers.LinSolver  \u2014  Type .  abstract type LinSolver  Structs inheriting from this type are able to solve linear systems associated with a NEP, for a specific  \u03bb -value. The most common are direct solvers such as  DefaultLinSolver ,  BackslashLinSolver  and iterative solvers such as  GMRESlinsolver .  The LinSolver objects are usually created by the NEP-algorithms through creator functions, which are passed as parameters.  Example  The most common usecase is that you want to pass a  linsolvercreator -function as parameter to the NEP-algorithm. This example shows how you can solvers based on backslash or  factorize() . In the example,  BackslashLinSolver  does not exploit that the system matrix remains the same throughout the algorithm and is therefore slower.  julia> nep=nep_gallery(\"qdep0\");\njulia> using BenchmarkTools\njulia> v0=ones(size(nep,1));\njulia> @btime \u03bb,v=quasinewton(nep,\u03bb=-1,v=v0, linsolvercreator=default_linsolvercreator);\n  199.540 ms (4929 allocations: 59.83 MiB)\njulia> @btime \u03bb,v=quasinewton(nep,\u03bb=-1,v=v0, linsolvercreator=backslash_linsolvercreator);\n  1.632 s (6137 allocations: 702.85 MiB)  Example  The  LinSolver s are constructed for extendability. This example creates our own  LinSolver  which uses an explicit formula for the inverse if the NEP has dimension 2x2.  Create the types and a creator.  julia> using LinearAlgebra\njulia> struct MyLinSolver <: LinSolver\n   M::Matrix{ComplexF64}\nend\njulia> function my_linsolvercreator(nep,\u03bb)\n   M=compute_Mder(nep,\u03bb);\n   return MyLinSolver(M);\nend  Explicit import  lin_solve  to show how to solve a linear system.  julia> import NonlinearEigenproblems.LinSolvers.lin_solve;\njulia> function lin_solve(solver::MyLinSolver,b::AbstractVecOrMat;tol=0)\n   M=solver.M;\n   invM=(1/(det(M)))*[M[2,2] -M[1,2];-M[2,1] M[1,1]]\n   return invM*b\nend\njulia> nep=SPMF_NEP([[1.0 3.0; 4.0 5.0], [2.0 1.0; -1 2.0]], [S->S^2,S->exp(S)])\njulia> \u03bb,v=quasinewton(nep,\u03bb=-1,v=[1;1],linsolvercreator=my_linsolvercreator);  See also:  lin_solve ,  DefaultSolver ,  default_linsolvercreator ,  BackslashSolver ,  backslash_linsolvercreator ,  GMRESLinSolver ,  gmres_linsolvercreator  source  #  NonlinearEigenproblems.LinSolvers.lin_solve  \u2014  Function .  lin_solve(solver::LinSolver, b::AbstractVecOrMat; tol=0)  This function solves the linear system represented in  solver::LinSolver  with a right-hand side  b . The  tol  kwarg is controlling how accurate the linear system needs to be solved. A NEP-algorithm will call this solver every time a linear system associated with  M(\u03bb)  needs to be solved.  This function must be overloaded if a user wants to define their own way of solving linear systems. See  LinSolver  for examples.  source  #  NonlinearEigenproblems.LinSolvers.DefaultLinSolver  \u2014  Type .  struct DefaultLinSolver <: LinSolver  This represents the linear solver associated with julia  factorize() . See  LinSolver  and  default_linsolvercreator  for examples.  source  #  NonlinearEigenproblems.LinSolvers.default_linsolvercreator  \u2014  Function .  default_linsolvercreator(nep::NEP, \u03bb; umfpack_refinements = 2)  Create a linear solver of type  DefaultLinSolver  for the NEP evaluated in point  \u03bb . For sparse matrices (the underlying solver is usually UMFPACK) the maximum number of iterative refinements can be changed to trade accuracy for performance with the parameter  umfpack_refinements . UMFPACK defaults to a maximum of 2 iterative refinements.  For examples see  LinSolver .  See also:  DefaultLinSolver .  source  #  NonlinearEigenproblems.LinSolvers.BackslashLinSolver  \u2014  Type .  struct BackslashLinSolver <: LinSolver  This represents a linear solver corresponding to the backslash operator (no pre-factorization).  See also:  LinSolver  and  backslash_linsolvercreator  source  #  NonlinearEigenproblems.LinSolvers.backslash_linsolvercreator  \u2014  Function .  backslash_linsolvercreator(nep::NEP, \u03bb)  Create a linear solver of type 'BackslashLinSolver' evaluated in  \u03bb .  See also:  LinSolver ,  BackslashLinSolver  source  #  NonlinearEigenproblems.LinSolvers.GMRESLinSolver  \u2014  Type .   struct GMRESLinSolver <: LinSolver  This represents a solver done with the julia GMRES implementation.  See also:  LinSolver ,  gmres_linsolvercreator  source  #  NonlinearEigenproblems.LinSolvers.gmres_linsolvercreator  \u2014  Function .  gmres_linsolvercreator(nep::NEP, \u03bb, kwargs=())  Create a linear solver of type 'GMRESLinSolver'. The kwargs are passed as parameter to Julia-built-in-GMRES.  See also:  LinSolver ,  GMRESLinSolver  source",
            "title": "LinSolvers"
        },
        {
            "location": "/transformations/",
            "text": "Transforming NEPs\n\n\nThere are various ways to transform NEPs into other NEPs. The simplest example is the function \nshift_and_scale()\n.\n\n\n#\n\n\nNonlinearEigenproblems.NEPTypes.shift_and_scale\n \u2014 \nFunction\n.\n\n\nshift_and_scale(orgnep::NEP;shift=0,scale=1)\n\n\n\n\nTransforms the orgnep by defining a new NEP from the relation T(\u03bb)=M(scale * \u03bb+shift) where M is the orgnep. This function tries  to preserve the NEP type, e.g., a shift\nand\nscale operation on an SPMF-object, return an SPMF object. If it cannot preserve the type, it will return a nep of the struct \nShiftScaledNEP\n.\n\n\nExample\n\n\njulia> nep0=nep_gallery(\"pep0\")\njulia> \u03c3=3; \u03b1=10;\njulia> nep1=shift_and_scale(nep0,shift=\u03c3,scale=\u03b1)\njulia> opnorm(compute_Mder(nep0,\u03b1*(4+4im)+\u03c3)-compute_Mder(nep1,4+4im))\n8.875435870738592e-12\n\n\n\n\nsource\n\n\nSimilarly \nmobius_transform()\n is more general than \nshift_and_scale\n which transform the problem using a M\u00f6bius transformation. The function \ntaylor_exp\n create new PEP by doing truncating a Taylor expansion.\n\n\n\n\nProjection\n\n\nSeveral methods for NEPs are based on forming a smaller NEP, which we will refer to as a projection:\n\n\n$$\nN(\u03bb)=W^HM(\u03bb)V,\n$$\n\n\nwhere $V,W\\in\\mathbb{C}^{n\\times p}$  and the corresponding projected problem\n\n\n$$\nN(\u03bb)u=0.\n$$\n\n\nNEPs which for which this projection can be computed inherit from \nProjectableNEP\n. The most important type is the \nSPMF_NEP\n. \n\n\nYou can create a projected NEP with \ncreate_proj_NEP\n:\n\n\n#\n\n\nNonlinearEigenproblems.NEPTypes.create_proj_NEP\n \u2014 \nFunction\n.\n\n\npnep=create_proj_NEP(orgnep::ProjectableNEP[,maxsize [,T]])\n\n\n\n\nCreate a NEP representing a projected problem. The projection is defined as the problem $N(\u03bb)=W^HM(\u03bb)V$ where $M(\u03bb)$ is represented by \norgnep\n. The optional parameter \nmaxsize\n determines how large the projected problem can be and \nT\n determines which Number type to use (default \nComplexF64\n). These are needed for memory allocation reasons. Use \nset_projectmatrices!()\n to specify projection matrices $V$ and $W$.\n\n\nsource\n\n\n#\n\n\nNonlinearEigenproblems.NEPTypes.set_projectmatrices!\n \u2014 \nMethod\n.\n\n\nset_projectmatrices!(pnep::Proj_NEP,W,V)\n\n\n\n\nSet the projection matrices for the NEP to W and V, i.e., corresponding the NEP: $N(\u03bb)=W^HM(\u03bb)V$.\n\n\nExample:\n\n\nThe following example illustrates that a projection of a \nNEP\n is also a \nNEP\n and we can for instance call \ncompute_Mder\non it:\n\n\njulia> nep=nep_gallery(\"pep0\")\njulia> V=Matrix(1.0*I,size(nep,1),2);\njulia> W=Matrix(1.0*I,size(nep,1),2);\njulia> pnep=create_proj_NEP(nep);\njulia> set_projectmatrices!(pnep,W,V);\njulia> compute_Mder(pnep,3.0)\n2\u00d72 Array{Float64,2}:\n -2.03662   13.9777\n -1.35069  -13.0975\njulia> compute_Mder(nep,3.0)[1:2,1:2]\n2\u00d72 Array{Float64,2}:\n -2.03662   13.9777\n -1.35069  -13.0975\n\n\n\n\nsource\n\n\n\n\nDeflation\n\n\nDue to structure of the representation of NEPs in NEP-PACK it is possible to do deflation, by transformation of the NEP-object. The deflation is based on theory provided in Effenbergers thesis and the main function consists of \neffenberger_deflation\n.\n\n\n#\n\n\nNonlinearEigenproblems.NEPTypes.effenberger_deflation\n \u2014 \nFunction\n.\n\n\neffenberger_deflation(nep::NEP,S0,V0)\n\n\n\n\nThis function creates a deflated NEP based on (S0,V0), which are assumed to an invariant pair of \nnep\n. Effectively, the function should return a NEP which has the same solutions as orgnep, except those corresponding to (S0,V0).\n\n\nExample:\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> (\u03bb,v)=newton(nep);\njulia> n=size(nep,1);\njulia> S0=reshape([\u03bb],1,1);\njulia> V0=reshape(v,n,1);\njulia> dnep=effenberger_deflation(nep,S0,V0)\njulia> (\u03bb2,v2)=augnewton(dnep);  # this converges to different eigval\njulia> minimum(svdvals(compute_Mder(nep,\u03bb2)))\n9.323003321058995e-17\n\n\n\n\nReferences\n\n\n\n\nC. Effenberger, Robust solution methods for nonlinear eigenvalue problems, PhD thesis, 2013, EPF Lausanne\n\n\n\n\nsource",
            "title": "NEP transformations"
        },
        {
            "location": "/transformations/#transforming-neps",
            "text": "There are various ways to transform NEPs into other NEPs. The simplest example is the function  shift_and_scale() .  #  NonlinearEigenproblems.NEPTypes.shift_and_scale  \u2014  Function .  shift_and_scale(orgnep::NEP;shift=0,scale=1)  Transforms the orgnep by defining a new NEP from the relation T(\u03bb)=M(scale * \u03bb+shift) where M is the orgnep. This function tries  to preserve the NEP type, e.g., a shift and scale operation on an SPMF-object, return an SPMF object. If it cannot preserve the type, it will return a nep of the struct  ShiftScaledNEP .  Example  julia> nep0=nep_gallery(\"pep0\")\njulia> \u03c3=3; \u03b1=10;\njulia> nep1=shift_and_scale(nep0,shift=\u03c3,scale=\u03b1)\njulia> opnorm(compute_Mder(nep0,\u03b1*(4+4im)+\u03c3)-compute_Mder(nep1,4+4im))\n8.875435870738592e-12  source  Similarly  mobius_transform()  is more general than  shift_and_scale  which transform the problem using a M\u00f6bius transformation. The function  taylor_exp  create new PEP by doing truncating a Taylor expansion.",
            "title": "Transforming NEPs"
        },
        {
            "location": "/transformations/#projection",
            "text": "Several methods for NEPs are based on forming a smaller NEP, which we will refer to as a projection:  $$\nN(\u03bb)=W^HM(\u03bb)V,\n$$  where $V,W\\in\\mathbb{C}^{n\\times p}$  and the corresponding projected problem  $$\nN(\u03bb)u=0.\n$$  NEPs which for which this projection can be computed inherit from  ProjectableNEP . The most important type is the  SPMF_NEP .   You can create a projected NEP with  create_proj_NEP :  #  NonlinearEigenproblems.NEPTypes.create_proj_NEP  \u2014  Function .  pnep=create_proj_NEP(orgnep::ProjectableNEP[,maxsize [,T]])  Create a NEP representing a projected problem. The projection is defined as the problem $N(\u03bb)=W^HM(\u03bb)V$ where $M(\u03bb)$ is represented by  orgnep . The optional parameter  maxsize  determines how large the projected problem can be and  T  determines which Number type to use (default  ComplexF64 ). These are needed for memory allocation reasons. Use  set_projectmatrices!()  to specify projection matrices $V$ and $W$.  source  #  NonlinearEigenproblems.NEPTypes.set_projectmatrices!  \u2014  Method .  set_projectmatrices!(pnep::Proj_NEP,W,V)  Set the projection matrices for the NEP to W and V, i.e., corresponding the NEP: $N(\u03bb)=W^HM(\u03bb)V$.  Example:  The following example illustrates that a projection of a  NEP  is also a  NEP  and we can for instance call  compute_Mder on it:  julia> nep=nep_gallery(\"pep0\")\njulia> V=Matrix(1.0*I,size(nep,1),2);\njulia> W=Matrix(1.0*I,size(nep,1),2);\njulia> pnep=create_proj_NEP(nep);\njulia> set_projectmatrices!(pnep,W,V);\njulia> compute_Mder(pnep,3.0)\n2\u00d72 Array{Float64,2}:\n -2.03662   13.9777\n -1.35069  -13.0975\njulia> compute_Mder(nep,3.0)[1:2,1:2]\n2\u00d72 Array{Float64,2}:\n -2.03662   13.9777\n -1.35069  -13.0975  source",
            "title": "Projection"
        },
        {
            "location": "/transformations/#deflation",
            "text": "Due to structure of the representation of NEPs in NEP-PACK it is possible to do deflation, by transformation of the NEP-object. The deflation is based on theory provided in Effenbergers thesis and the main function consists of  effenberger_deflation .  #  NonlinearEigenproblems.NEPTypes.effenberger_deflation  \u2014  Function .  effenberger_deflation(nep::NEP,S0,V0)  This function creates a deflated NEP based on (S0,V0), which are assumed to an invariant pair of  nep . Effectively, the function should return a NEP which has the same solutions as orgnep, except those corresponding to (S0,V0).  Example:  julia> nep=nep_gallery(\"dep0\");\njulia> (\u03bb,v)=newton(nep);\njulia> n=size(nep,1);\njulia> S0=reshape([\u03bb],1,1);\njulia> V0=reshape(v,n,1);\njulia> dnep=effenberger_deflation(nep,S0,V0)\njulia> (\u03bb2,v2)=augnewton(dnep);  # this converges to different eigval\njulia> minimum(svdvals(compute_Mder(nep,\u03bb2)))\n9.323003321058995e-17  References   C. Effenberger, Robust solution methods for nonlinear eigenvalue problems, PhD thesis, 2013, EPF Lausanne   source",
            "title": "Deflation"
        },
        {
            "location": "/gallery/",
            "text": "A large number of examples are provided in the \nnep_gallery\n.\n\n\njulia> using Gallery\njulia> nep=nep_gallery(\"dep0\")\njulia> \u03bb,v=newton(nep)\n(-0.3587189459686265 + 0.0im, Complex{Float64}[0.284742+0.0im, -0.143316+0.0im, 0.278378+0.0im, -0.5009+0.0im, -0.613634+0.0im])\njulia> norm(compute_Mlincomb(nep,\u03bb,v))\n4.718447854656915e-16\n\n\n\n\nIf MATLAB and the Berlin-Manchester collection areinstalled, we can access them with the GalleryNLEVP (which does MATLAB-access through julia's MATLAB-package).\n\n\njulia> using GalleryNLEVP\njulia> nep=nep_gallery(NLEVP_NEP,\"hadeler\")\njulia> \u03bb,v=quasinewton(nep,\u03bb=0.2,displaylevel=1,maxit=20,tol=1e-10);\njulia> norm(compute_Mlincomb(nep,\u03bb,v))/norm(v)\n9.698206079849311e-11\n\n\n\n\nProblems loaded from the Berlin-Manchester collection are NEP-objects where every call to access a function generates a call to an underlying MATLAB-session. Some problems in the Berlin-Manchester collection have native support in NEPPACK, i.e., avoiding a MATLAB-access in every call. The native equivalent object is generated with  \nnlevp_make_native\n:\n\n\njulia> using GalleryNLEVP\njulia> nep1=nep_gallery(NLEVP_NEP,\"gun\")\njulia> nep2=nlevp_make_native(nep1);\njulia> norm(compute_Mder(nep1,0)-compute_Mder(nep2,0),1)\n0.0\n\n\n\n\nStand-alone implementation can be accessed in a similar way, e.g., a native implementation of the waveguide eigenvalue problem:\n\n\njulia> using GalleryWaveguide\njulia> nep=nep_gallery(WEP,benchmark_problem=\"TAUSCH\");",
            "title": "NEP Gallery"
        },
        {
            "location": "/development/",
            "text": "Developer info\n\n\n\n\nCompiling the documentation\n\n\nCompile this documentation page by running:\n\n\njarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ julia --color=yes make.jl &&  mkdocs build --clean\njarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ firefox site/index.html\n\n\n\n\nIf you want this to appear on our documentation page \nhttps://nep-pack.github.io/NonlinearEigenproblems.jl/\n you need to push it to the \ngh-branch\n, e.g.,  by running\n\n\njarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ export DOCSDIR=`pwd`\njarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ cd /tmp\njarl@bjork:/tmp$ git clone -b \"gh-pages\" git@github.com:nep-pack/NonlinearEigenproblems.jl.git\njarl@bjork:/tmp$ cd NonlinearEigenproblems.jl\njarl@bjork:/tmp/NonlinearEigenproblems.jl$ cp -r $DOCSDIR/site/* .\njarl@bjork:/tmp/NonlinearEigenproblems.jl$ git add *;  git commit . -m \"refresh docs\"; git push\n\n\n\n\nMore information about \nDocumenter.jl\n: \nhere",
            "title": "Developer info"
        },
        {
            "location": "/development/#developer-info",
            "text": "",
            "title": "Developer info"
        },
        {
            "location": "/development/#compiling-the-documentation",
            "text": "Compile this documentation page by running:  jarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ julia --color=yes make.jl &&  mkdocs build --clean\njarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ firefox site/index.html  If you want this to appear on our documentation page  https://nep-pack.github.io/NonlinearEigenproblems.jl/  you need to push it to the  gh-branch , e.g.,  by running  jarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ export DOCSDIR=`pwd`\njarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ cd /tmp\njarl@bjork:/tmp$ git clone -b \"gh-pages\" git@github.com:nep-pack/NonlinearEigenproblems.jl.git\njarl@bjork:/tmp$ cd NonlinearEigenproblems.jl\njarl@bjork:/tmp/NonlinearEigenproblems.jl$ cp -r $DOCSDIR/site/* .\njarl@bjork:/tmp/NonlinearEigenproblems.jl$ git add *;  git commit . -m \"refresh docs\"; git push  More information about  Documenter.jl :  here",
            "title": "Compiling the documentation"
        }
    ]
}