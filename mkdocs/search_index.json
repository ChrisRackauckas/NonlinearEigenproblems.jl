{
    "docs": [
        {
            "location": "/",
            "text": "NEPPACK\n\n\nNEPPACK is a package with implementations of methods to solve nonlinear eigenvalue problems of the type: Find $(\u03bb,v)\\in\\mathbb{C}\\times\\mathbb{C}^n$ such that\n\n\n$$\nM(\u03bb)v=0\n$$\n\n\nand $v\\neq 0$.\n\n\n\n\nGetting started\n\n\nInstall it as an unregistered package in julia's REPL package mode by writing \n] add git:/..\n:\n\n\n(v1.0) pkg> add git://github.com/nep-pack/NonlinearEigenproblems.jl.git\n\n\n\n\n\nThen we can start to load some NEP-PACK packages\n\n\njulia> using NonlinearEigenproblems.NEPSolver\njulia> using NonlinearEigenproblems.NEPTypes\njulia> using LinearAlgebra\n\n\n\n\nWe are now ready to create and solve a nonlinear eigenvalue problem, in this illustrative example we set\n\n\n$$\nM(\u03bb)=\\begin{bmatrix}1&3\\newline5&6\\end{bmatrix}+\n\u03bb\\begin{bmatrix}3&4\\newline6&6\\end{bmatrix}+\n\u03bb^2\\begin{bmatrix}1&0\\newline0&1\\end{bmatrix}\n$$\n\n\nThe following code creates this NEP (which is a so called polynomial eigenvalue problem) and solves it using the NEP solution method implemented in \npolyeig()\n:\n\n\njulia> A0=[1.0 3; 5 6]; A1=[3.0 4; 6 6]; A2=[1.0 0; 0 1.0];\njulia> nep=PEP([A0,A1,A2])\nPEP(2, Array{Float64,2}[[1.0 3.0; 5.0 6.0], [3.0 4.0; 6.0 6.0], [1.0 0.0; 0.0 1.0]])\njulia> \u03bb,v=polyeig(nep)\n(Complex{Float64}[1.36267+0.0im, -0.824084+0.280682im, -0.824084-0.280682im, -8.7145+0.0im], Complex{Float64}[-1.0+0.0im 0.739183-0.196401im 0.739183+0.196401im 0.627138+0.0im; 0.821812+0.0im -0.501408-0.375337im -0.501408+0.375337im 1.0+0.0im])\n\n\n\n\nYou have now solved your first nonlinear eigenvalue problem with NEPPACK.\n\n\nIn order to verify that we have a solution, we can check that  $M(\u03bb)$ is singular, with a singular vector $v$ such that $M(\u03bb)v=0$:\n\n\njulia> \u03bb1=\u03bb[1]; v1=v[:,1];\njulia> norm(A0*v1+\u03bb1*A1*v1+\u03bb1^2*v1)/norm(v1)\n1.1502634749464687e-14\n\n\n\n\n\n\nAccessing more complicated applications\n\n\nWe have made benchmark examples available in the module \nGallery\n. Use it by loading the module and calling the function \nnep_gallery\n:\n\n\njulia> using NonlinearEigenproblems.Gallery\njulia> nep=nep_gallery(\"dep0\",100);\njulia> size(nep)\n(100, 100)\njulia> \u03bb,v=mslp(nep,tol=1e-10);\njulia> \u03bb\n0.23169217667341738 - 2.1866254654451488e-16im\njulia> size(v)\n(100,)\njulia> resnorm=norm(compute_Mlincomb(nep,\u03bb,v))\n3.124042808475689e-14\n\n\n\n\nInformation about the gallery can be found by typing \n?nep_gallery\n. The second arument in the call to \nnep_gallery\n is a problem parameter, in this case specifying that the  size of the problem should be \n100\n. The example solves the problem with the method MSLP. The parameter \ntol\n specifies the tolerance for iteration termination. Type \n?mslp\n for more information about this method.\n\n\n\n\nA model of a neuron\n\n\nThe following (delay) differential equation models a neuron\n\n\n$$\n\\dot{x}_1(t)=-\\kappa x_1(t)+\\beta\\tanh(x_1(t-\\tau_3))+a_1\\tanh(x_2(t-\\tau_2))\n$$\n\n\n$$\n\\dot{x}_2(t)=-\\kappa x_2(t)+\\beta\\tanh(x_2(t-\\tau_3))+a_2\\tanh(x_1(t-\\tau_1))\n$$\n\n\nSee \nL. P. Shayer and S. A. Campbell.  Stability, bifurcation and multistability in a system of two coupled neurons with multiple time delays. SIAM J. Applied Mathematics , 61(2):673\u2013700, 2000\n. It is also available as a first demo in \nDDE-BIFTOOL\n. The linear stability analysis of this problem requires the solution of a nonlinear eigenvalue eigenvalue problem\n\n\n$$\nM(\u03bb)=-\u03bbI+A_0+A_1e^{-\\tau_1\u03bb}+A_2e^{-\\tau_2\u03bb}+A_3e^{-\\tau_3\u03bb}\n$$\n\n\nwhere the matrices are the Jacobian at the stationary solution. For the zero stationary solution, the matrices are\n\n\nkappa=0.5; a2=2.34; a1=1; beta=-1;\nA0=-kappa*[1 0; 0 1];\nA1=a2*[0 0; 1 0];\nA2=a1*[0 1; 0 0];\nA3=beta*[1 0; 0 1];\n\n\n\n\nWe can now create the nonlinear eigenvalue problem and compute the stability by first creating the problem\n\n\njulia> tauv=[0;0.2;0.2;1.5];\njulia> dep=DEP([A0, A1,   A2, A3],tauv);\n\n\n\n\nand solving it with for instance the infinite Arnoldi method\n\n\njulia> \u03bb,V=iar_chebyshev(dep,maxit=100); # This takes some time the first time is run due to JIT-compiler\n\n\n\n\nThe figure in a demo of DDE-BIFTOOL \nhttp://ddebiftool.sourceforge.net/demos/neuron/html/demo1_stst.html\n can be directly generated by\n\n\njulia> using PyPlot;\njulia> plot(real(\u03bb),imag(\u03bb),\"*\")\n\n\n\n\nThis problem is also available in the \nGallery\n by calling \ndep=nep_gallery(\"neuron0\")\n.\n\n\n\n\nWhat now?\n\n\nNow you are ready to have a look at the examples in \nNEP methods\n and  \nNEP Gallery\n.",
            "title": "Introduction"
        },
        {
            "location": "/#neppack",
            "text": "NEPPACK is a package with implementations of methods to solve nonlinear eigenvalue problems of the type: Find $(\u03bb,v)\\in\\mathbb{C}\\times\\mathbb{C}^n$ such that  $$\nM(\u03bb)v=0\n$$  and $v\\neq 0$.",
            "title": "NEPPACK"
        },
        {
            "location": "/#getting-started",
            "text": "Install it as an unregistered package in julia's REPL package mode by writing  ] add git:/.. :  (v1.0) pkg> add git://github.com/nep-pack/NonlinearEigenproblems.jl.git  Then we can start to load some NEP-PACK packages  julia> using NonlinearEigenproblems.NEPSolver\njulia> using NonlinearEigenproblems.NEPTypes\njulia> using LinearAlgebra  We are now ready to create and solve a nonlinear eigenvalue problem, in this illustrative example we set  $$\nM(\u03bb)=\\begin{bmatrix}1&3\\newline5&6\\end{bmatrix}+\n\u03bb\\begin{bmatrix}3&4\\newline6&6\\end{bmatrix}+\n\u03bb^2\\begin{bmatrix}1&0\\newline0&1\\end{bmatrix}\n$$  The following code creates this NEP (which is a so called polynomial eigenvalue problem) and solves it using the NEP solution method implemented in  polyeig() :  julia> A0=[1.0 3; 5 6]; A1=[3.0 4; 6 6]; A2=[1.0 0; 0 1.0];\njulia> nep=PEP([A0,A1,A2])\nPEP(2, Array{Float64,2}[[1.0 3.0; 5.0 6.0], [3.0 4.0; 6.0 6.0], [1.0 0.0; 0.0 1.0]])\njulia> \u03bb,v=polyeig(nep)\n(Complex{Float64}[1.36267+0.0im, -0.824084+0.280682im, -0.824084-0.280682im, -8.7145+0.0im], Complex{Float64}[-1.0+0.0im 0.739183-0.196401im 0.739183+0.196401im 0.627138+0.0im; 0.821812+0.0im -0.501408-0.375337im -0.501408+0.375337im 1.0+0.0im])  You have now solved your first nonlinear eigenvalue problem with NEPPACK.  In order to verify that we have a solution, we can check that  $M(\u03bb)$ is singular, with a singular vector $v$ such that $M(\u03bb)v=0$:  julia> \u03bb1=\u03bb[1]; v1=v[:,1];\njulia> norm(A0*v1+\u03bb1*A1*v1+\u03bb1^2*v1)/norm(v1)\n1.1502634749464687e-14",
            "title": "Getting started"
        },
        {
            "location": "/#accessing-more-complicated-applications",
            "text": "We have made benchmark examples available in the module  Gallery . Use it by loading the module and calling the function  nep_gallery :  julia> using NonlinearEigenproblems.Gallery\njulia> nep=nep_gallery(\"dep0\",100);\njulia> size(nep)\n(100, 100)\njulia> \u03bb,v=mslp(nep,tol=1e-10);\njulia> \u03bb\n0.23169217667341738 - 2.1866254654451488e-16im\njulia> size(v)\n(100,)\njulia> resnorm=norm(compute_Mlincomb(nep,\u03bb,v))\n3.124042808475689e-14  Information about the gallery can be found by typing  ?nep_gallery . The second arument in the call to  nep_gallery  is a problem parameter, in this case specifying that the  size of the problem should be  100 . The example solves the problem with the method MSLP. The parameter  tol  specifies the tolerance for iteration termination. Type  ?mslp  for more information about this method.",
            "title": "Accessing more complicated applications"
        },
        {
            "location": "/#a-model-of-a-neuron",
            "text": "The following (delay) differential equation models a neuron  $$\n\\dot{x}_1(t)=-\\kappa x_1(t)+\\beta\\tanh(x_1(t-\\tau_3))+a_1\\tanh(x_2(t-\\tau_2))\n$$  $$\n\\dot{x}_2(t)=-\\kappa x_2(t)+\\beta\\tanh(x_2(t-\\tau_3))+a_2\\tanh(x_1(t-\\tau_1))\n$$  See  L. P. Shayer and S. A. Campbell.  Stability, bifurcation and multistability in a system of two coupled neurons with multiple time delays. SIAM J. Applied Mathematics , 61(2):673\u2013700, 2000 . It is also available as a first demo in  DDE-BIFTOOL . The linear stability analysis of this problem requires the solution of a nonlinear eigenvalue eigenvalue problem  $$\nM(\u03bb)=-\u03bbI+A_0+A_1e^{-\\tau_1\u03bb}+A_2e^{-\\tau_2\u03bb}+A_3e^{-\\tau_3\u03bb}\n$$  where the matrices are the Jacobian at the stationary solution. For the zero stationary solution, the matrices are  kappa=0.5; a2=2.34; a1=1; beta=-1;\nA0=-kappa*[1 0; 0 1];\nA1=a2*[0 0; 1 0];\nA2=a1*[0 1; 0 0];\nA3=beta*[1 0; 0 1];  We can now create the nonlinear eigenvalue problem and compute the stability by first creating the problem  julia> tauv=[0;0.2;0.2;1.5];\njulia> dep=DEP([A0, A1,   A2, A3],tauv);  and solving it with for instance the infinite Arnoldi method  julia> \u03bb,V=iar_chebyshev(dep,maxit=100); # This takes some time the first time is run due to JIT-compiler  The figure in a demo of DDE-BIFTOOL  http://ddebiftool.sourceforge.net/demos/neuron/html/demo1_stst.html  can be directly generated by  julia> using PyPlot;\njulia> plot(real(\u03bb),imag(\u03bb),\"*\")  This problem is also available in the  Gallery  by calling  dep=nep_gallery(\"neuron0\") .",
            "title": "A model of a neuron"
        },
        {
            "location": "/#what-now",
            "text": "Now you are ready to have a look at the examples in  NEP methods  and   NEP Gallery .",
            "title": "What now?"
        },
        {
            "location": "/methods/",
            "text": "NEP Methods\n\n\nThe NEP solver methods implemented in NEP-pack, are accessed by the functions below. The functions all return $\u03bb,v,w$ where $\u03bb$ is either a number (eigenvalue) a vector of eigenvalues $v$ is either a vector containing an eigenvector or a matrix whose columns corresponding to the eigenvectors.\n\n\nThe first parameter optional parameter in all NEP solver methods is a type. This type specifies which arithmetic should be used for the algorithm.\n\n\nExample:\n\n\njulia> nep=nep_gallery(\"dep0\")\njulia> \u03bb,v=augnewton(Complex128,nep,v=ones(5))\n(0.8347353572199425 + 0.0im, Complex{Float64}[0.480386+0.0im, 0.0631636+0.0im, -0.136405+0.0im, 0.214274+0.0im, 0.378581+0.0im])\njulia> typeof(\u03bb)\nComplex{Float64}\njulia> \u03bb,v=augnewton(Float16,nep,v=ones(5))\n(Float16(0.8223), Float16[0.47388, 0.063904, -0.13843, 0.21692, 0.38306])\njulia> typeof(\u03bb)\nFloat16\n\n\n\n\n\n\nNewton type methods\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.newton\n \u2014 \nFunction\n.\n\n\n\u03bb,v = newton([eltype],nep::NEP;[errmeasure,][tol,][maxit,][\u03bb,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max])\n\n\n\n\nApplies Newton-Raphsons method on the system of nonlinear equations with \nn+1\n unknowns:\n\n\n$$\nM(\u03bb)v=0\n$$\n\n\n$$\nc^Hv-1=0\n$$\n\n\nThe kwarg \nerrmeasure\n is a function handle which can be used to specify how the error is measured to be used in termination (default is absolute residual norm). The iteration is continued until errmeausure is less than \ntol\n. \n\u03bb\n and \nv\n are starting approximations. \nc\n is the orthogonalization vector.  If \nc=0\n the current approximation will be used for the orthogonalization. \narmijo_factor\n specifies if an Armijo rule should be applied, and its value specifies the scaling factor of the step length (per reduction step). The variable \narmijo_max\n specifies the maximum number of step length reductions.\n\n\nExample\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> \u03bb,v=newton(nep);\njulia> minimum(svdvals(compute_Mder(nep,\u03bb)))\n1.6066157878930876e-16\n\n\n\n\nReferences\n\n\n\n\nNichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.\n\n\nA. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689\n\n\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.augnewton\n \u2014 \nFunction\n.\n\n\naugnewton([eltype], nep::NEP; [errmeasure,][tol,][maxit,][\u03bb,][v,][c,][displaylevel,][linsolvercreator,][armijo_factor,][armijo_max])\n\n\n\n\nRun the augmented Newton method. The method is equivalent to \nnewton()\n in exact arithmetic,  but works only with operations on vectors of length \nn\n. The \nlinsolvecreator\n is used to initiate linear solvers. See \nnewton()\n for other parameters.\n\n\nExample\n\n\nThis illustrates the equivalence between \nnewton\n and \naugnewton\n.\n\n\njulia> nep=nep_gallery(\"dep1\")\njulia> \u03bb1,v1=newton(nep,maxit=20,v=ones(size(nep,1)),\u03bb=0)\njulia> \u03bb2,v2=augnewton(nep,maxit=20,v=ones(size(nep,1)),\u03bb=0)\njulia> \u03bb1-\u03bb2\n0.0 + 0.0im\n\n\n\n\nReferences\n\n\n\n\nNichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.\n\n\nA. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689\n\n\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.resinv\n \u2014 \nFunction\n.\n\n\n\u03bb,v = resinv([eltype],nep::NEP;[errmeasure,][tol,][maxit,][\u03bb,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max,][linsolvecreator])\n\n\n\n\nApplies residual inverse iteration method for nonlinear eigenvalue problems. The kwarg \nlinsolvecreator\n is a function which specifies how the linear system is created. The function calls \ncompute_rf\n for the computation of the Rayleigh functional. See \nnewton()\n for other parameters.\n\n\nExample\n\n\nThe example shows how to specify if the method should run in real or complex mode (or any other \nNumber\n type).\n\n\njulia> nep=nep_gallery(\"qdep0\");\njulia> \u03bb,v=resinv(nep,\u03bb=-2,v=ones(size(nep,1)))\njulia> typeof(\u03bb)\nComplex{Float64}\njulia> norm(compute_Mlincomb(nep,\u03bb,v))\n1.817030659827106e-14\njulia> \u03bb,v=resinv(Float64,nep,\u03bb=-2,v=ones(size(nep,1)))\njulia> typeof(\u03bb)\nFloat64\njulia> norm(compute_Mlincomb(nep,\u03bb,v))\n1.817030659827106e-14\n\n\n\n\nReferences\n\n\n\n\nA. Neumaier, Residual inverse iteration for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 22 (1985) 914-923\n\n\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.quasinewton\n \u2014 \nFunction\n.\n\n\nquasinewton([T=ComplexF64],nep,[errmeasure,][tol,][maxit,][\u03bb,][v][ws][displaylevel][linsolvercreator,][armijo_factor,][armijo_max])\n\n\n\n\nAn implementation of the quasi-Newton approach referred to as quasi-Newton 2 in the reference. The method involves one linear system solve per iteration corresponding with the matrix $M(\u03bb)$, where $\u03bb$ is constant. The vector \nws\n is a representation of the normalization, in the sense that $c^T=w_s^TM(\u03bb)$, where all iterates satisfy $c^Tx_i=1$. See \nnewton()\n for other parameters.\n\n\nExample\n\n\njulia> nep=nep_gallery(\"pep0\")\njulia> \u03bb,v=quasinewton(nep,v=ones(size(nep,1)));\njulia> norm(compute_Mlincomb(nep,\u03bb,v))/norm(v)\n6.301479387102376e-15\n\n\n\n\nReferences\n\n\n\n\nJarlebring, Koskela, Mele, Disguised and new Quasi-Newton methods for nonlinear eigenvalue problems, arxiv preprint: https://arxiv.org/abs/1702.08492\n\n\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.mslp\n \u2014 \nFunction\n.\n\n\n mslp([eltype],nep::NEP;[errmeasure,][tol,][maxit,][\u03bb,][v,][displaylevel,][eigsolvertype::DataType][armijo_factor=1,][armijo_max])\n\n\n\n\nRuns the method of successive linear problems. The  method requires the solution of a generalized eigenvalue problem in every iteration. The method used for the eigenvalue computation is specified in eigsolvertype. See \nnewton\n for other parameters.\n\n\nExample\n\n\nCreate a rational NEP with SPMFs.\n\n\njulia> Av=[ones(3,3),eye(3,3),triu(ones(3,3))];\njulia> fv=[S-> S, S -> S^2, S::AbstractArray -> inv(Matrix(S)-eye(S)*10)]\njulia> nep=SPMF_NEP(Av,fv)\njulia> (\u03bb,v)=mslp(nep)\njulia> compute_Mlincomb(nep,\u03bb,v)\n3-element Array{Complex{Float64},1}:\n -1.38778e-17+1.65715e-18im\n -5.55112e-17+1.30633e-17im\n -4.16334e-17-1.54436e-17im\n\n\n\n\nReferences\n\n\n\n\nA. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689\n\n\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.rfi\n \u2014 \nFunction\n.\n\n\nrfi(nep,nept,[\u03bb=0,][errmeasure=default_errmeasure,][tol=eps()*100,][maxit=100,][v=randn,][u=randn,][displaylevel=0,][linsolvecreator=default_linsolvecreator,])\n\n\n\n\nThis is an implementation of the two-sided Rayleigh functional Iteration. This method requires the transpose of the NEP, which needs to be provided in nept.\n\n\nExample:\n\n\njulia> nep=nep\ngallery(\"dep0\"); julia> nept=DEP([nep.A[1]',nep.A[2]']) julia> \u03bb,v,u=rfi(nep,nept,v=ones(size(nep,1))) julia> opnorm(compute\nMder(nep,\u03bb)\nv) % v is a right eigenvector 5.4672143489065705e-16 julia> opnorm(u'\ncompute_Mder(nep,\u03bb)) % u is a left eigenvector 4.1447913221215544e-16\n\n\nReference\n\n\n\n\nAlgorithm 4 in  Schreiber, Nonlinear Eigenvalue Problems: Newton-type Methods and Nonlinear Rayleigh Functionals, PhD thesis, TU Berlin, 2008\n\n\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.newtonqr\n \u2014 \nFunction\n.\n\n\nNewton-QR method.\n\n\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.implicitdet\n \u2014 \nFunction\n.\n\n\nImplicit determinant method\n\n\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.broyden\n \u2014 \nFunction\n.\n\n\nS,V = broyden([eltype,]nep::NEP[,approxnep::NEP];kwargs)\n\n\n\n\nRuns Broydens method (with deflation) for the nonlinear eigenvalue problem defined by nep. An approximate nep can be provided which is used as an initialization of starting matrix/vectors.\n\n\nThe method computes an invariant pair and can therefore find several eigenvalues. The retured value is (S,V) is an invariant pair and the eigenvalues are on the diagonal of S.\n\n\nExample\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> S,V=broyden(nep);\njulia> \u03bb=S[1,1]\n-0.3587189459686267 - 3.0010731412746105e-31im\njulia> minimum(svdvals(compute_Mder(nep,\u03bb)))\n1.6066157878930856e-16\njulia> \u03bb=S[2,2]\n-0.04093521177097334 + 1.486011530941621im\njulia> minimum(svdvals(compute_Mder(nep,\u03bb)))\n4.159109513753696e-16\njulia> \u03bb=S[3,3]\n0.8347353572199486 + 1.5032076225139986e-14im\njulia> minimum(svdvals(compute_Mder(nep,\u03bb)))\n1.296144276122994e-14\njulia> broyden(nep,displaylevel=2,check_error_every=1);  % Prints out a lot more convergence info\n\n\n\n\nReferences\n\n\n\n\nJarlebring, Broyden\u2019s method for nonlinear eigenproblems, 2018, https://arxiv.org/pdf/1802.07322\n\n\n\n\n\n\nProjection methods\n\n\nnlar\n\n\n\n\n\n\nArnoldi type methods\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.iar\n \u2014 \nFunction\n.\n\n\niar(nep,[maxit=30,][\u03c3=0,][\u03b3=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])\n\n\n\n\nInfinite Arnoldi method\n\n\nRuns the infinite Arnoldi method which tries to find eigenvalues close to the shift \u03c3.\n\n\nExample\n\n\njulia> using NonlinearEigenproblems: NEPSolver, NEPCore, Gallery\njulia> nep=nep_gallery(\"dep0\");\njulia> \u03bb,v=iar(nep);\njulia> minimum(svdvals(compute_Mder(nep,\u03bb[1]))) % Is it an eigenvalue?\n\n\n\n\n\nReferences\n\n\n\n\nAlgorithm 2 in Jarlebring, Michiels Meerbergen, A linear eigenvalue algorithm for the nonlinear eigenvalue problem, Numer. Math, 2012\n\n\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.tiar\n \u2014 \nFunction\n.\n\n\ntiar(nep,[maxit=30,][\u03c3=0,][\u03b3=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])\n\n\n\n\nRuns the tensor infinite Arnoldi method which tries to find eigenvalues close to the shift \u03c3.\n\n\nExample\n\n\njulia> using NonlinearEigenproblems: NEPSolver, NEPCore, Gallery\njulia> nep=nep_gallery(\"dep0\",100);\njulia> v0=ones(size(nep,1));\njulia> \u03bb,v=iar(nep,v=v0,tol=1e-5,Neig=3);\njulia> \u03bb\n3-element Array{Complex{Float64},1}:\n -0.156062-0.122734im\n -0.156062+0.122734im\n  0.231692+4.82981e-17im\njulia> \u03bb,v=iar(nep,v=v0,tol=1e-5,Neig=3);\njulia> \u03bb  % Same eigenvalues are computed\n3-element Array{Complex{Float64},1}:\n -0.156062-0.122734im\n -0.156062+0.122734im\n  0.231692+4.82981e-17im\n\n\n\n\nReferences\n\n\n\n\nAlgorithm 2 in Jarlebring, Mele, Runborg, The Waveguide Eigenvalue Problem and the Tensor Infinite Arnoldi Method, SIAM J. Scient. computing, 39 (3), A1062-A1088, 2017\n\n\n\n\n#\n\n\nNonlinearEigenproblems.NEPSolver.infbilanczos\n \u2014 \nFunction\n.\n\n\n\u03bbv,V,U=infbilanczos([eltype],nep, nept,[linsolvecreator,][linsolvertcreator,][v,][u,][\u03c3,][\u03b3,][tol,][Neig,][errmeasure,][displaylevel,][maxit,][check_error_every])\n\n\n\n\nExecutes the Infinite Bi-Lanczos method on the problem defined by \nnep::NEP\n and \nnept::NEP\n. \nnep:NEP\n is the original nonlinear eigenvalue problem and \nnept::NEP\n is its (hermitian) transpose: $M(\u03bb^*)^H$.  \nv\n and \nu\n are starting vectors, \n\u03c3\n is the shift and \n\u03b3\n the scaling.  See \nnewton()\n for other parameters.\n\n\nExample:\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> A=get_Av(nep); fv=get_fv(nep);\njulia> nept=SPMF_NEP([A[1]',A[2]',A[3]'],fv); # Create the transposed NEP\njulia> \u03bbv,V=infbilanczos(nep,nept,Neig=3)\njulia> norm(compute_Mlincomb(nep,\u03bbv[1],V[:,1]))\n\n\n\n\nReferences:\n\n\n\n\nThe infinite bi-Lanczos method for nonlinear eigenvalue problems, S. W. Gaaf and E. Jarlebring, arxiv: 1607.03454, to appear in SIAM J. Scientific Computing\n\n\n\n\n\n\nClass specific methods\n\n\n\n\nCompanion linearizations\n\n\n\n\nRational ?",
            "title": "NEP Methods"
        },
        {
            "location": "/methods/#nep-methods",
            "text": "The NEP solver methods implemented in NEP-pack, are accessed by the functions below. The functions all return $\u03bb,v,w$ where $\u03bb$ is either a number (eigenvalue) a vector of eigenvalues $v$ is either a vector containing an eigenvector or a matrix whose columns corresponding to the eigenvectors.  The first parameter optional parameter in all NEP solver methods is a type. This type specifies which arithmetic should be used for the algorithm.  Example:  julia> nep=nep_gallery(\"dep0\")\njulia> \u03bb,v=augnewton(Complex128,nep,v=ones(5))\n(0.8347353572199425 + 0.0im, Complex{Float64}[0.480386+0.0im, 0.0631636+0.0im, -0.136405+0.0im, 0.214274+0.0im, 0.378581+0.0im])\njulia> typeof(\u03bb)\nComplex{Float64}\njulia> \u03bb,v=augnewton(Float16,nep,v=ones(5))\n(Float16(0.8223), Float16[0.47388, 0.063904, -0.13843, 0.21692, 0.38306])\njulia> typeof(\u03bb)\nFloat16",
            "title": "NEP Methods"
        },
        {
            "location": "/methods/#newton-type-methods",
            "text": "#  NonlinearEigenproblems.NEPSolver.newton  \u2014  Function .  \u03bb,v = newton([eltype],nep::NEP;[errmeasure,][tol,][maxit,][\u03bb,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max])  Applies Newton-Raphsons method on the system of nonlinear equations with  n+1  unknowns:  $$\nM(\u03bb)v=0\n$$  $$\nc^Hv-1=0\n$$  The kwarg  errmeasure  is a function handle which can be used to specify how the error is measured to be used in termination (default is absolute residual norm). The iteration is continued until errmeausure is less than  tol .  \u03bb  and  v  are starting approximations.  c  is the orthogonalization vector.  If  c=0  the current approximation will be used for the orthogonalization.  armijo_factor  specifies if an Armijo rule should be applied, and its value specifies the scaling factor of the step length (per reduction step). The variable  armijo_max  specifies the maximum number of step length reductions.  Example  julia> nep=nep_gallery(\"dep0\");\njulia> \u03bb,v=newton(nep);\njulia> minimum(svdvals(compute_Mder(nep,\u03bb)))\n1.6066157878930876e-16  References   Nichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.  A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689   #  NonlinearEigenproblems.NEPSolver.augnewton  \u2014  Function .  augnewton([eltype], nep::NEP; [errmeasure,][tol,][maxit,][\u03bb,][v,][c,][displaylevel,][linsolvercreator,][armijo_factor,][armijo_max])  Run the augmented Newton method. The method is equivalent to  newton()  in exact arithmetic,  but works only with operations on vectors of length  n . The  linsolvecreator  is used to initiate linear solvers. See  newton()  for other parameters.  Example  This illustrates the equivalence between  newton  and  augnewton .  julia> nep=nep_gallery(\"dep1\")\njulia> \u03bb1,v1=newton(nep,maxit=20,v=ones(size(nep,1)),\u03bb=0)\njulia> \u03bb2,v2=augnewton(nep,maxit=20,v=ones(size(nep,1)),\u03bb=0)\njulia> \u03bb1-\u03bb2\n0.0 + 0.0im  References   Nichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.  A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689   #  NonlinearEigenproblems.NEPSolver.resinv  \u2014  Function .  \u03bb,v = resinv([eltype],nep::NEP;[errmeasure,][tol,][maxit,][\u03bb,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max,][linsolvecreator])  Applies residual inverse iteration method for nonlinear eigenvalue problems. The kwarg  linsolvecreator  is a function which specifies how the linear system is created. The function calls  compute_rf  for the computation of the Rayleigh functional. See  newton()  for other parameters.  Example  The example shows how to specify if the method should run in real or complex mode (or any other  Number  type).  julia> nep=nep_gallery(\"qdep0\");\njulia> \u03bb,v=resinv(nep,\u03bb=-2,v=ones(size(nep,1)))\njulia> typeof(\u03bb)\nComplex{Float64}\njulia> norm(compute_Mlincomb(nep,\u03bb,v))\n1.817030659827106e-14\njulia> \u03bb,v=resinv(Float64,nep,\u03bb=-2,v=ones(size(nep,1)))\njulia> typeof(\u03bb)\nFloat64\njulia> norm(compute_Mlincomb(nep,\u03bb,v))\n1.817030659827106e-14  References   A. Neumaier, Residual inverse iteration for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 22 (1985) 914-923   #  NonlinearEigenproblems.NEPSolver.quasinewton  \u2014  Function .  quasinewton([T=ComplexF64],nep,[errmeasure,][tol,][maxit,][\u03bb,][v][ws][displaylevel][linsolvercreator,][armijo_factor,][armijo_max])  An implementation of the quasi-Newton approach referred to as quasi-Newton 2 in the reference. The method involves one linear system solve per iteration corresponding with the matrix $M(\u03bb)$, where $\u03bb$ is constant. The vector  ws  is a representation of the normalization, in the sense that $c^T=w_s^TM(\u03bb)$, where all iterates satisfy $c^Tx_i=1$. See  newton()  for other parameters.  Example  julia> nep=nep_gallery(\"pep0\")\njulia> \u03bb,v=quasinewton(nep,v=ones(size(nep,1)));\njulia> norm(compute_Mlincomb(nep,\u03bb,v))/norm(v)\n6.301479387102376e-15  References   Jarlebring, Koskela, Mele, Disguised and new Quasi-Newton methods for nonlinear eigenvalue problems, arxiv preprint: https://arxiv.org/abs/1702.08492   #  NonlinearEigenproblems.NEPSolver.mslp  \u2014  Function .   mslp([eltype],nep::NEP;[errmeasure,][tol,][maxit,][\u03bb,][v,][displaylevel,][eigsolvertype::DataType][armijo_factor=1,][armijo_max])  Runs the method of successive linear problems. The  method requires the solution of a generalized eigenvalue problem in every iteration. The method used for the eigenvalue computation is specified in eigsolvertype. See  newton  for other parameters.  Example  Create a rational NEP with SPMFs.  julia> Av=[ones(3,3),eye(3,3),triu(ones(3,3))];\njulia> fv=[S-> S, S -> S^2, S::AbstractArray -> inv(Matrix(S)-eye(S)*10)]\njulia> nep=SPMF_NEP(Av,fv)\njulia> (\u03bb,v)=mslp(nep)\njulia> compute_Mlincomb(nep,\u03bb,v)\n3-element Array{Complex{Float64},1}:\n -1.38778e-17+1.65715e-18im\n -5.55112e-17+1.30633e-17im\n -4.16334e-17-1.54436e-17im  References   A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689   #  NonlinearEigenproblems.NEPSolver.rfi  \u2014  Function .  rfi(nep,nept,[\u03bb=0,][errmeasure=default_errmeasure,][tol=eps()*100,][maxit=100,][v=randn,][u=randn,][displaylevel=0,][linsolvecreator=default_linsolvecreator,])  This is an implementation of the two-sided Rayleigh functional Iteration. This method requires the transpose of the NEP, which needs to be provided in nept.  Example:  julia> nep=nep gallery(\"dep0\"); julia> nept=DEP([nep.A[1]',nep.A[2]']) julia> \u03bb,v,u=rfi(nep,nept,v=ones(size(nep,1))) julia> opnorm(compute Mder(nep,\u03bb) v) % v is a right eigenvector 5.4672143489065705e-16 julia> opnorm(u' compute_Mder(nep,\u03bb)) % u is a left eigenvector 4.1447913221215544e-16  Reference   Algorithm 4 in  Schreiber, Nonlinear Eigenvalue Problems: Newton-type Methods and Nonlinear Rayleigh Functionals, PhD thesis, TU Berlin, 2008   #  NonlinearEigenproblems.NEPSolver.newtonqr  \u2014  Function .  Newton-QR method.  #  NonlinearEigenproblems.NEPSolver.implicitdet  \u2014  Function .  Implicit determinant method  #  NonlinearEigenproblems.NEPSolver.broyden  \u2014  Function .  S,V = broyden([eltype,]nep::NEP[,approxnep::NEP];kwargs)  Runs Broydens method (with deflation) for the nonlinear eigenvalue problem defined by nep. An approximate nep can be provided which is used as an initialization of starting matrix/vectors.  The method computes an invariant pair and can therefore find several eigenvalues. The retured value is (S,V) is an invariant pair and the eigenvalues are on the diagonal of S.  Example  julia> nep=nep_gallery(\"dep0\");\njulia> S,V=broyden(nep);\njulia> \u03bb=S[1,1]\n-0.3587189459686267 - 3.0010731412746105e-31im\njulia> minimum(svdvals(compute_Mder(nep,\u03bb)))\n1.6066157878930856e-16\njulia> \u03bb=S[2,2]\n-0.04093521177097334 + 1.486011530941621im\njulia> minimum(svdvals(compute_Mder(nep,\u03bb)))\n4.159109513753696e-16\njulia> \u03bb=S[3,3]\n0.8347353572199486 + 1.5032076225139986e-14im\njulia> minimum(svdvals(compute_Mder(nep,\u03bb)))\n1.296144276122994e-14\njulia> broyden(nep,displaylevel=2,check_error_every=1);  % Prints out a lot more convergence info  References   Jarlebring, Broyden\u2019s method for nonlinear eigenproblems, 2018, https://arxiv.org/pdf/1802.07322",
            "title": "Newton type methods"
        },
        {
            "location": "/methods/#projection-methods",
            "text": "nlar",
            "title": "Projection methods"
        },
        {
            "location": "/methods/#arnoldi-type-methods",
            "text": "#  NonlinearEigenproblems.NEPSolver.iar  \u2014  Function .  iar(nep,[maxit=30,][\u03c3=0,][\u03b3=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])  Infinite Arnoldi method  Runs the infinite Arnoldi method which tries to find eigenvalues close to the shift \u03c3.  Example  julia> using NonlinearEigenproblems: NEPSolver, NEPCore, Gallery\njulia> nep=nep_gallery(\"dep0\");\njulia> \u03bb,v=iar(nep);\njulia> minimum(svdvals(compute_Mder(nep,\u03bb[1]))) % Is it an eigenvalue?  References   Algorithm 2 in Jarlebring, Michiels Meerbergen, A linear eigenvalue algorithm for the nonlinear eigenvalue problem, Numer. Math, 2012   #  NonlinearEigenproblems.NEPSolver.tiar  \u2014  Function .  tiar(nep,[maxit=30,][\u03c3=0,][\u03b3=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])  Runs the tensor infinite Arnoldi method which tries to find eigenvalues close to the shift \u03c3.  Example  julia> using NonlinearEigenproblems: NEPSolver, NEPCore, Gallery\njulia> nep=nep_gallery(\"dep0\",100);\njulia> v0=ones(size(nep,1));\njulia> \u03bb,v=iar(nep,v=v0,tol=1e-5,Neig=3);\njulia> \u03bb\n3-element Array{Complex{Float64},1}:\n -0.156062-0.122734im\n -0.156062+0.122734im\n  0.231692+4.82981e-17im\njulia> \u03bb,v=iar(nep,v=v0,tol=1e-5,Neig=3);\njulia> \u03bb  % Same eigenvalues are computed\n3-element Array{Complex{Float64},1}:\n -0.156062-0.122734im\n -0.156062+0.122734im\n  0.231692+4.82981e-17im  References   Algorithm 2 in Jarlebring, Mele, Runborg, The Waveguide Eigenvalue Problem and the Tensor Infinite Arnoldi Method, SIAM J. Scient. computing, 39 (3), A1062-A1088, 2017   #  NonlinearEigenproblems.NEPSolver.infbilanczos  \u2014  Function .  \u03bbv,V,U=infbilanczos([eltype],nep, nept,[linsolvecreator,][linsolvertcreator,][v,][u,][\u03c3,][\u03b3,][tol,][Neig,][errmeasure,][displaylevel,][maxit,][check_error_every])  Executes the Infinite Bi-Lanczos method on the problem defined by  nep::NEP  and  nept::NEP .  nep:NEP  is the original nonlinear eigenvalue problem and  nept::NEP  is its (hermitian) transpose: $M(\u03bb^*)^H$.   v  and  u  are starting vectors,  \u03c3  is the shift and  \u03b3  the scaling.  See  newton()  for other parameters.  Example:  julia> nep=nep_gallery(\"dep0\");\njulia> A=get_Av(nep); fv=get_fv(nep);\njulia> nept=SPMF_NEP([A[1]',A[2]',A[3]'],fv); # Create the transposed NEP\njulia> \u03bbv,V=infbilanczos(nep,nept,Neig=3)\njulia> norm(compute_Mlincomb(nep,\u03bbv[1],V[:,1]))  References:   The infinite bi-Lanczos method for nonlinear eigenvalue problems, S. W. Gaaf and E. Jarlebring, arxiv: 1607.03454, to appear in SIAM J. Scientific Computing",
            "title": "Arnoldi type methods"
        },
        {
            "location": "/methods/#class-specific-methods",
            "text": "",
            "title": "Class specific methods"
        },
        {
            "location": "/methods/#companion-linearizations",
            "text": "",
            "title": "Companion linearizations"
        },
        {
            "location": "/methods/#rational",
            "text": "",
            "title": "Rational ?"
        },
        {
            "location": "/types/",
            "text": "The basic type\n\n\nThe basic class is the abstract class \nNEP\n which represents a NEP. \n\n\n#\n\n\nNonlinearEigenproblems.NEPCore.NEP\n \u2014 \nType\n.\n\n\nabstract NEP\n\n\n\n\nA \nNEP\n object represents a nonlinear eigenvalue problem. All NEPs should implement\n\n\nsize(nep::NEP,d)\n\n\n\n\nand at least one of the following\n\n\nM=compute_Mder(nep::NEP,\u03bb::Number;der=0)\nV=compute_Mlincomb(nep::NEP,\u03bb::Number,V::Array{<:Number,2})\nMM=compute_MM(nep::NEP,S::Array{<:Number,2},V::Array{<:Number,2})\n\n\n\n\n\n\nAccessing the NEP\n\n\nThe nonlinear eigenvalue problem is defined by the data stored in the NEP-class, and the NEP-solvers access the data mainly through three main functions, \ncompute_Mder\n \ncompute_Mlincomb\n and \ncompute_MM\n.\n\n\ncompute_Mder(nep::NEPCore.NEP, \u03bb::Number, i::Integer) \ncompute_Mlincomb(nep::NEPCore.NEP, \u03bb::Number, V; a)\ncompute_MM\n\n\n\n\n\n\nNEPTypes\n\n\nIn order to use the methods, the user has the possibility to implement their own problem-specific functions above, or use one of the predefined types. The most common one is the \nSPMF_NEP\n.\n\n\n#\n\n\nNonlinearEigenproblems.NEPTypes.SPMF_NEP\n \u2014 \nType\n.\n\n\nstruct SPMF_NEP <: AbstractSPMF\n\n\n\n\nAn SPMF_NEP is a NEP defined by a Sum of Products of Matrices and Functions, i.e.,\n\n\n$$\nM(\u03bb)=\u2211_i A_i f_i(\u03bb).\n$$\n\n\nAll of the matrices $A_0,...$ are of size $n\u00d7n$ and $f_i$ are a functions. The  functions $f_i$ must be defined for matrices in the standard matrix function sense.\n\n\nIn order to construct an \nSPMF_NEP\n, we need to provide the matrices and the functions.\n\n\nSPMF_NEP(AA::Array, fii::Array{Function,1}) \n\n\n\n\n#\n\n\nNonlinearEigenproblems.NEPCore.compute_Mder\n \u2014 \nFunction\n.\n\n\ncompute_Mder(nep::NEP,\u03bb::Number [,i::Integer=0])\n\n\n\n\nComputes the ith derivative of \nnep\n evaluated in \n\u03bb\n.\n\n\nExample\n\n\nThis example shows that \ncompute_Mder(nep,\u03bb,1)\n gives the first derivative.\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> \u03f5=1e-5;\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aplus=compute_Mder(nep,\u03bb+\u03f5);\njulia> opnorm((Aplus-Aminus)/(2\u03f5)-compute_Mder(nep,\u03bb,1))\n1.990970375089371e-11\n\n\n\n\n#\n\n\nNonlinearEigenproblems.NEPCore.compute_Mlincomb\n \u2014 \nFunction\n.\n\n\ncompute_Mlincomb(nep::NEP,\u03bb::Number,V,a::Array,startder::Integer)\n\n\n\n\nComputes linear combination starting with derivative startder, i.e., $\u03a3_i a_i M^{(i+startder)}(\u03bb) v_i$\n\n\nThe default implementation of this can be slow. Overload for specific NEP if you want efficiency (for aug_newton, IAR, ..).\n\n\nLet's try an equation $x=f(x)$. (a \\ne 0)\n\n\n$$\nx=x_1+1\n$$",
            "title": "NEP Types"
        },
        {
            "location": "/types/#the-basic-type",
            "text": "The basic class is the abstract class  NEP  which represents a NEP.   #  NonlinearEigenproblems.NEPCore.NEP  \u2014  Type .  abstract NEP  A  NEP  object represents a nonlinear eigenvalue problem. All NEPs should implement  size(nep::NEP,d)  and at least one of the following  M=compute_Mder(nep::NEP,\u03bb::Number;der=0)\nV=compute_Mlincomb(nep::NEP,\u03bb::Number,V::Array{<:Number,2})\nMM=compute_MM(nep::NEP,S::Array{<:Number,2},V::Array{<:Number,2})",
            "title": "The basic type"
        },
        {
            "location": "/types/#accessing-the-nep",
            "text": "The nonlinear eigenvalue problem is defined by the data stored in the NEP-class, and the NEP-solvers access the data mainly through three main functions,  compute_Mder   compute_Mlincomb  and  compute_MM .  compute_Mder(nep::NEPCore.NEP, \u03bb::Number, i::Integer) \ncompute_Mlincomb(nep::NEPCore.NEP, \u03bb::Number, V; a)\ncompute_MM",
            "title": "Accessing the NEP"
        },
        {
            "location": "/types/#neptypes",
            "text": "In order to use the methods, the user has the possibility to implement their own problem-specific functions above, or use one of the predefined types. The most common one is the  SPMF_NEP .  #  NonlinearEigenproblems.NEPTypes.SPMF_NEP  \u2014  Type .  struct SPMF_NEP <: AbstractSPMF  An SPMF_NEP is a NEP defined by a Sum of Products of Matrices and Functions, i.e.,  $$\nM(\u03bb)=\u2211_i A_i f_i(\u03bb).\n$$  All of the matrices $A_0,...$ are of size $n\u00d7n$ and $f_i$ are a functions. The  functions $f_i$ must be defined for matrices in the standard matrix function sense.  In order to construct an  SPMF_NEP , we need to provide the matrices and the functions.  SPMF_NEP(AA::Array, fii::Array{Function,1})   #  NonlinearEigenproblems.NEPCore.compute_Mder  \u2014  Function .  compute_Mder(nep::NEP,\u03bb::Number [,i::Integer=0])  Computes the ith derivative of  nep  evaluated in  \u03bb .  Example  This example shows that  compute_Mder(nep,\u03bb,1)  gives the first derivative.  julia> nep=nep_gallery(\"dep0\");\njulia> \u03f5=1e-5;\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aplus=compute_Mder(nep,\u03bb+\u03f5);\njulia> opnorm((Aplus-Aminus)/(2\u03f5)-compute_Mder(nep,\u03bb,1))\n1.990970375089371e-11  #  NonlinearEigenproblems.NEPCore.compute_Mlincomb  \u2014  Function .  compute_Mlincomb(nep::NEP,\u03bb::Number,V,a::Array,startder::Integer)  Computes linear combination starting with derivative startder, i.e., $\u03a3_i a_i M^{(i+startder)}(\u03bb) v_i$  The default implementation of this can be slow. Overload for specific NEP if you want efficiency (for aug_newton, IAR, ..).  Let's try an equation $x=f(x)$. (a \\ne 0)  $$\nx=x_1+1\n$$",
            "title": "NEPTypes"
        },
        {
            "location": "/transformations/",
            "text": "Transforming NEPs\n\n\nThere are various ways to transform NEPs into other NEPs. The simplest example is the function \nshift_and_scale()\n.\n\n\n#\n\n\nNonlinearEigenproblems.NEPTypes.shift_and_scale\n \u2014 \nFunction\n.\n\n\nshift_and_scale(orgnep::NEP;shift=0,scale=1)\n\n\n\n\nTransforms the orgnep by defining a new NEP from the relation T(\u03bb)=M(scale * \u03bb+shift) where M is the orgnep. This function tries  to preserve the NEP type, e.g., a shift\nand\nscale operation on an SPMF-object, return an SPMF object. If it cannot preserve the type, it will return a nep of the struct \nShiftScaledNEP\n.\n\n\nExample\n\n\njulia> nep0=nep_gallery(\"pep0\")\njulia> \u03c3=3; \u03b1=10;\njulia> nep1=shift_and_scale(nep0,shift=\u03c3,scale=\u03b1)\njulia> opnorm(compute_Mder(nep0,\u03b1*(4+4im)+\u03c3)-compute_Mder(nep1,4+4im))\n8.875435870738592e-12\n\n\n\n\nSimilarly \nmobius_transform()\n is more general than \nshift_and_scale\n which transform the problem using a M\u00f6bius transformation. The function \ntaylor_exp\n create new PEP by doing truncating a Taylor expansion.\n\n\n\n\nProjection\n\n\nSeveral methods for NEPs are based on forming a smaller NEP, which we will refer to as a projection:\n\n\n$$\nN(\u03bb)=W^HM(\u03bb)V,\n$$\n\n\nwhere $V,W\\in\\mathbb{C}^{n\\times p}$  and the corresponding projected problem\n\n\n$$\nN(\u03bb)u=0.\n$$\n\n\nNEPs which for which this projection can be computed inherit from \nProjectableNEP\n. The most important type is the \nSPMF_NEP\n. \n\n\nYou can create a projected NEP with \ncreate_proj_NEP\n:\n\n\n#\n\n\nNonlinearEigenproblems.NEPTypes.create_proj_NEP\n \u2014 \nFunction\n.\n\n\npnep=create_proj_NEP(orgnep::ProjectableNEP)\n\n\n\n\nCreate a NEP representing a projected problem. The projection is defined as the problem $N(\u03bb)=W^HM(\u03bb)V$ where $M(\u03bb)$ is represented by \norgnep\n. Use \nset_projectionmatrices!()\n to specify projection matrices $V$ and $W$.\n\n\n#\n\n\nNonlinearEigenproblems.NEPTypes.set_projectmatrices!\n \u2014 \nMethod\n.\n\n\nset_projectmatrices!(pnep::Proj_NEP,W,V)\n\n\n\n\nSet the projection matrices for the NEP to W and V, i.e., corresponding the NEP: $N(\u03bb)=W^HM(\u03bb)V$.\n\n\nExample:\n\n\nThe following example illustrates that a projection of a \nNEP\n is also a \nNEP\n and we can for instance call \ncompute_Mder\non it:\n\n\njulia> nep=nep_gallery(\"pep0\")\njulia> V=eye(size(nep,1),2);\njulia> W=eye(size(nep,1),2);\njulia> pnep=create_proj_NEP(nep);\njulia> set_projectmatrices!(pnep,W,V);\njulia> compute_Mder(pnep,\u03bb)\n2\u00d72 Array{Float64,2}:\n -2.03662   13.9777\n -1.35069  -13.0975\njulia> compute_Mder(nep,\u03bb)[1:2,1:2]\n2\u00d72 Array{Float64,2}:\n -2.03662   13.9777\n -1.35069  -13.0975\n\n\n\n\n\n\nDeflation\n\n\nDue to structure of the representation of NEPs in NEP-PACK it is possible to do deflation, by transformation of the NEP-object. The deflation is based on theory provided in Effenbergers thesis and the main function consists of \neffenberger_deflation\n.\n\n\n#\n\n\nNonlinearEigenproblems.NEPTypes.effenberger_deflation\n \u2014 \nFunction\n.\n\n\neffenberger_deflation(nep::NEP,S0,V0)\n\n\n\n\nThis function creates a deflated NEP based on (S0,V0), which are assumed to an invariant pair of \nnep\n. Effectively, the function should return a NEP which has the same solutions as orgnep, except those corresponding to (S0,V0).\n\n\nExample:\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> (\u03bb,v)=newton(nep);\njulia> n=size(nep,1);\njulia> S0=reshape([\u03bb],1,1);\njulia> V0=reshape(v,n,1);\njulia> dnep=effenberger_deflation(nep,S0,V0)\njulia> (\u03bb2,v2)=augnewton(dnep);  # this converges to different eigval\njulia> minimum(svdvals(compute_Mder(nep,\u03bb2)))\n9.323003321058995e-17\n\n\n\n\nReferences\n\n\n\n\nC. Effenberger, Robust solution methods for nonlinear eigenvalue problems, PhD thesis, 2013, EPF Lausanne",
            "title": "NEP transformations"
        },
        {
            "location": "/transformations/#transforming-neps",
            "text": "There are various ways to transform NEPs into other NEPs. The simplest example is the function  shift_and_scale() .  #  NonlinearEigenproblems.NEPTypes.shift_and_scale  \u2014  Function .  shift_and_scale(orgnep::NEP;shift=0,scale=1)  Transforms the orgnep by defining a new NEP from the relation T(\u03bb)=M(scale * \u03bb+shift) where M is the orgnep. This function tries  to preserve the NEP type, e.g., a shift and scale operation on an SPMF-object, return an SPMF object. If it cannot preserve the type, it will return a nep of the struct  ShiftScaledNEP .  Example  julia> nep0=nep_gallery(\"pep0\")\njulia> \u03c3=3; \u03b1=10;\njulia> nep1=shift_and_scale(nep0,shift=\u03c3,scale=\u03b1)\njulia> opnorm(compute_Mder(nep0,\u03b1*(4+4im)+\u03c3)-compute_Mder(nep1,4+4im))\n8.875435870738592e-12  Similarly  mobius_transform()  is more general than  shift_and_scale  which transform the problem using a M\u00f6bius transformation. The function  taylor_exp  create new PEP by doing truncating a Taylor expansion.",
            "title": "Transforming NEPs"
        },
        {
            "location": "/transformations/#projection",
            "text": "Several methods for NEPs are based on forming a smaller NEP, which we will refer to as a projection:  $$\nN(\u03bb)=W^HM(\u03bb)V,\n$$  where $V,W\\in\\mathbb{C}^{n\\times p}$  and the corresponding projected problem  $$\nN(\u03bb)u=0.\n$$  NEPs which for which this projection can be computed inherit from  ProjectableNEP . The most important type is the  SPMF_NEP .   You can create a projected NEP with  create_proj_NEP :  #  NonlinearEigenproblems.NEPTypes.create_proj_NEP  \u2014  Function .  pnep=create_proj_NEP(orgnep::ProjectableNEP)  Create a NEP representing a projected problem. The projection is defined as the problem $N(\u03bb)=W^HM(\u03bb)V$ where $M(\u03bb)$ is represented by  orgnep . Use  set_projectionmatrices!()  to specify projection matrices $V$ and $W$.  #  NonlinearEigenproblems.NEPTypes.set_projectmatrices!  \u2014  Method .  set_projectmatrices!(pnep::Proj_NEP,W,V)  Set the projection matrices for the NEP to W and V, i.e., corresponding the NEP: $N(\u03bb)=W^HM(\u03bb)V$.  Example:  The following example illustrates that a projection of a  NEP  is also a  NEP  and we can for instance call  compute_Mder on it:  julia> nep=nep_gallery(\"pep0\")\njulia> V=eye(size(nep,1),2);\njulia> W=eye(size(nep,1),2);\njulia> pnep=create_proj_NEP(nep);\njulia> set_projectmatrices!(pnep,W,V);\njulia> compute_Mder(pnep,\u03bb)\n2\u00d72 Array{Float64,2}:\n -2.03662   13.9777\n -1.35069  -13.0975\njulia> compute_Mder(nep,\u03bb)[1:2,1:2]\n2\u00d72 Array{Float64,2}:\n -2.03662   13.9777\n -1.35069  -13.0975",
            "title": "Projection"
        },
        {
            "location": "/transformations/#deflation",
            "text": "Due to structure of the representation of NEPs in NEP-PACK it is possible to do deflation, by transformation of the NEP-object. The deflation is based on theory provided in Effenbergers thesis and the main function consists of  effenberger_deflation .  #  NonlinearEigenproblems.NEPTypes.effenberger_deflation  \u2014  Function .  effenberger_deflation(nep::NEP,S0,V0)  This function creates a deflated NEP based on (S0,V0), which are assumed to an invariant pair of  nep . Effectively, the function should return a NEP which has the same solutions as orgnep, except those corresponding to (S0,V0).  Example:  julia> nep=nep_gallery(\"dep0\");\njulia> (\u03bb,v)=newton(nep);\njulia> n=size(nep,1);\njulia> S0=reshape([\u03bb],1,1);\njulia> V0=reshape(v,n,1);\njulia> dnep=effenberger_deflation(nep,S0,V0)\njulia> (\u03bb2,v2)=augnewton(dnep);  # this converges to different eigval\njulia> minimum(svdvals(compute_Mder(nep,\u03bb2)))\n9.323003321058995e-17  References   C. Effenberger, Robust solution methods for nonlinear eigenvalue problems, PhD thesis, 2013, EPF Lausanne",
            "title": "Deflation"
        },
        {
            "location": "/gallery/",
            "text": "A large number of examples are provided in the \nnep_gallery\n.\n\n\njulia> using Gallery\njulia> nep=nep_gallery(\"dep0\")\njulia> \u03bb,v=newton(nep)\n(-0.3587189459686265 + 0.0im, Complex{Float64}[0.284742+0.0im, -0.143316+0.0im, 0.278378+0.0im, -0.5009+0.0im, -0.613634+0.0im])\njulia> norm(compute_Mlincomb(nep,\u03bb,v))\n4.718447854656915e-16\n\n\n\n\nIf MATLAB and the Berlin-Manchester collection areinstalled, we can access them with the GalleryNLEVP (which does MATLAB-access through julia's MATLAB-package).\n\n\njulia> using GalleryNLEVP\njulia> nep=nep_gallery(NLEVP_NEP,\"hadeler\")\njulia> \u03bb,v=quasinewton(nep,\u03bb=0.2,displaylevel=1,maxit=20,tol=1e-10);\njulia> norm(compute_Mlincomb(nep,\u03bb,v))/norm(v)\n9.698206079849311e-11\n\n\n\n\nProblems loaded from the Berlin-Manchester collection are NEP-objects where every call to access a function generates a call to an underlying MATLAB-session. Some problems in the Berlin-Manchester collection have native support in NEPPACK, i.e., avoiding a MATLAB-access in every call. The native equivalent object is generated with  \nnlevp_make_native\n:\n\n\njulia> using GalleryNLEVP\njulia> nep1=nep_gallery(NLEVP_NEP,\"gun\")\njulia> nep2=nlevp_make_native(nep1);\njulia> norm(compute_Mder(nep1,0)-compute_Mder(nep2,0),1)\n0.0\n\n\n\n\nStand-alone implementation can be accessed in a similar way, e.g., a native implementation of the waveguide eigenvalue problem:\n\n\njulia> using GalleryWaveguide\njulia> nep=nep_gallery(WEP,benchmark_problem=\"TAUSCH\");",
            "title": "NEP Gallery"
        },
        {
            "location": "/development/",
            "text": "Developer info\n\n\n\n\nCompiling the documentation\n\n\nCompile this documentation page by running:\n\n\njarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ julia --color=yes make.jl &&  mkdocs build --clean\njarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ firefox site/index.html\n\n\n\n\nIf you want this to appear on our documentation page \nhttps://nep-pack.github.io/NonlinearEigenproblems.jl/\n you need to push it to the \ngh-branch\n, e.g.,  by running\n\n\njarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ export DOCSDIR=`pwd`\njarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ cd /tmp\njarl@bjork:/tmp$ git clone -b \"gh-pages\" git@github.com:nep-pack/NonlinearEigenproblems.jl.git\njarl@bjork:/tmp$ cd NonlinearEigenproblems.jl\njarl@bjork:/tmp/NonlinearEigenproblems.jl$ cp -r $DOCSDIR/site/* .\njarl@bjork:/tmp/NonlinearEigenproblems.jl$ git add *;  git commit . -m \"refresh docs\"; git push\n\n\n\n\nMore information about \nDocumenter.jl\n: \nhere",
            "title": "Developer info"
        },
        {
            "location": "/development/#developer-info",
            "text": "",
            "title": "Developer info"
        },
        {
            "location": "/development/#compiling-the-documentation",
            "text": "Compile this documentation page by running:  jarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ julia --color=yes make.jl &&  mkdocs build --clean\njarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ firefox site/index.html  If you want this to appear on our documentation page  https://nep-pack.github.io/NonlinearEigenproblems.jl/  you need to push it to the  gh-branch , e.g.,  by running  jarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ export DOCSDIR=`pwd`\njarl@bjork:~/src/NonlinearEigenproblems.jl/docs$ cd /tmp\njarl@bjork:/tmp$ git clone -b \"gh-pages\" git@github.com:nep-pack/NonlinearEigenproblems.jl.git\njarl@bjork:/tmp$ cd NonlinearEigenproblems.jl\njarl@bjork:/tmp/NonlinearEigenproblems.jl$ cp -r $DOCSDIR/site/* .\njarl@bjork:/tmp/NonlinearEigenproblems.jl$ git add *;  git commit . -m \"refresh docs\"; git push  More information about  Documenter.jl :  here",
            "title": "Compiling the documentation"
        }
    ]
}