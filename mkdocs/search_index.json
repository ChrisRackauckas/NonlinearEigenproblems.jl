{
    "docs": [
        {
            "location": "/",
            "text": "NEPCore Documentation\n\n\n#\n\n\nNEPCore.NEP\n \u2014 \nType\n.\n\n\nabstract NEP\n\n\n\n\nA NEP object represents a nonlinear eigenvalue problem. All NEPs should implement\n\n\nsize(nep::NEP,d)\n\n\n\n\nand at least one of the following\n\n\nM=compute_Mder(nep::NEP,\u03bb::Number;der=0)\nV=compute_Mlincomb(nep::NEP,\u03bb::Number,V::Array{<:Number,2})\nMM=compute_MM(nep::NEP,S::Array{<:Number,2},V::Array{<:Number,2})\n\n\n\n\n#\n\n\nNEPTypes.SPMF_NEP\n \u2014 \nType\n.\n\n\ntype SPMF_NEP <: AbstractSPMF\n\n\n\n\nAn SPMF_NEP is a NEP defined by a Sum of Products of Matrices and Functions, i.e.,\n\n\n$$\nM(\u03bb)=\u2211_i A_i f_i(\u03bb).\n$$\n\n\nAll of the matrices $A_0,...$ are of size $n\u00d7n$ and $f_i$ are a functions. The  functions $f_i$ must be defined for matrices in the standard matrix function sense. \n\n\n#\n\n\nNEPTypes.SPMF_NEP\n \u2014 \nMethod\n.\n\n\n SPMF_NEP(AA,fii,Schur_fact=false)\n\n\n\n\nCreates a SPMF_NEP consisting of matrices \nAA\n and functions \nfii\n. \nfii\n must be an array of functions defined for matrices. \nAA\n is an array of matrices. \nSchur_fact\n specifies if the computation of \ncompute_MM\n should be done by first pre-computing a Schur-factorization (which can be faster).\n\n\njulia> A0=[1 3; 4 5]; A1=[3 4; 5 6];\njulia> id_op=S -> eye(S)\njulia> exp_op=S -> expm(S)\njulia> nep=SPMF_NEP([A0,A1],[id_op,exp_op]);\njulia> compute_Mder(nep,1)-(A0+A1*exp(1))\n2\u00d72 Array{Float64,2}:\n 0.0  0.0\n 0.0  0.0\n\n\n\n\n#\n\n\nNEPCore.compute_Mder\n \u2014 \nFunction\n.\n\n\ncompute_Mder(nep::NEP,\u03bb::Number [,i::Integer=0])\n\n\n\n\nComputes the ith derivative of \nnep\n evaluated in \n\u03bb\n.\n\n\nExample\n\n\nThis example shows that \ncompute_Mder(nep,\u03bb,1)\n gives the first derivative.\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> \u03f5=1e-5;\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aplus=compute_Mder(nep,\u03bb+\u03f5);\njulia> norm((Aplus-Aminus)/(2\u03f5)-compute_Mder(nep,\u03bb,1))\n1.990970375089371e-11\n\n\n\n\n#\n\n\nNEPCore.compute_Mlincomb\n \u2014 \nFunction\n.\n\n\ncompute_Mlincomb(nep::NEP,\u03bb::Number,V;a=ones(size(V,2)))\n\n\n\n\nComputes the linear combination of derivatives\n$\u03a3_i a_i M^{(i)}(\u03bb) v_i$\n\n\nExample\n\n\nThis example shows that \ncompute_Mder\n gives a result consistent with \ncompute_Mlincomb\n. Note that \ncompute_Mlincomb\n is in general faster since no matrix needs to be constructed.\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> v=ones(size(nep,1)); \u03bb=-1+1im;\njulia> norm(compute_Mder(nep,\u03bb,1)*v-compute_Mlincomb(nep,\u03bb,hcat(v,v),a=[0,1]))\n1.0778315928076987e-15\n\n\n\n\n\ncompute_Mlincomb(nep::NEP,\u03bb::Number,V,a::Array,startder::Integer)\n\n\n\n\nComputes linear combination starting with derivative startder, i.e., $\u03a3_i a_i M^{(i+startder)}(\u03bb) v_i$\n\n\nThe default implementation of this can be slow. Overload for specific NEP if you want efficiency (for aug_newton, IAR, ..).\n\n\nLet's try an equation $x=f(x)$. (a \\ne 0)\n\n\n$$\nx=x_1+1\n$$\n\n\n\n\nCompiling the documentation\n\n\nCompile this documentation page by running:\n\n\njarl@bjork:~/jobb/src/nep-pack-alpha/docs$ julia --color=yes make.jl\njarl@bjork:~/jobb/src/nep-pack-alpha/docs$ mkdocs build --clean\njarl@bjork:~/jobb/src/nep-pack-alpha/docs$ firefox site/index.html\n\n\n\n\nIf you want this to appear on our documentation page \nhttps://gitr.sys.kth.se/pages/nep-pack/nep-pack-alpha/\n you need to push it to the \ngh-branch\n, e.g.,  by running\n\n\njarl@bjork:~/jobb/src/nep-pack-alpha/docs$ export DOCSDIR=`pwd`\njarl@bjork:~/jobb/src/nep-pack-alpha/docs$ cd /tmp\njarl@bjork:/tmp$ git clone -b \"gh-pages\" git@gitr.sys.kth.se:nep-pack/nep-pack-alpha.git\njarl@bjork:/tmp$ cd nep-pack-alpha\njarl@bjork:/tmp/nep-pack-alpha$ cp -r $DOCSDIR/site/* .\njarl@bjork:/tmp/nep-pack-alpha$ git add *\njarl@bjork:/tmp/nep-pack-alpha$ git commit .\njarl@bjork:/tmp/nep-pack-alpha$ git push\n\n\n\n\nMore information about \nDocumenter.jl\n: \nhere\n\n\n\n\nNEP methods\n\n\n\n\nNewton type methods\n\n\n#\n\n\nNEPSolver.newton\n \u2014 \nFunction\n.\n\n\n\u03bb,v = newton([eltype],nep::NEP;[errmeasure,][tol,][maxit,][\u03bb,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max])\n\n\n\n\nApplies Newton-Raphsons method on nonlinear equation with \n(n+1)\n unknowns. errmeasure is a function handle which specifies provides a procedure for error measure and termination. The iteration is continued until errmeausure is less than \ntol\n. \n\u03bb\n and \nv\n are starting approximations. \nc\n is the orthogonalization vector.  If \nc=0\n the current approximation will be used for the orthogonalization. \narmijo_factor\n specifies if an Armijo rule should be applied, and its value specifies the scaling factor of the step length (per reduction step). The variable \narmijo_max\n specifies the maximum number of step length reductions.\n\n\nExample\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> \u03bb,v=newton(nep);\njulia> minimum(svdvals(compute_Mder(nep,\u03bb)))\n1.6066157878930876e-16\n\n\n\n\nReferences\n\n\n\n\nNichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.\n\n\nA. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689\n\n\n\n\n#\n\n\nNEPSolver.augnewton\n \u2014 \nFunction\n.\n\n\nAugmented Newton's method. Equivalent to newton() but works only with operations on vectors of length n, instead of n+1.\n\n\n\n\n#\n\n\nNEPSolver.resinv\n \u2014 \nFunction\n.\n\n\n\u03bb,v = resinv([eltype],nep::NEP;[errmeasure,][tol,][maxit,][\u03bb,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max,][linsolvecreator])\n\n\n\n\nApplies residual inverse iteration method for nonlinear eigenvalue problems. linsolvecreator is a function which specifies how the linear system is created. See \nnewton()\n for other parameters.\n\n\nExample\n\n\njulia> nep=nep_gallery(\"qdep0\");\njulia> \u03bb,v=resinv(Complex128,nep,\u03bb=-2,v=ones(size(nep,1)))\njulia> norm(compute_Mlincomb(nep,\u03bb,v))\n1.817030659827106e-14                   \n\n\n\n\nReferences\n\n\n\n\nA. Neumaier, Residual inverse iteration for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 22 (1985) 914-923\n\n\n\n\n#\n\n\nNEPSolver.quasinewton\n \u2014 \nFunction\n.\n\n\nquasinewton([T=Complex128],nep,[errmeasure,][tol,][maxit,][\u03bb,][v][ws][displaylevel][linsolvercreator,][armijo_factor,][armijo_max])\n\n\n\n\nAn implementation of the quasi-Newton approach referred to as quasi-Newton 2 in the reference. The method involves one linear system solve per iteration corresponding with the matrix $M(\u03bb)$, where $\u03bb$ is constant. The vector \nws\n is a representation of the normalization, in the sense that $c^T=w_s^TM(\u03bb)$, where all iterates satisfy $c^Tx_i=1$. See \nnewton()\n for other parameters.\n\n\nExample\n\n\njulia> nep=nep_gallery(\"pep0\")\njulia> \u03bb,v=quasinewton(nep,v=ones(size(nep,1)));\njulia> norm(compute_Mlincomb(nep,\u03bb,v))/norm(v)\n6.301479387102376e-15\n\n\n\n\nReferences\n\n\n\n\nJarlebring, Koskela, Mele, Disguised and new Quasi-Newton methods for nonlinear eigenvalue problems, arxiv preprint: https://arxiv.org/abs/1702.08492\n\n\n\n\n#\n\n\nNEPSolver.mslp\n \u2014 \nFunction\n.\n\n\n mslp(nep,..)\n\n\n\n\nMethod of successive linear problems\n\n\n#\n\n\nNEPSolver.rfi\n \u2014 \nFunction\n.\n\n\nrfi(nep,nept,[\u03bb=0,][errmeasure=default_errmeasure,][tol=eps()*100,][maxit=100,][v=randn,][u=randn,][displaylevel=0,][linsolvecreator=default_linsolvecreator,])\n\n\n\n\nTwo-sided Rayleigh functional Iteration, as given as Algorithm 4 in  \"Nonlinear Eigenvalue Problems: Newton-type Methods and Nonlinear Rayleigh Functionals\", by Kathrin Schreiber.\n\n\n#\n\n\nNEPSolver.newtonqr\n \u2014 \nFunction\n.\n\n\nNewton-QR method.\n\n\n\n\n#\n\n\nNEPSolver.implicitdet\n \u2014 \nFunction\n.\n\n\nImplicit determinant method\n\n\n\n\n\n\nProjection methods\n\n\nNEPSolver.nlar\n\n\n\n\n\n\nArnoldi type methods\n\n\n#\n\n\nNEPSolver.iar\n \u2014 \nFunction\n.\n\n\niar(nep,[maxit=30,][\u03c3=0,][\u03b3=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])\n\n\n\n\nInfinite Arnoldi method\n\n\nInfinite Arnoldi method, as described in Algorithm 2 in  \"A linear eigenvalue algorithm for the nonlinear eigenvalue problem\", by Jarlebring, Elias and Michiels, Wim and Meerbergen, Karl.\n\n\n#\n\n\nNEPSolver.tiar\n \u2014 \nFunction\n.\n\n\ntiar(nep,[maxit=30,][\u03c3=0,][\u03b3=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])\n\n\n\n\nTensor Infinite Arnoldi method\n\n\nTensor Infinite Arnoldi method, as described in Algorithm 2 in  \"The Waveguide Eigenvalue Problem and the Tensor Infinite Arnoldi Method\", by Jarlebring, Elias and Mele, Giampaolo and Runborg, Olof.\n\n\n#\n\n\nNEPSolver.infbilanczos\n \u2014 \nFunction\n.\n\n\n\u03bbv,V,U=infbilanczos([eltype],nep, nept,[linsolvecreator,][linsolvertcreator,][v,][u,][\u03c3,][\u03b3,][tol,][Neig,][errmeasure,][displaylevel,][maxit,][check_error_every])\n\n\n\n\nExecutes the Infinite Bi-Lanczos method on the problem defined by nep::NEP and nept::NEP. nep:NEP is the original nonlinear eigenvalue problem and nept::NEP is its (hermitian) transpose. v and u are starting vectors, \u03c3 is the shift and \u03b3 the scaling.  See \nnewton()\n for other parameters.\n\n\nExample:\n\n\njulia> nep=nep_gallery(\"dep0\");\njulia> A=get_Av(nep); fv=get_fv(nep);\njulia> nept=SPMF_NEP([A[1]',A[2]',A[3]'],fv); # Create the transposed NEP\njulia> \u03bbv,V=infbilanczos(nep,nept,Neig=3)\njulia> norm(compute_Mlincomb(nep,\u03bbv[1],V[:,1]))\n\n\n\n\nReferences:\n\n\n\n\nThe infinite bi-Lanczos method for nonlinear eigenvalue problems, S. W. Gaaf and E. Jarlebring, arxiv: 1607.03454, to appear in SIAM J. Scientific Computing\n\n\n\n\n\n\nGallery\n\n\nWEP",
            "title": "Home"
        },
        {
            "location": "/#nepcore-documentation",
            "text": "#  NEPCore.NEP  \u2014  Type .  abstract NEP  A NEP object represents a nonlinear eigenvalue problem. All NEPs should implement  size(nep::NEP,d)  and at least one of the following  M=compute_Mder(nep::NEP,\u03bb::Number;der=0)\nV=compute_Mlincomb(nep::NEP,\u03bb::Number,V::Array{<:Number,2})\nMM=compute_MM(nep::NEP,S::Array{<:Number,2},V::Array{<:Number,2})  #  NEPTypes.SPMF_NEP  \u2014  Type .  type SPMF_NEP <: AbstractSPMF  An SPMF_NEP is a NEP defined by a Sum of Products of Matrices and Functions, i.e.,  $$\nM(\u03bb)=\u2211_i A_i f_i(\u03bb).\n$$  All of the matrices $A_0,...$ are of size $n\u00d7n$ and $f_i$ are a functions. The  functions $f_i$ must be defined for matrices in the standard matrix function sense.   #  NEPTypes.SPMF_NEP  \u2014  Method .   SPMF_NEP(AA,fii,Schur_fact=false)  Creates a SPMF_NEP consisting of matrices  AA  and functions  fii .  fii  must be an array of functions defined for matrices.  AA  is an array of matrices.  Schur_fact  specifies if the computation of  compute_MM  should be done by first pre-computing a Schur-factorization (which can be faster).  julia> A0=[1 3; 4 5]; A1=[3 4; 5 6];\njulia> id_op=S -> eye(S)\njulia> exp_op=S -> expm(S)\njulia> nep=SPMF_NEP([A0,A1],[id_op,exp_op]);\njulia> compute_Mder(nep,1)-(A0+A1*exp(1))\n2\u00d72 Array{Float64,2}:\n 0.0  0.0\n 0.0  0.0  #  NEPCore.compute_Mder  \u2014  Function .  compute_Mder(nep::NEP,\u03bb::Number [,i::Integer=0])  Computes the ith derivative of  nep  evaluated in  \u03bb .  Example  This example shows that  compute_Mder(nep,\u03bb,1)  gives the first derivative.  julia> nep=nep_gallery(\"dep0\");\njulia> \u03f5=1e-5;\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aminus=compute_Mder(nep,\u03bb-\u03f5);\njulia> Aplus=compute_Mder(nep,\u03bb+\u03f5);\njulia> norm((Aplus-Aminus)/(2\u03f5)-compute_Mder(nep,\u03bb,1))\n1.990970375089371e-11  #  NEPCore.compute_Mlincomb  \u2014  Function .  compute_Mlincomb(nep::NEP,\u03bb::Number,V;a=ones(size(V,2)))  Computes the linear combination of derivatives\n$\u03a3_i a_i M^{(i)}(\u03bb) v_i$  Example  This example shows that  compute_Mder  gives a result consistent with  compute_Mlincomb . Note that  compute_Mlincomb  is in general faster since no matrix needs to be constructed.  julia> nep=nep_gallery(\"dep0\");\njulia> v=ones(size(nep,1)); \u03bb=-1+1im;\njulia> norm(compute_Mder(nep,\u03bb,1)*v-compute_Mlincomb(nep,\u03bb,hcat(v,v),a=[0,1]))\n1.0778315928076987e-15  compute_Mlincomb(nep::NEP,\u03bb::Number,V,a::Array,startder::Integer)  Computes linear combination starting with derivative startder, i.e., $\u03a3_i a_i M^{(i+startder)}(\u03bb) v_i$  The default implementation of this can be slow. Overload for specific NEP if you want efficiency (for aug_newton, IAR, ..).  Let's try an equation $x=f(x)$. (a \\ne 0)  $$\nx=x_1+1\n$$",
            "title": "NEPCore Documentation"
        },
        {
            "location": "/#compiling-the-documentation",
            "text": "Compile this documentation page by running:  jarl@bjork:~/jobb/src/nep-pack-alpha/docs$ julia --color=yes make.jl\njarl@bjork:~/jobb/src/nep-pack-alpha/docs$ mkdocs build --clean\njarl@bjork:~/jobb/src/nep-pack-alpha/docs$ firefox site/index.html  If you want this to appear on our documentation page  https://gitr.sys.kth.se/pages/nep-pack/nep-pack-alpha/  you need to push it to the  gh-branch , e.g.,  by running  jarl@bjork:~/jobb/src/nep-pack-alpha/docs$ export DOCSDIR=`pwd`\njarl@bjork:~/jobb/src/nep-pack-alpha/docs$ cd /tmp\njarl@bjork:/tmp$ git clone -b \"gh-pages\" git@gitr.sys.kth.se:nep-pack/nep-pack-alpha.git\njarl@bjork:/tmp$ cd nep-pack-alpha\njarl@bjork:/tmp/nep-pack-alpha$ cp -r $DOCSDIR/site/* .\njarl@bjork:/tmp/nep-pack-alpha$ git add *\njarl@bjork:/tmp/nep-pack-alpha$ git commit .\njarl@bjork:/tmp/nep-pack-alpha$ git push  More information about  Documenter.jl :  here",
            "title": "Compiling the documentation"
        },
        {
            "location": "/#nep-methods",
            "text": "",
            "title": "NEP methods"
        },
        {
            "location": "/#newton-type-methods",
            "text": "#  NEPSolver.newton  \u2014  Function .  \u03bb,v = newton([eltype],nep::NEP;[errmeasure,][tol,][maxit,][\u03bb,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max])  Applies Newton-Raphsons method on nonlinear equation with  (n+1)  unknowns. errmeasure is a function handle which specifies provides a procedure for error measure and termination. The iteration is continued until errmeausure is less than  tol .  \u03bb  and  v  are starting approximations.  c  is the orthogonalization vector.  If  c=0  the current approximation will be used for the orthogonalization.  armijo_factor  specifies if an Armijo rule should be applied, and its value specifies the scaling factor of the step length (per reduction step). The variable  armijo_max  specifies the maximum number of step length reductions.  Example  julia> nep=nep_gallery(\"dep0\");\njulia> \u03bb,v=newton(nep);\njulia> minimum(svdvals(compute_Mder(nep,\u03bb)))\n1.6066157878930876e-16  References   Nichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.  A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689   #  NEPSolver.augnewton  \u2014  Function .  Augmented Newton's method. Equivalent to newton() but works only with operations on vectors of length n, instead of n+1.  #  NEPSolver.resinv  \u2014  Function .  \u03bb,v = resinv([eltype],nep::NEP;[errmeasure,][tol,][maxit,][\u03bb,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max,][linsolvecreator])  Applies residual inverse iteration method for nonlinear eigenvalue problems. linsolvecreator is a function which specifies how the linear system is created. See  newton()  for other parameters.  Example  julia> nep=nep_gallery(\"qdep0\");\njulia> \u03bb,v=resinv(Complex128,nep,\u03bb=-2,v=ones(size(nep,1)))\njulia> norm(compute_Mlincomb(nep,\u03bb,v))\n1.817030659827106e-14                     References   A. Neumaier, Residual inverse iteration for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 22 (1985) 914-923   #  NEPSolver.quasinewton  \u2014  Function .  quasinewton([T=Complex128],nep,[errmeasure,][tol,][maxit,][\u03bb,][v][ws][displaylevel][linsolvercreator,][armijo_factor,][armijo_max])  An implementation of the quasi-Newton approach referred to as quasi-Newton 2 in the reference. The method involves one linear system solve per iteration corresponding with the matrix $M(\u03bb)$, where $\u03bb$ is constant. The vector  ws  is a representation of the normalization, in the sense that $c^T=w_s^TM(\u03bb)$, where all iterates satisfy $c^Tx_i=1$. See  newton()  for other parameters.  Example  julia> nep=nep_gallery(\"pep0\")\njulia> \u03bb,v=quasinewton(nep,v=ones(size(nep,1)));\njulia> norm(compute_Mlincomb(nep,\u03bb,v))/norm(v)\n6.301479387102376e-15  References   Jarlebring, Koskela, Mele, Disguised and new Quasi-Newton methods for nonlinear eigenvalue problems, arxiv preprint: https://arxiv.org/abs/1702.08492   #  NEPSolver.mslp  \u2014  Function .   mslp(nep,..)  Method of successive linear problems  #  NEPSolver.rfi  \u2014  Function .  rfi(nep,nept,[\u03bb=0,][errmeasure=default_errmeasure,][tol=eps()*100,][maxit=100,][v=randn,][u=randn,][displaylevel=0,][linsolvecreator=default_linsolvecreator,])  Two-sided Rayleigh functional Iteration, as given as Algorithm 4 in  \"Nonlinear Eigenvalue Problems: Newton-type Methods and Nonlinear Rayleigh Functionals\", by Kathrin Schreiber.  #  NEPSolver.newtonqr  \u2014  Function .  Newton-QR method.  #  NEPSolver.implicitdet  \u2014  Function .  Implicit determinant method",
            "title": "Newton type methods"
        },
        {
            "location": "/#projection-methods",
            "text": "NEPSolver.nlar",
            "title": "Projection methods"
        },
        {
            "location": "/#arnoldi-type-methods",
            "text": "#  NEPSolver.iar  \u2014  Function .  iar(nep,[maxit=30,][\u03c3=0,][\u03b3=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])  Infinite Arnoldi method  Infinite Arnoldi method, as described in Algorithm 2 in  \"A linear eigenvalue algorithm for the nonlinear eigenvalue problem\", by Jarlebring, Elias and Michiels, Wim and Meerbergen, Karl.  #  NEPSolver.tiar  \u2014  Function .  tiar(nep,[maxit=30,][\u03c3=0,][\u03b3=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])  Tensor Infinite Arnoldi method  Tensor Infinite Arnoldi method, as described in Algorithm 2 in  \"The Waveguide Eigenvalue Problem and the Tensor Infinite Arnoldi Method\", by Jarlebring, Elias and Mele, Giampaolo and Runborg, Olof.  #  NEPSolver.infbilanczos  \u2014  Function .  \u03bbv,V,U=infbilanczos([eltype],nep, nept,[linsolvecreator,][linsolvertcreator,][v,][u,][\u03c3,][\u03b3,][tol,][Neig,][errmeasure,][displaylevel,][maxit,][check_error_every])  Executes the Infinite Bi-Lanczos method on the problem defined by nep::NEP and nept::NEP. nep:NEP is the original nonlinear eigenvalue problem and nept::NEP is its (hermitian) transpose. v and u are starting vectors, \u03c3 is the shift and \u03b3 the scaling.  See  newton()  for other parameters.  Example:  julia> nep=nep_gallery(\"dep0\");\njulia> A=get_Av(nep); fv=get_fv(nep);\njulia> nept=SPMF_NEP([A[1]',A[2]',A[3]'],fv); # Create the transposed NEP\njulia> \u03bbv,V=infbilanczos(nep,nept,Neig=3)\njulia> norm(compute_Mlincomb(nep,\u03bbv[1],V[:,1]))  References:   The infinite bi-Lanczos method for nonlinear eigenvalue problems, S. W. Gaaf and E. Jarlebring, arxiv: 1607.03454, to appear in SIAM J. Scientific Computing",
            "title": "Arnoldi type methods"
        },
        {
            "location": "/#gallery",
            "text": "WEP",
            "title": "Gallery"
        }
    ]
}